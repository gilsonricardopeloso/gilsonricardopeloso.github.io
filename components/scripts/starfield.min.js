!function (t) { var e = {}; function r(n) { if (e[n]) return e[n].exports; var i = e[n] = { i: n, l: !1, exports: {} }; return t[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports } r.m = t, r.c = e, r.d = function (t, e, n) { r.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }) }, r.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, r.t = function (t, e) { if (1 & e && (t = r(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var n = Object.create(null); if (r.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var i in t) r.d(n, i, function (e) { return t[e] }.bind(null, i)); return n }, r.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return r.d(e, "a", e), e }, r.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, r.p = "", r(r.s = 369) }([function (t, e, r) { var n = r(2), i = r(13).f, o = r(15), s = r(16), a = r(83), c = r(110), u = r(56); t.exports = function (t, e) { var r, l, h, f, p, d = t.target, m = t.global, g = t.stat; if (r = m ? n : g ? n[d] || a(d, {}) : (n[d] || {}).prototype) for (l in e) { if (f = e[l], h = t.noTargetGet ? (p = i(r, l)) && p.value : r[l], !u(m ? l : d + (g ? "." : "#") + l, t.forced) && void 0 !== h) { if (typeof f == typeof h) continue; c(f, h) } (t.sham || h && h.sham) && o(f, "sham", !0), s(r, l, f, t) } } }, function (t, e) { t.exports = function (t) { try { return !!t() } catch (t) { return !0 } } }, function (t, e, r) { (function (e) { var r = function (t) { return t && t.Math == Math && t }; t.exports = r("object" == typeof globalThis && globalThis) || r("object" == typeof window && window) || r("object" == typeof self && self) || r("object" == typeof e && e) || Function("return this")() }).call(this, r(156)) }, function (t, e) { t.exports = function (t) { return "object" == typeof t ? null !== t : "function" == typeof t } }, function (t, e, r) { var n = r(3); t.exports = function (t) { if (!n(t)) throw TypeError(String(t) + " is not an object"); return t } }, function (t, e, r) { var n = r(2), i = r(85), o = r(10), s = r(53), a = r(89), c = r(113), u = i("wks"), l = n.Symbol, h = c ? l : l && l.withoutSetter || s; t.exports = function (t) { return o(u, t) || (a && o(l, t) ? u[t] = l[t] : u[t] = h("Symbol." + t)), u[t] } }, function (t, e, r) { var n = r(1); t.exports = !n((function () { return 7 != Object.defineProperty({}, 1, { get: function () { return 7 } })[1] })) }, function (t, e, r) { var n = r(25), i = Math.min; t.exports = function (t) { return t > 0 ? i(n(t), 9007199254740991) : 0 } }, function (t, e, r) { "use strict"; var n, i = r(127), o = r(6), s = r(2), a = r(3), c = r(10), u = r(63), l = r(15), h = r(16), f = r(9).f, p = r(30), d = r(45), m = r(5), g = r(53), v = s.Int8Array, y = v && v.prototype, x = s.Uint8ClampedArray, b = x && x.prototype, w = v && p(v), M = y && p(y), S = Object.prototype, _ = S.isPrototypeOf, T = m("toStringTag"), E = g("TYPED_ARRAY_TAG"), A = i && !!d && "Opera" !== u(s.opera), R = !1, L = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, O = function (t) { return a(t) && c(L, u(t)) }; for (n in L) s[n] || (A = !1); if ((!A || "function" != typeof w || w === Function.prototype) && (w = function () { throw TypeError("Incorrect invocation") }, A)) for (n in L) s[n] && d(s[n], w); if ((!A || !M || M === S) && (M = w.prototype, A)) for (n in L) s[n] && d(s[n].prototype, M); if (A && p(b) !== M && d(b, M), o && !c(M, T)) for (n in R = !0, f(M, T, { get: function () { return a(this) ? this[E] : void 0 } }), L) s[n] && l(s[n], E, n); t.exports = { NATIVE_ARRAY_BUFFER_VIEWS: A, TYPED_ARRAY_TAG: R && E, aTypedArray: function (t) { if (O(t)) return t; throw TypeError("Target is not a typed array") }, aTypedArrayConstructor: function (t) { if (d) { if (_.call(w, t)) return t } else for (var e in L) if (c(L, n)) { var r = s[e]; if (r && (t === r || _.call(r, t))) return t } throw TypeError("Target is not a typed array constructor") }, exportTypedArrayMethod: function (t, e, r) { if (o) { if (r) for (var n in L) { var i = s[n]; i && c(i.prototype, t) && delete i.prototype[t] } M[t] && !r || h(M, t, r ? e : A && y[t] || e) } }, exportTypedArrayStaticMethod: function (t, e, r) { var n, i; if (o) { if (d) { if (r) for (n in L) (i = s[n]) && c(i, t) && delete i[t]; if (w[t] && !r) return; try { return h(w, t, r ? e : A && v[t] || e) } catch (t) { } } for (n in L) !(i = s[n]) || i[t] && !r || h(i, t, e) } }, isView: function (t) { var e = u(t); return "DataView" === e || c(L, e) }, isTypedArray: O, TypedArray: w, TypedArrayPrototype: M } }, function (t, e, r) { var n = r(6), i = r(107), o = r(4), s = r(31), a = Object.defineProperty; e.f = n ? a : function (t, e, r) { if (o(t), e = s(e, !0), o(r), i) try { return a(t, e, r) } catch (t) { } if ("get" in r || "set" in r) throw TypeError("Accessors not supported"); return "value" in r && (t[e] = r.value), t } }, function (t, e) { var r = {}.hasOwnProperty; t.exports = function (t, e) { return r.call(t, e) } }, function (t, e, r) { var n = r(14); t.exports = function (t) { return Object(n(t)) } }, function (t, e, r) { var n = r(36), i = r(52), o = r(11), s = r(7), a = r(59), c = [].push, u = function (t) { var e = 1 == t, r = 2 == t, u = 3 == t, l = 4 == t, h = 6 == t, f = 5 == t || h; return function (p, d, m, g) { for (var v, y, x = o(p), b = i(x), w = n(d, m, 3), M = s(b.length), S = 0, _ = g || a, T = e ? _(p, M) : r ? _(p, 0) : void 0; M > S; S++)if ((f || S in b) && (y = w(v = b[S], S, x), t)) if (e) T[S] = y; else if (y) switch (t) { case 3: return !0; case 5: return v; case 6: return S; case 2: c.call(T, v) } else if (l) return !1; return h ? -1 : u || l ? l : T } }; t.exports = { forEach: u(0), map: u(1), filter: u(2), some: u(3), every: u(4), find: u(5), findIndex: u(6) } }, function (t, e, r) { var n = r(6), i = r(66), o = r(34), s = r(20), a = r(31), c = r(10), u = r(107), l = Object.getOwnPropertyDescriptor; e.f = n ? l : function (t, e) { if (t = s(t), e = a(e, !0), u) try { return l(t, e) } catch (t) { } if (c(t, e)) return o(!i.f.call(t, e), t[e]) } }, function (t, e) { t.exports = function (t) { if (null == t) throw TypeError("Can't call method on " + t); return t } }, function (t, e, r) { var n = r(6), i = r(9), o = r(34); t.exports = n ? function (t, e, r) { return i.f(t, e, o(1, r)) } : function (t, e, r) { return t[e] = r, t } }, function (t, e, r) { var n = r(2), i = r(15), o = r(10), s = r(83), a = r(84), c = r(17), u = c.get, l = c.enforce, h = String(String).split("String"); (t.exports = function (t, e, r, a) { var c = !!a && !!a.unsafe, u = !!a && !!a.enumerable, f = !!a && !!a.noTargetGet; "function" == typeof r && ("string" != typeof e || o(r, "name") || i(r, "name", e), l(r).source = h.join("string" == typeof e ? e : "")), t !== n ? (c ? !f && t[e] && (u = !0) : delete t[e], u ? t[e] = r : i(t, e, r)) : u ? t[e] = r : s(e, r) })(Function.prototype, "toString", (function () { return "function" == typeof this && u(this).source || a(this) })) }, function (t, e, r) { var n, i, o, s = r(109), a = r(2), c = r(3), u = r(15), l = r(10), h = r(67), f = r(54), p = a.WeakMap; if (s) { var d = new p, m = d.get, g = d.has, v = d.set; n = function (t, e) { return v.call(d, t, e), e }, i = function (t) { return m.call(d, t) || {} }, o = function (t) { return g.call(d, t) } } else { var y = h("state"); f[y] = !0, n = function (t, e) { return u(t, y, e), e }, i = function (t) { return l(t, y) ? t[y] : {} }, o = function (t) { return l(t, y) } } t.exports = { set: n, get: i, has: o, enforce: function (t) { return o(t) ? i(t) : n(t, {}) }, getterFor: function (t) { return function (e) { var r; if (!c(e) || (r = i(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required"); return r } } } }, function (t, e, r) { var n = r(111), i = r(10), o = r(117), s = r(9).f; t.exports = function (t) { var e = n.Symbol || (n.Symbol = {}); i(e, t) || s(e, t, { value: o.f(t) }) } }, function (t, e, r) { var n = r(6), i = r(1), o = r(10), s = Object.defineProperty, a = {}, c = function (t) { throw t }; t.exports = function (t, e) { if (o(a, t)) return a[t]; e || (e = {}); var r = [][t], u = !!o(e, "ACCESSORS") && e.ACCESSORS, l = o(e, 0) ? e[0] : c, h = o(e, 1) ? e[1] : void 0; return a[t] = !!r && !i((function () { if (u && !n) return !0; var t = { length: -1 }; u ? s(t, 1, { enumerable: !0, get: c }) : t[1] = 1, r.call(t, l, h) })) } }, function (t, e, r) { var n = r(52), i = r(14); t.exports = function (t) { return n(i(t)) } }, function (t, e) { t.exports = function (t) { if ("function" != typeof t) throw TypeError(String(t) + " is not a function"); return t } }, function (t, e, r) { var n = r(14), i = /"/g; t.exports = function (t, e, r, o) { var s = String(n(t)), a = "<" + e; return "" !== r && (a += " " + r + '="' + String(o).replace(i, "&quot;") + '"'), a + ">" + s + "</" + e + ">" } }, function (t, e, r) { var n = r(1); t.exports = function (t) { return n((function () { var e = ""[t]('"'); return e !== e.toLowerCase() || e.split('"').length > 3 })) } }, function (t, e) { var r = {}.toString; t.exports = function (t) { return r.call(t).slice(8, -1) } }, function (t, e) { var r = Math.ceil, n = Math.floor; t.exports = function (t) { return isNaN(t = +t) ? 0 : (t > 0 ? n : r)(t) } }, function (t, e) { t.exports = function () { throw new Error("define cannot be used indirect") } }, , function (t, e) { t.exports = !1 }, function (t, e, r) { var n = r(111), i = r(2), o = function (t) { return "function" == typeof t ? t : void 0 }; t.exports = function (t, e) { return arguments.length < 2 ? o(n[t]) || o(i[t]) : n[t] && n[t][e] || i[t] && i[t][e] } }, function (t, e, r) { var n = r(10), i = r(11), o = r(67), s = r(97), a = o("IE_PROTO"), c = Object.prototype; t.exports = s ? Object.getPrototypeOf : function (t) { return t = i(t), n(t, a) ? t[a] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? c : null } }, function (t, e, r) { var n = r(3); t.exports = function (t, e) { if (!n(t)) return t; var r, i; if (e && "function" == typeof (r = t.toString) && !n(i = r.call(t))) return i; if ("function" == typeof (r = t.valueOf) && !n(i = r.call(t))) return i; if (!e && "function" == typeof (r = t.toString) && !n(i = r.call(t))) return i; throw TypeError("Can't convert object to primitive value") } }, function (t, e, r) { var n = r(9).f, i = r(10), o = r(5)("toStringTag"); t.exports = function (t, e, r) { t && !i(t = r ? t : t.prototype, o) && n(t, o, { configurable: !0, value: e }) } }, function (t, e, r) { "use strict"; var n = r(0), i = r(2), o = r(6), s = r(106), a = r(8), c = r(126), u = r(39), l = r(34), h = r(15), f = r(7), p = r(128), d = r(144), m = r(31), g = r(10), v = r(63), y = r(3), x = r(35), b = r(45), w = r(41).f, M = r(145), S = r(12).forEach, _ = r(46), T = r(9), E = r(13), A = r(17), R = r(72), L = A.get, O = A.set, P = T.f, I = E.f, C = Math.round, k = i.RangeError, N = c.ArrayBuffer, z = c.DataView, U = a.NATIVE_ARRAY_BUFFER_VIEWS, j = a.TYPED_ARRAY_TAG, B = a.TypedArray, F = a.TypedArrayPrototype, D = a.aTypedArrayConstructor, G = a.isTypedArray, V = function (t, e) { for (var r = 0, n = e.length, i = new (D(t))(n); n > r;)i[r] = e[r++]; return i }, H = function (t, e) { P(t, e, { get: function () { return L(this)[e] } }) }, W = function (t) { var e; return t instanceof N || "ArrayBuffer" == (e = v(t)) || "SharedArrayBuffer" == e }, q = function (t, e) { return G(t) && "symbol" != typeof e && e in t && String(+e) == String(e) }, X = function (t, e) { return q(t, e = m(e, !0)) ? l(2, t[e]) : I(t, e) }, Y = function (t, e, r) { return !(q(t, e = m(e, !0)) && y(r) && g(r, "value")) || g(r, "get") || g(r, "set") || r.configurable || g(r, "writable") && !r.writable || g(r, "enumerable") && !r.enumerable ? P(t, e, r) : (t[e] = r.value, t) }; o ? (U || (E.f = X, T.f = Y, H(F, "buffer"), H(F, "byteOffset"), H(F, "byteLength"), H(F, "length")), n({ target: "Object", stat: !0, forced: !U }, { getOwnPropertyDescriptor: X, defineProperty: Y }), t.exports = function (t, e, r) { var o = t.match(/\d+$/)[0] / 8, a = t + (r ? "Clamped" : "") + "Array", c = "get" + t, l = "set" + t, m = i[a], g = m, v = g && g.prototype, T = {}, E = function (t, e) { P(t, e, { get: function () { return function (t, e) { var r = L(t); return r.view[c](e * o + r.byteOffset, !0) }(this, e) }, set: function (t) { return function (t, e, n) { var i = L(t); r && (n = (n = C(n)) < 0 ? 0 : n > 255 ? 255 : 255 & n), i.view[l](e * o + i.byteOffset, n, !0) }(this, e, t) }, enumerable: !0 }) }; U ? s && (g = e((function (t, e, r, n) { return u(t, g, a), R(y(e) ? W(e) ? void 0 !== n ? new m(e, d(r, o), n) : void 0 !== r ? new m(e, d(r, o)) : new m(e) : G(e) ? V(g, e) : M.call(g, e) : new m(p(e)), t, g) })), b && b(g, B), S(w(m), (function (t) { t in g || h(g, t, m[t]) })), g.prototype = v) : (g = e((function (t, e, r, n) { u(t, g, a); var i, s, c, l = 0, h = 0; if (y(e)) { if (!W(e)) return G(e) ? V(g, e) : M.call(g, e); i = e, h = d(r, o); var m = e.byteLength; if (void 0 === n) { if (m % o) throw k("Wrong length"); if ((s = m - h) < 0) throw k("Wrong length") } else if ((s = f(n) * o) + h > m) throw k("Wrong length"); c = s / o } else c = p(e), i = new N(s = c * o); for (O(t, { buffer: i, byteOffset: h, byteLength: s, length: c, view: new z(i) }); l < c;)E(t, l++) })), b && b(g, B), v = g.prototype = x(F)), v.constructor !== g && h(v, "constructor", g), j && h(v, j, a), T[a] = g, n({ global: !0, forced: g != m, sham: !U }, T), "BYTES_PER_ELEMENT" in g || h(g, "BYTES_PER_ELEMENT", o), "BYTES_PER_ELEMENT" in v || h(v, "BYTES_PER_ELEMENT", o), _(a) }) : t.exports = function () { } }, function (t, e) { t.exports = function (t, e) { return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e } } }, function (t, e, r) { var n, i = r(4), o = r(114), s = r(87), a = r(54), c = r(115), u = r(82), l = r(67), h = l("IE_PROTO"), f = function () { }, p = function (t) { return "<script>" + t + "<\/script>" }, d = function () { try { n = document.domain && new ActiveXObject("htmlfile") } catch (t) { } var t, e; d = n ? function (t) { t.write(p("")), t.close(); var e = t.parentWindow.Object; return t = null, e }(n) : ((e = u("iframe")).style.display = "none", c.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write(p("document.F=Object")), t.close(), t.F); for (var r = s.length; r--;)delete d.prototype[s[r]]; return d() }; a[h] = !0, t.exports = Object.create || function (t, e) { var r; return null !== t ? (f.prototype = i(t), r = new f, f.prototype = null, r[h] = t) : r = d(), void 0 === e ? r : o(r, e) } }, function (t, e, r) { var n = r(21); t.exports = function (t, e, r) { if (n(t), void 0 === e) return t; switch (r) { case 0: return function () { return t.call(e) }; case 1: return function (r) { return t.call(e, r) }; case 2: return function (r, n) { return t.call(e, r, n) }; case 3: return function (r, n, i) { return t.call(e, r, n, i) } }return function () { return t.apply(e, arguments) } } }, function (t, e, r) { var n = r(5), i = r(35), o = r(9), s = n("unscopables"), a = Array.prototype; null == a[s] && o.f(a, s, { configurable: !0, value: i(null) }), t.exports = function (t) { a[s][t] = !0 } }, function (t, e, r) { "use strict"; var n = r(1); t.exports = function (t, e) { var r = [][t]; return !!r && n((function () { r.call(null, e || function () { throw 1 }, 1) })) } }, function (t, e) { t.exports = function (t, e, r) { if (!(t instanceof e)) throw TypeError("Incorrect " + (r ? r + " " : "") + "invocation"); return t } }, function (t, e, r) { var n = r(4), i = r(21), o = r(5)("species"); t.exports = function (t, e) { var r, s = n(t).constructor; return void 0 === s || null == (r = n(s)[o]) ? e : i(r) } }, function (t, e, r) { var n = r(112), i = r(87).concat("length", "prototype"); e.f = Object.getOwnPropertyNames || function (t) { return n(t, i) } }, function (t, e, r) { var n = r(25), i = Math.max, o = Math.min; t.exports = function (t, e) { var r = n(t); return r < 0 ? i(r + e, 0) : o(r, e) } }, function (t, e, r) { "use strict"; var n = r(31), i = r(9), o = r(34); t.exports = function (t, e, r) { var s = n(e); s in t ? i.f(t, s, o(0, r)) : t[s] = r } }, function (t, e, r) { var n = r(54), i = r(3), o = r(10), s = r(9).f, a = r(53), c = r(64), u = a("meta"), l = 0, h = Object.isExtensible || function () { return !0 }, f = function (t) { s(t, u, { value: { objectID: "O" + ++l, weakData: {} } }) }, p = t.exports = { REQUIRED: !1, fastKey: function (t, e) { if (!i(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t; if (!o(t, u)) { if (!h(t)) return "F"; if (!e) return "E"; f(t) } return t[u].objectID }, getWeakData: function (t, e) { if (!o(t, u)) { if (!h(t)) return !0; if (!e) return !1; f(t) } return t[u].weakData }, onFreeze: function (t) { return c && p.REQUIRED && h(t) && !o(t, u) && f(t), t } }; n[u] = !0 }, function (t, e, r) { var n = r(4), i = r(124); t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () { var t, e = !1, r = {}; try { (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(r, []), e = r instanceof Array } catch (t) { } return function (r, o) { return n(r), i(o), e ? t.call(r, o) : r.__proto__ = o, r } }() : void 0) }, function (t, e, r) { "use strict"; var n = r(29), i = r(9), o = r(5), s = r(6), a = o("species"); t.exports = function (t) { var e = n(t), r = i.f; s && e && !e[a] && r(e, a, { configurable: !0, get: function () { return this } }) } }, function (t, e, r) { var n = r(16); t.exports = function (t, e, r) { for (var i in e) n(t, i, e[i], r); return t } }, function (t, e, r) { var n = r(4), i = r(93), o = r(7), s = r(36), a = r(62), c = r(122), u = function (t, e) { this.stopped = t, this.result = e }; (t.exports = function (t, e, r, l, h) { var f, p, d, m, g, v, y, x = s(e, r, l ? 2 : 1); if (h) f = t; else { if ("function" != typeof (p = a(t))) throw TypeError("Target is not iterable"); if (i(p)) { for (d = 0, m = o(t.length); m > d; d++)if ((g = l ? x(n(y = t[d])[0], y[1]) : x(t[d])) && g instanceof u) return g; return new u(!1) } f = p.call(t) } for (v = f.next; !(y = v.call(f)).done;)if ("object" == typeof (g = c(f, x, y.value, l)) && g && g instanceof u) return g; return new u(!1) }).stop = function (t) { return new u(!0, t) } }, function (t, e, r) { var n = r(14), i = "[" + r(74) + "]", o = RegExp("^" + i + i + "*"), s = RegExp(i + i + "*$"), a = function (t) { return function (e) { var r = String(n(e)); return 1 & t && (r = r.replace(o, "")), 2 & t && (r = r.replace(s, "")), r } }; t.exports = { start: a(1), end: a(2), trim: a(3) } }, function (t, e) { t.exports = function (t) { return t.webpackPolyfill || (t.deprecate = function () { }, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, "loaded", { enumerable: !0, get: function () { return t.l } }), Object.defineProperty(t, "id", { enumerable: !0, get: function () { return t.i } }), t.webpackPolyfill = 1), t } }, function (t, e) { (function (e) { t.exports = e }).call(this, {}) }, function (t, e, r) { var n = r(1), i = r(24), o = "".split; t.exports = n((function () { return !Object("z").propertyIsEnumerable(0) })) ? function (t) { return "String" == i(t) ? o.call(t, "") : Object(t) } : Object }, function (t, e) { var r = 0, n = Math.random(); t.exports = function (t) { return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++r + n).toString(36) } }, function (t, e) { t.exports = {} }, function (t, e, r) { var n = r(20), i = r(7), o = r(42), s = function (t) { return function (e, r, s) { var a, c = n(e), u = i(c.length), l = o(s, u); if (t && r != r) { for (; u > l;)if ((a = c[l++]) != a) return !0 } else for (; u > l; l++)if ((t || l in c) && c[l] === r) return t || l || 0; return !t && -1 } }; t.exports = { includes: s(!0), indexOf: s(!1) } }, function (t, e, r) { var n = r(1), i = /#|\.prototype\./, o = function (t, e) { var r = a[s(t)]; return r == u || r != c && ("function" == typeof e ? n(e) : !!e) }, s = o.normalize = function (t) { return String(t).replace(i, ".").toLowerCase() }, a = o.data = {}, c = o.NATIVE = "N", u = o.POLYFILL = "P"; t.exports = o }, function (t, e, r) { var n = r(24); t.exports = Array.isArray || function (t) { return "Array" == n(t) } }, function (t, e, r) { var n = r(112), i = r(87); t.exports = Object.keys || function (t) { return n(t, i) } }, function (t, e, r) { var n = r(3), i = r(57), o = r(5)("species"); t.exports = function (t, e) { var r; return i(t) && ("function" != typeof (r = t.constructor) || r !== Array && !i(r.prototype) ? n(r) && null === (r = r[o]) && (r = void 0) : r = void 0), new (void 0 === r ? Array : r)(0 === e ? 0 : e) } }, function (t, e, r) { var n = r(1), i = r(5), o = r(90), s = i("species"); t.exports = function (t) { return o >= 51 || !n((function () { var e = []; return (e.constructor = {})[s] = function () { return { foo: 1 } }, 1 !== e[t](Boolean).foo })) } }, function (t, e) { t.exports = {} }, function (t, e, r) { var n = r(63), i = r(61), o = r(5)("iterator"); t.exports = function (t) { if (null != t) return t[o] || t["@@iterator"] || i[n(t)] } }, function (t, e, r) { var n = r(94), i = r(24), o = r(5)("toStringTag"), s = "Arguments" == i(function () { return arguments }()); t.exports = n ? i : function (t) { var e, r, n; return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (r = function (t, e) { try { return t[e] } catch (t) { } }(e = Object(t), o)) ? r : s ? i(e) : "Object" == (n = i(e)) && "function" == typeof e.callee ? "Arguments" : n } }, function (t, e, r) { var n = r(1); t.exports = !n((function () { return Object.isExtensible(Object.preventExtensions({})) })) }, function (t, e, r) { "use strict"; var n = r(4); t.exports = function () { var t = n(this), e = ""; return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.sticky && (e += "y"), e } }, function (t, e, r) { "use strict"; var n = {}.propertyIsEnumerable, i = Object.getOwnPropertyDescriptor, o = i && !n.call({ 1: 2 }, 1); e.f = o ? function (t) { var e = i(this, t); return !!e && e.enumerable } : n }, function (t, e, r) { var n = r(85), i = r(53), o = n("keys"); t.exports = function (t) { return o[t] || (o[t] = i(t)) } }, function (t, e, r) { var n = r(5)("iterator"), i = !1; try { var o = 0, s = { next: function () { return { done: !!o++ } }, return: function () { i = !0 } }; s[n] = function () { return this }, Array.from(s, (function () { throw 2 })) } catch (t) { } t.exports = function (t, e) { if (!e && !i) return !1; var r = !1; try { var o = {}; o[n] = function () { return { next: function () { return { done: r = !0 } } } }, t(o) } catch (t) { } return r } }, function (t, e, r) { "use strict"; var n = r(20), i = r(37), o = r(61), s = r(17), a = r(95), c = s.set, u = s.getterFor("Array Iterator"); t.exports = a(Array, "Array", (function (t, e) { c(this, { type: "Array Iterator", target: n(t), index: 0, kind: e }) }), (function () { var t = u(this), e = t.target, r = t.kind, n = t.index++; return !e || n >= e.length ? (t.target = void 0, { value: void 0, done: !0 }) : "keys" == r ? { value: n, done: !1 } : "values" == r ? { value: e[n], done: !1 } : { value: [n, e[n]], done: !1 } }), "values"), o.Arguments = o.Array, i("keys"), i("values"), i("entries") }, function (t, e, r) { var n = r(21), i = r(11), o = r(52), s = r(7), a = function (t) { return function (e, r, a, c) { n(r); var u = i(e), l = o(u), h = s(u.length), f = t ? h - 1 : 0, p = t ? -1 : 1; if (a < 2) for (; ;) { if (f in l) { c = l[f], f += p; break } if (f += p, t ? f < 0 : h <= f) throw TypeError("Reduce of empty array with no initial value") } for (; t ? f >= 0 : h > f; f += p)f in l && (c = r(c, l[f], f, u)); return c } }; t.exports = { left: a(!1), right: a(!0) } }, function (t, e, r) { "use strict"; var n = r(0), i = r(2), o = r(56), s = r(16), a = r(44), c = r(48), u = r(39), l = r(3), h = r(1), f = r(68), p = r(32), d = r(72); t.exports = function (t, e, r) { var m = -1 !== t.indexOf("Map"), g = -1 !== t.indexOf("Weak"), v = m ? "set" : "add", y = i[t], x = y && y.prototype, b = y, w = {}, M = function (t) { var e = x[t]; s(x, t, "add" == t ? function (t) { return e.call(this, 0 === t ? 0 : t), this } : "delete" == t ? function (t) { return !(g && !l(t)) && e.call(this, 0 === t ? 0 : t) } : "get" == t ? function (t) { return g && !l(t) ? void 0 : e.call(this, 0 === t ? 0 : t) } : "has" == t ? function (t) { return !(g && !l(t)) && e.call(this, 0 === t ? 0 : t) } : function (t, r) { return e.call(this, 0 === t ? 0 : t, r), this }) }; if (o(t, "function" != typeof y || !(g || x.forEach && !h((function () { (new y).entries().next() }))))) b = r.getConstructor(e, t, m, v), a.REQUIRED = !0; else if (o(t, !0)) { var S = new b, _ = S[v](g ? {} : -0, 1) != S, T = h((function () { S.has(1) })), E = f((function (t) { new y(t) })), A = !g && h((function () { for (var t = new y, e = 5; e--;)t[v](e, e); return !t.has(-0) })); E || ((b = e((function (e, r) { u(e, b, t); var n = d(new y, e, b); return null != r && c(r, n[v], n, m), n }))).prototype = x, x.constructor = b), (T || A) && (M("delete"), M("has"), m && M("get")), (A || _) && M(v), g && x.clear && delete x.clear } return w[t] = b, n({ global: !0, forced: b != y }, w), p(b, t), g || r.setStrong(b, t, m), b } }, function (t, e, r) { var n = r(3), i = r(45); t.exports = function (t, e, r) { var o, s; return i && "function" == typeof (o = e.constructor) && o !== r && n(s = o.prototype) && s !== r.prototype && i(t, s), t } }, function (t, e) { var r = Math.expm1, n = Math.exp; t.exports = !r || r(10) > 22025.465794806718 || r(10) < 22025.465794806718 || -2e-17 != r(-2e-17) ? function (t) { return 0 == (t = +t) ? t : t > -1e-6 && t < 1e-6 ? t + t * t / 2 : n(t) - 1 } : r }, function (t, e) { t.exports = "\t\n\v\f\r                　\u2028\u2029\ufeff" }, function (t, e, r) { "use strict"; var n = r(28), i = r(2), o = r(1); t.exports = n || !o((function () { var t = Math.random(); __defineSetter__.call(null, t, (function () { })), delete i[t] })) }, function (t, e, r) { var n = r(3), i = r(24), o = r(5)("match"); t.exports = function (t) { var e; return n(t) && (void 0 !== (e = t[o]) ? !!e : "RegExp" == i(t)) } }, function (t, e, r) { "use strict"; var n, i, o = r(65), s = r(102), a = RegExp.prototype.exec, c = String.prototype.replace, u = a, l = (n = /a/, i = /b*/g, a.call(n, "a"), a.call(i, "a"), 0 !== n.lastIndex || 0 !== i.lastIndex), h = s.UNSUPPORTED_Y || s.BROKEN_CARET, f = void 0 !== /()??/.exec("")[1]; (l || f || h) && (u = function (t) { var e, r, n, i, s = this, u = h && s.sticky, p = o.call(s), d = s.source, m = 0, g = t; return u && (-1 === (p = p.replace("y", "")).indexOf("g") && (p += "g"), g = String(t).slice(s.lastIndex), s.lastIndex > 0 && (!s.multiline || s.multiline && "\n" !== t[s.lastIndex - 1]) && (d = "(?: " + d + ")", g = " " + g, m++), r = new RegExp("^(?:" + d + ")", p)), f && (r = new RegExp("^" + d + "$(?!\\s)", p)), l && (e = s.lastIndex), n = a.call(u ? r : s, g), u ? n ? (n.input = n.input.slice(m), n[0] = n[0].slice(m), n.index = s.lastIndex, s.lastIndex += n[0].length) : s.lastIndex = 0 : l && n && (s.lastIndex = s.global ? n.index + n[0].length : e), f && n && n.length > 1 && c.call(n[0], r, (function () { for (i = 1; i < arguments.length - 2; i++)void 0 === arguments[i] && (n[i] = void 0) })), n }), t.exports = u }, function (t, e, r) { var n = r(25), i = r(14), o = function (t) { return function (e, r) { var o, s, a = String(i(e)), c = n(r), u = a.length; return c < 0 || c >= u ? t ? "" : void 0 : (o = a.charCodeAt(c)) < 55296 || o > 56319 || c + 1 === u || (s = a.charCodeAt(c + 1)) < 56320 || s > 57343 ? t ? a.charAt(c) : o : t ? a.slice(c, c + 2) : s - 56320 + (o - 55296 << 10) + 65536 } }; t.exports = { codeAt: o(!1), charAt: o(!0) } }, function (t, e, r) { "use strict"; r(140); var n = r(16), i = r(1), o = r(5), s = r(77), a = r(15), c = o("species"), u = !i((function () { var t = /./; return t.exec = function () { var t = []; return t.groups = { a: "7" }, t }, "7" !== "".replace(t, "$<a>") })), l = "$0" === "a".replace(/./, "$0"), h = o("replace"), f = !!/./[h] && "" === /./[h]("a", "$0"), p = !i((function () { var t = /(?:)/, e = t.exec; t.exec = function () { return e.apply(this, arguments) }; var r = "ab".split(t); return 2 !== r.length || "a" !== r[0] || "b" !== r[1] })); t.exports = function (t, e, r, h) { var d = o(t), m = !i((function () { var e = {}; return e[d] = function () { return 7 }, 7 != ""[t](e) })), g = m && !i((function () { var e = !1, r = /a/; return "split" === t && ((r = {}).constructor = {}, r.constructor[c] = function () { return r }, r.flags = "", r[d] = /./[d]), r.exec = function () { return e = !0, null }, r[d](""), !e })); if (!m || !g || "replace" === t && (!u || !l || f) || "split" === t && !p) { var v = /./[d], y = r(d, ""[t], (function (t, e, r, n, i) { return e.exec === s ? m && !i ? { done: !0, value: v.call(e, r, n) } : { done: !0, value: t.call(r, e, n) } : { done: !1 } }), { REPLACE_KEEPS_$0: l, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: f }), x = y[0], b = y[1]; n(String.prototype, t, x), n(RegExp.prototype, d, 2 == e ? function (t, e) { return b.call(t, this, e) } : function (t) { return b.call(t, this) }) } h && a(RegExp.prototype[d], "sham", !0) } }, function (t, e, r) { "use strict"; var n = r(78).charAt; t.exports = function (t, e, r) { return e + (r ? n(t, e).length : 1) } }, function (t, e, r) { var n = r(24), i = r(77); t.exports = function (t, e) { var r = t.exec; if ("function" == typeof r) { var o = r.call(t, e); if ("object" != typeof o) throw TypeError("RegExp exec method returned something other than an Object or null"); return o } if ("RegExp" !== n(t)) throw TypeError("RegExp#exec called on incompatible receiver"); return i.call(t, e) } }, function (t, e, r) { var n = r(2), i = r(3), o = n.document, s = i(o) && i(o.createElement); t.exports = function (t) { return s ? o.createElement(t) : {} } }, function (t, e, r) { var n = r(2), i = r(15); t.exports = function (t, e) { try { i(n, t, e) } catch (r) { n[t] = e } return e } }, function (t, e, r) { var n = r(108), i = Function.toString; "function" != typeof n.inspectSource && (n.inspectSource = function (t) { return i.call(t) }), t.exports = n.inspectSource }, function (t, e, r) { var n = r(28), i = r(108); (t.exports = function (t, e) { return i[t] || (i[t] = void 0 !== e ? e : {}) })("versions", []).push({ version: "3.6.5", mode: n ? "pure" : "global", copyright: "© 2020 Denis Pushkarev (zloirock.ru)" }) }, function (t, e, r) { var n = r(29), i = r(41), o = r(88), s = r(4); t.exports = n("Reflect", "ownKeys") || function (t) { var e = i.f(s(t)), r = o.f; return r ? e.concat(r(t)) : e } }, function (t, e) { t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"] }, function (t, e) { e.f = Object.getOwnPropertySymbols }, function (t, e, r) { var n = r(1); t.exports = !!Object.getOwnPropertySymbols && !n((function () { return !String(Symbol()) })) }, function (t, e, r) { var n, i, o = r(2), s = r(91), a = o.process, c = a && a.versions, u = c && c.v8; u ? i = (n = u.split("."))[0] + n[1] : s && (!(n = s.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = s.match(/Chrome\/(\d+)/)) && (i = n[1]), t.exports = i && +i }, function (t, e, r) { var n = r(29); t.exports = n("navigator", "userAgent") || "" }, function (t, e, r) { "use strict"; var n = r(11), i = r(42), o = r(7); t.exports = function (t) { for (var e = n(this), r = o(e.length), s = arguments.length, a = i(s > 1 ? arguments[1] : void 0, r), c = s > 2 ? arguments[2] : void 0, u = void 0 === c ? r : i(c, r); u > a;)e[a++] = t; return e } }, function (t, e, r) { var n = r(5), i = r(61), o = n("iterator"), s = Array.prototype; t.exports = function (t) { return void 0 !== t && (i.Array === t || s[o] === t) } }, function (t, e, r) { var n = {}; n[r(5)("toStringTag")] = "z", t.exports = "[object z]" === String(n) }, function (t, e, r) { "use strict"; var n = r(0), i = r(96), o = r(30), s = r(45), a = r(32), c = r(15), u = r(16), l = r(5), h = r(28), f = r(61), p = r(123), d = p.IteratorPrototype, m = p.BUGGY_SAFARI_ITERATORS, g = l("iterator"), v = function () { return this }; t.exports = function (t, e, r, l, p, y, x) { i(r, e, l); var b, w, M, S = function (t) { if (t === p && R) return R; if (!m && t in E) return E[t]; switch (t) { case "keys": case "values": case "entries": return function () { return new r(this, t) } }return function () { return new r(this) } }, _ = e + " Iterator", T = !1, E = t.prototype, A = E[g] || E["@@iterator"] || p && E[p], R = !m && A || S(p), L = "Array" == e && E.entries || A; if (L && (b = o(L.call(new t)), d !== Object.prototype && b.next && (h || o(b) === d || (s ? s(b, d) : "function" != typeof b[g] && c(b, g, v)), a(b, _, !0, !0), h && (f[_] = v))), "values" == p && A && "values" !== A.name && (T = !0, R = function () { return A.call(this) }), h && !x || E[g] === R || c(E, g, R), f[e] = R, p) if (w = { values: S("values"), keys: y ? R : S("keys"), entries: S("entries") }, x) for (M in w) (m || T || !(M in E)) && u(E, M, w[M]); else n({ target: e, proto: !0, forced: m || T }, w); return w } }, function (t, e, r) { "use strict"; var n = r(123).IteratorPrototype, i = r(35), o = r(34), s = r(32), a = r(61), c = function () { return this }; t.exports = function (t, e, r) { var u = e + " Iterator"; return t.prototype = i(n, { next: o(1, r) }), s(t, u, !1, !0), a[u] = c, t } }, function (t, e, r) { var n = r(1); t.exports = !n((function () { function t() { } return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype })) }, function (t, e) { t.exports = Math.sign || function (t) { return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1 } }, function (t, e, r) { "use strict"; var n = r(25), i = r(14); t.exports = "".repeat || function (t) { var e = String(i(this)), r = "", o = n(t); if (o < 0 || o == 1 / 0) throw RangeError("Wrong number of repetitions"); for (; o > 0; (o >>>= 1) && (e += e))1 & o && (r += e); return r } }, function (t, e, r) { var n, i, o, s = r(2), a = r(1), c = r(24), u = r(36), l = r(115), h = r(82), f = r(136), p = s.location, d = s.setImmediate, m = s.clearImmediate, g = s.process, v = s.MessageChannel, y = s.Dispatch, x = 0, b = {}, w = function (t) { if (b.hasOwnProperty(t)) { var e = b[t]; delete b[t], e() } }, M = function (t) { return function () { w(t) } }, S = function (t) { w(t.data) }, _ = function (t) { s.postMessage(t + "", p.protocol + "//" + p.host) }; d && m || (d = function (t) { for (var e = [], r = 1; arguments.length > r;)e.push(arguments[r++]); return b[++x] = function () { ("function" == typeof t ? t : Function(t)).apply(void 0, e) }, n(x), x }, m = function (t) { delete b[t] }, "process" == c(g) ? n = function (t) { g.nextTick(M(t)) } : y && y.now ? n = function (t) { y.now(M(t)) } : v && !f ? (o = (i = new v).port2, i.port1.onmessage = S, n = u(o.postMessage, o, 1)) : !s.addEventListener || "function" != typeof postMessage || s.importScripts || a(_) || "file:" === p.protocol ? n = "onreadystatechange" in h("script") ? function (t) { l.appendChild(h("script")).onreadystatechange = function () { l.removeChild(this), w(t) } } : function (t) { setTimeout(M(t), 0) } : (n = _, s.addEventListener("message", S, !1))), t.exports = { set: d, clear: m } }, function (t, e, r) { "use strict"; var n = r(21), i = function (t) { var e, r; this.promise = new t((function (t, n) { if (void 0 !== e || void 0 !== r) throw TypeError("Bad Promise constructor"); e = t, r = n })), this.resolve = n(e), this.reject = n(r) }; t.exports.f = function (t) { return new i(t) } }, function (t, e, r) { "use strict"; var n = r(1); function i(t, e) { return RegExp(t, e) } e.UNSUPPORTED_Y = n((function () { var t = i("a", "y"); return t.lastIndex = 2, null != t.exec("abcd") })), e.BROKEN_CARET = n((function () { var t = i("^r", "gy"); return t.lastIndex = 2, null != t.exec("str") })) }, function (t, e, r) { var n = r(76); t.exports = function (t) { if (n(t)) throw TypeError("The method doesn't accept regular expressions"); return t } }, function (t, e, r) { var n = r(5)("match"); t.exports = function (t) { var e = /./; try { "/./"[t](e) } catch (r) { try { return e[n] = !1, "/./"[t](e) } catch (t) { } } return !1 } }, function (t, e, r) { var n = r(1), i = r(74); t.exports = function (t) { return n((function () { return !!i[t]() || "​᠎" != "​᠎"[t]() || i[t].name !== t })) } }, function (t, e, r) { var n = r(2), i = r(1), o = r(68), s = r(8).NATIVE_ARRAY_BUFFER_VIEWS, a = n.ArrayBuffer, c = n.Int8Array; t.exports = !s || !i((function () { c(1) })) || !i((function () { new c(-1) })) || !o((function (t) { new c, new c(null), new c(1.5), new c(t) }), !0) || i((function () { return 1 !== new c(new a(2), 1, void 0).length })) }, function (t, e, r) { var n = r(6), i = r(1), o = r(82); t.exports = !n && !i((function () { return 7 != Object.defineProperty(o("div"), "a", { get: function () { return 7 } }).a })) }, function (t, e, r) { var n = r(2), i = r(83), o = n["__core-js_shared__"] || i("__core-js_shared__", {}); t.exports = o }, function (t, e, r) { var n = r(2), i = r(84), o = n.WeakMap; t.exports = "function" == typeof o && /native code/.test(i(o)) }, function (t, e, r) { var n = r(10), i = r(86), o = r(13), s = r(9); t.exports = function (t, e) { for (var r = i(e), a = s.f, c = o.f, u = 0; u < r.length; u++) { var l = r[u]; n(t, l) || a(t, l, c(e, l)) } } }, function (t, e, r) { var n = r(2); t.exports = n }, function (t, e, r) { var n = r(10), i = r(20), o = r(55).indexOf, s = r(54); t.exports = function (t, e) { var r, a = i(t), c = 0, u = []; for (r in a) !n(s, r) && n(a, r) && u.push(r); for (; e.length > c;)n(a, r = e[c++]) && (~o(u, r) || u.push(r)); return u } }, function (t, e, r) { var n = r(89); t.exports = n && !Symbol.sham && "symbol" == typeof Symbol.iterator }, function (t, e, r) { var n = r(6), i = r(9), o = r(4), s = r(58); t.exports = n ? Object.defineProperties : function (t, e) { o(t); for (var r, n = s(e), a = n.length, c = 0; a > c;)i.f(t, r = n[c++], e[r]); return t } }, function (t, e, r) { var n = r(29); t.exports = n("document", "documentElement") }, function (t, e, r) { var n = r(20), i = r(41).f, o = {}.toString, s = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; t.exports.f = function (t) { return s && "[object Window]" == o.call(t) ? function (t) { try { return i(t) } catch (t) { return s.slice() } }(t) : i(n(t)) } }, function (t, e, r) { var n = r(5); e.f = n }, function (t, e, r) { "use strict"; var n = r(11), i = r(42), o = r(7), s = Math.min; t.exports = [].copyWithin || function (t, e) { var r = n(this), a = o(r.length), c = i(t, a), u = i(e, a), l = arguments.length > 2 ? arguments[2] : void 0, h = s((void 0 === l ? a : i(l, a)) - u, a - c), f = 1; for (u < c && c < u + h && (f = -1, u += h - 1, c += h - 1); h-- > 0;)u in r ? r[c] = r[u] : delete r[c], c += f, u += f; return r } }, function (t, e, r) { "use strict"; var n = r(57), i = r(7), o = r(36), s = function (t, e, r, a, c, u, l, h) { for (var f, p = c, d = 0, m = !!l && o(l, h, 3); d < a;) { if (d in r) { if (f = m ? m(r[d], d, e) : r[d], u > 0 && n(f)) p = s(t, e, f, i(f.length), p, u - 1) - 1; else { if (p >= 9007199254740991) throw TypeError("Exceed the acceptable array length"); t[p] = f } p++ } d++ } return p }; t.exports = s }, function (t, e, r) { "use strict"; var n = r(12).forEach, i = r(38), o = r(19), s = i("forEach"), a = o("forEach"); t.exports = s && a ? [].forEach : function (t) { return n(this, t, arguments.length > 1 ? arguments[1] : void 0) } }, function (t, e, r) { "use strict"; var n = r(36), i = r(11), o = r(122), s = r(93), a = r(7), c = r(43), u = r(62); t.exports = function (t) { var e, r, l, h, f, p, d = i(t), m = "function" == typeof this ? this : Array, g = arguments.length, v = g > 1 ? arguments[1] : void 0, y = void 0 !== v, x = u(d), b = 0; if (y && (v = n(v, g > 2 ? arguments[2] : void 0, 2)), null == x || m == Array && s(x)) for (r = new m(e = a(d.length)); e > b; b++)p = y ? v(d[b], b) : d[b], c(r, b, p); else for (f = (h = x.call(d)).next, r = new m; !(l = f.call(h)).done; b++)p = y ? o(h, v, [l.value, b], !0) : l.value, c(r, b, p); return r.length = b, r } }, function (t, e, r) { var n = r(4); t.exports = function (t, e, r, i) { try { return i ? e(n(r)[0], r[1]) : e(r) } catch (e) { var o = t.return; throw void 0 !== o && n(o.call(t)), e } } }, function (t, e, r) { "use strict"; var n, i, o, s = r(30), a = r(15), c = r(10), u = r(5), l = r(28), h = u("iterator"), f = !1;[].keys && ("next" in (o = [].keys()) ? (i = s(s(o))) !== Object.prototype && (n = i) : f = !0), null == n && (n = {}), l || c(n, h) || a(n, h, (function () { return this })), t.exports = { IteratorPrototype: n, BUGGY_SAFARI_ITERATORS: f } }, function (t, e, r) { var n = r(3); t.exports = function (t) { if (!n(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype"); return t } }, function (t, e, r) { "use strict"; var n = r(20), i = r(25), o = r(7), s = r(38), a = r(19), c = Math.min, u = [].lastIndexOf, l = !!u && 1 / [1].lastIndexOf(1, -0) < 0, h = s("lastIndexOf"), f = a("indexOf", { ACCESSORS: !0, 1: 0 }), p = l || !h || !f; t.exports = p ? function (t) { if (l) return u.apply(this, arguments) || 0; var e = n(this), r = o(e.length), s = r - 1; for (arguments.length > 1 && (s = c(s, i(arguments[1]))), s < 0 && (s = r + s); s >= 0; s--)if (s in e && e[s] === t) return s || 0; return -1 } : u }, function (t, e, r) { "use strict"; var n = r(2), i = r(6), o = r(127), s = r(15), a = r(47), c = r(1), u = r(39), l = r(25), h = r(7), f = r(128), p = r(197), d = r(30), m = r(45), g = r(41).f, v = r(9).f, y = r(92), x = r(32), b = r(17), w = b.get, M = b.set, S = n.ArrayBuffer, _ = S, T = n.DataView, E = T && T.prototype, A = Object.prototype, R = n.RangeError, L = p.pack, O = p.unpack, P = function (t) { return [255 & t] }, I = function (t) { return [255 & t, t >> 8 & 255] }, C = function (t) { return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255] }, k = function (t) { return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0] }, N = function (t) { return L(t, 23, 4) }, z = function (t) { return L(t, 52, 8) }, U = function (t, e) { v(t.prototype, e, { get: function () { return w(this)[e] } }) }, j = function (t, e, r, n) { var i = f(r), o = w(t); if (i + e > o.byteLength) throw R("Wrong index"); var s = w(o.buffer).bytes, a = i + o.byteOffset, c = s.slice(a, a + e); return n ? c : c.reverse() }, B = function (t, e, r, n, i, o) { var s = f(r), a = w(t); if (s + e > a.byteLength) throw R("Wrong index"); for (var c = w(a.buffer).bytes, u = s + a.byteOffset, l = n(+i), h = 0; h < e; h++)c[u + h] = l[o ? h : e - h - 1] }; if (o) { if (!c((function () { S(1) })) || !c((function () { new S(-1) })) || c((function () { return new S, new S(1.5), new S(NaN), "ArrayBuffer" != S.name }))) { for (var F, D = (_ = function (t) { return u(this, _), new S(f(t)) }).prototype = S.prototype, G = g(S), V = 0; G.length > V;)(F = G[V++]) in _ || s(_, F, S[F]); D.constructor = _ } m && d(E) !== A && m(E, A); var H = new T(new _(2)), W = E.setInt8; H.setInt8(0, 2147483648), H.setInt8(1, 2147483649), !H.getInt8(0) && H.getInt8(1) || a(E, { setInt8: function (t, e) { W.call(this, t, e << 24 >> 24) }, setUint8: function (t, e) { W.call(this, t, e << 24 >> 24) } }, { unsafe: !0 }) } else _ = function (t) { u(this, _, "ArrayBuffer"); var e = f(t); M(this, { bytes: y.call(new Array(e), 0), byteLength: e }), i || (this.byteLength = e) }, T = function (t, e, r) { u(this, T, "DataView"), u(t, _, "DataView"); var n = w(t).byteLength, o = l(e); if (o < 0 || o > n) throw R("Wrong offset"); if (o + (r = void 0 === r ? n - o : h(r)) > n) throw R("Wrong length"); M(this, { buffer: t, byteLength: r, byteOffset: o }), i || (this.buffer = t, this.byteLength = r, this.byteOffset = o) }, i && (U(_, "byteLength"), U(T, "buffer"), U(T, "byteLength"), U(T, "byteOffset")), a(T.prototype, { getInt8: function (t) { return j(this, 1, t)[0] << 24 >> 24 }, getUint8: function (t) { return j(this, 1, t)[0] }, getInt16: function (t) { var e = j(this, 2, t, arguments.length > 1 ? arguments[1] : void 0); return (e[1] << 8 | e[0]) << 16 >> 16 }, getUint16: function (t) { var e = j(this, 2, t, arguments.length > 1 ? arguments[1] : void 0); return e[1] << 8 | e[0] }, getInt32: function (t) { return k(j(this, 4, t, arguments.length > 1 ? arguments[1] : void 0)) }, getUint32: function (t) { return k(j(this, 4, t, arguments.length > 1 ? arguments[1] : void 0)) >>> 0 }, getFloat32: function (t) { return O(j(this, 4, t, arguments.length > 1 ? arguments[1] : void 0), 23) }, getFloat64: function (t) { return O(j(this, 8, t, arguments.length > 1 ? arguments[1] : void 0), 52) }, setInt8: function (t, e) { B(this, 1, t, P, e) }, setUint8: function (t, e) { B(this, 1, t, P, e) }, setInt16: function (t, e) { B(this, 2, t, I, e, arguments.length > 2 ? arguments[2] : void 0) }, setUint16: function (t, e) { B(this, 2, t, I, e, arguments.length > 2 ? arguments[2] : void 0) }, setInt32: function (t, e) { B(this, 4, t, C, e, arguments.length > 2 ? arguments[2] : void 0) }, setUint32: function (t, e) { B(this, 4, t, C, e, arguments.length > 2 ? arguments[2] : void 0) }, setFloat32: function (t, e) { B(this, 4, t, N, e, arguments.length > 2 ? arguments[2] : void 0) }, setFloat64: function (t, e) { B(this, 8, t, z, e, arguments.length > 2 ? arguments[2] : void 0) } }); x(_, "ArrayBuffer"), x(T, "DataView"), t.exports = { ArrayBuffer: _, DataView: T } }, function (t, e) { t.exports = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView }, function (t, e, r) { var n = r(25), i = r(7); t.exports = function (t) { if (void 0 === t) return 0; var e = n(t), r = i(e); if (e !== r) throw RangeError("Wrong length or index"); return r } }, function (t, e, r) { "use strict"; var n = r(9).f, i = r(35), o = r(47), s = r(36), a = r(39), c = r(48), u = r(95), l = r(46), h = r(6), f = r(44).fastKey, p = r(17), d = p.set, m = p.getterFor; t.exports = { getConstructor: function (t, e, r, u) { var l = t((function (t, n) { a(t, l, e), d(t, { type: e, index: i(null), first: void 0, last: void 0, size: 0 }), h || (t.size = 0), null != n && c(n, t[u], t, r) })), p = m(e), g = function (t, e, r) { var n, i, o = p(t), s = v(t, e); return s ? s.value = r : (o.last = s = { index: i = f(e, !0), key: e, value: r, previous: n = o.last, next: void 0, removed: !1 }, o.first || (o.first = s), n && (n.next = s), h ? o.size++ : t.size++, "F" !== i && (o.index[i] = s)), t }, v = function (t, e) { var r, n = p(t), i = f(e); if ("F" !== i) return n.index[i]; for (r = n.first; r; r = r.next)if (r.key == e) return r }; return o(l.prototype, { clear: function () { for (var t = p(this), e = t.index, r = t.first; r;)r.removed = !0, r.previous && (r.previous = r.previous.next = void 0), delete e[r.index], r = r.next; t.first = t.last = void 0, h ? t.size = 0 : this.size = 0 }, delete: function (t) { var e = p(this), r = v(this, t); if (r) { var n = r.next, i = r.previous; delete e.index[r.index], r.removed = !0, i && (i.next = n), n && (n.previous = i), e.first == r && (e.first = n), e.last == r && (e.last = i), h ? e.size-- : this.size-- } return !!r }, forEach: function (t) { for (var e, r = p(this), n = s(t, arguments.length > 1 ? arguments[1] : void 0, 3); e = e ? e.next : r.first;)for (n(e.value, e.key, this); e && e.removed;)e = e.previous }, has: function (t) { return !!v(this, t) } }), o(l.prototype, r ? { get: function (t) { var e = v(this, t); return e && e.value }, set: function (t, e) { return g(this, 0 === t ? 0 : t, e) } } : { add: function (t) { return g(this, t = 0 === t ? 0 : t, t) } }), h && n(l.prototype, "size", { get: function () { return p(this).size } }), l }, setStrong: function (t, e, r) { var n = e + " Iterator", i = m(e), o = m(n); u(t, e, (function (t, e) { d(this, { type: n, target: t, state: i(t), kind: e, last: void 0 }) }), (function () { for (var t = o(this), e = t.kind, r = t.last; r && r.removed;)r = r.previous; return t.target && (t.last = r = r ? r.next : t.state.first) ? "keys" == e ? { value: r.key, done: !1 } : "values" == e ? { value: r.value, done: !1 } : { value: [r.key, r.value], done: !1 } : (t.target = void 0, { value: void 0, done: !0 }) }), r ? "entries" : "values", !r, !0), l(e) } } }, function (t, e) { var r = Math.log; t.exports = Math.log1p || function (t) { return (t = +t) > -1e-8 && t < 1e-8 ? t - t * t / 2 : r(1 + t) } }, function (t, e, r) { var n = r(3), i = Math.floor; t.exports = function (t) { return !n(t) && isFinite(t) && i(t) === t } }, function (t, e, r) { "use strict"; var n = r(6), i = r(1), o = r(58), s = r(88), a = r(66), c = r(11), u = r(52), l = Object.assign, h = Object.defineProperty; t.exports = !l || i((function () { if (n && 1 !== l({ b: 1 }, l(h({}, "a", { enumerable: !0, get: function () { h(this, "b", { value: 3, enumerable: !1 }) } }), { b: 2 })).b) return !0; var t = {}, e = {}, r = Symbol(); return t[r] = 7, "abcdefghijklmnopqrst".split("").forEach((function (t) { e[t] = t })), 7 != l({}, t)[r] || "abcdefghijklmnopqrst" != o(l({}, e)).join("") })) ? function (t, e) { for (var r = c(t), i = arguments.length, l = 1, h = s.f, f = a.f; i > l;)for (var p, d = u(arguments[l++]), m = h ? o(d).concat(h(d)) : o(d), g = m.length, v = 0; g > v;)p = m[v++], n && !f.call(d, p) || (r[p] = d[p]); return r } : l }, function (t, e, r) { var n = r(6), i = r(58), o = r(20), s = r(66).f, a = function (t) { return function (e) { for (var r, a = o(e), c = i(a), u = c.length, l = 0, h = []; u > l;)r = c[l++], n && !s.call(a, r) || h.push(t ? [r, a[r]] : a[r]); return h } }; t.exports = { entries: a(!0), values: a(!1) } }, function (t, e) { t.exports = Object.is || function (t, e) { return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e } }, function (t, e, r) { var n = r(2); t.exports = n.Promise }, function (t, e, r) { var n = r(91); t.exports = /(iphone|ipod|ipad).*applewebkit/i.test(n) }, function (t, e, r) { var n, i, o, s, a, c, u, l, h = r(2), f = r(13).f, p = r(24), d = r(100).set, m = r(136), g = h.MutationObserver || h.WebKitMutationObserver, v = h.process, y = h.Promise, x = "process" == p(v), b = f(h, "queueMicrotask"), w = b && b.value; w || (n = function () { var t, e; for (x && (t = v.domain) && t.exit(); i;) { e = i.fn, i = i.next; try { e() } catch (t) { throw i ? s() : o = void 0, t } } o = void 0, t && t.enter() }, x ? s = function () { v.nextTick(n) } : g && !m ? (a = !0, c = document.createTextNode(""), new g(n).observe(c, { characterData: !0 }), s = function () { c.data = a = !a }) : y && y.resolve ? (u = y.resolve(void 0), l = u.then, s = function () { l.call(u, n) }) : s = function () { d.call(h, n) }), t.exports = w || function (t) { var e = { fn: t, next: void 0 }; o && (o.next = e), i || (i = e, s()), o = e } }, function (t, e, r) { var n = r(4), i = r(3), o = r(101); t.exports = function (t, e) { if (n(t), i(e) && e.constructor === t) return e; var r = o.f(t); return (0, r.resolve)(e), r.promise } }, function (t, e) { t.exports = function (t) { try { return { error: !1, value: t() } } catch (t) { return { error: !0, value: t } } } }, function (t, e, r) { "use strict"; var n = r(0), i = r(77); n({ target: "RegExp", proto: !0, forced: /./.exec !== i }, { exec: i }) }, function (t, e, r) { "use strict"; var n = r(78).charAt, i = r(17), o = r(95), s = i.set, a = i.getterFor("String Iterator"); o(String, "String", (function (t) { s(this, { type: "String Iterator", string: String(t), index: 0 }) }), (function () { var t, e = a(this), r = e.string, i = e.index; return i >= r.length ? { value: void 0, done: !0 } : (t = n(r, i), e.index += t.length, { value: t, done: !1 }) })) }, function (t, e, r) { var n = r(7), i = r(99), o = r(14), s = Math.ceil, a = function (t) { return function (e, r, a) { var c, u, l = String(o(e)), h = l.length, f = void 0 === a ? " " : String(a), p = n(r); return p <= h || "" == f ? l : (c = p - h, (u = i.call(f, s(c / f.length))).length > c && (u = u.slice(0, c)), t ? l + u : u + l) } }; t.exports = { start: a(!1), end: a(!0) } }, function (t, e, r) { var n = r(91); t.exports = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(n) }, function (t, e, r) { var n = r(314); t.exports = function (t, e) { var r = n(t); if (r % e) throw RangeError("Wrong offset"); return r } }, function (t, e, r) { var n = r(11), i = r(7), o = r(62), s = r(93), a = r(36), c = r(8).aTypedArrayConstructor; t.exports = function (t) { var e, r, u, l, h, f, p = n(t), d = arguments.length, m = d > 1 ? arguments[1] : void 0, g = void 0 !== m, v = o(p); if (null != v && !s(v)) for (f = (h = v.call(p)).next, p = []; !(l = f.call(h)).done;)p.push(l.value); for (g && d > 2 && (m = a(m, arguments[2], 2)), r = i(p.length), u = new (c(this))(r), e = 0; r > e; e++)u[e] = g ? m(p[e], e) : p[e]; return u } }, function (t, e, r) { "use strict"; var n = r(47), i = r(44).getWeakData, o = r(4), s = r(3), a = r(39), c = r(48), u = r(12), l = r(10), h = r(17), f = h.set, p = h.getterFor, d = u.find, m = u.findIndex, g = 0, v = function (t) { return t.frozen || (t.frozen = new y) }, y = function () { this.entries = [] }, x = function (t, e) { return d(t.entries, (function (t) { return t[0] === e })) }; y.prototype = { get: function (t) { var e = x(this, t); if (e) return e[1] }, has: function (t) { return !!x(this, t) }, set: function (t, e) { var r = x(this, t); r ? r[1] = e : this.entries.push([t, e]) }, delete: function (t) { var e = m(this.entries, (function (e) { return e[0] === t })); return ~e && this.entries.splice(e, 1), !!~e } }, t.exports = { getConstructor: function (t, e, r, u) { var h = t((function (t, n) { a(t, h, e), f(t, { type: e, id: g++, frozen: void 0 }), null != n && c(n, t[u], t, r) })), d = p(e), m = function (t, e, r) { var n = d(t), s = i(o(e), !0); return !0 === s ? v(n).set(e, r) : s[n.id] = r, t }; return n(h.prototype, { delete: function (t) { var e = d(this); if (!s(t)) return !1; var r = i(t); return !0 === r ? v(e).delete(t) : r && l(r, e.id) && delete r[e.id] }, has: function (t) { var e = d(this); if (!s(t)) return !1; var r = i(t); return !0 === r ? v(e).has(t) : r && l(r, e.id) } }), n(h.prototype, r ? { get: function (t) { var e = d(this); if (s(t)) { var r = i(t); return !0 === r ? v(e).get(t) : r ? r[e.id] : void 0 } }, set: function (t, e) { return m(this, t, e) } } : { add: function (t) { return m(this, t, !0) } }), h } } }, function (t, e) { t.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 } }, function (t, e, r) { var n = r(1), i = r(5), o = r(28), s = i("iterator"); t.exports = !n((function () { var t = new URL("b?a=1&b=2&c=3", "http://a"), e = t.searchParams, r = ""; return t.pathname = "c%20d", e.forEach((function (t, n) { e.delete("b"), r += n + t })), o && !t.toJSON || !e.sort || "http://a/c%20d?a=1&c=3" !== t.href || "3" !== e.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !e[s] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://тест").host || "#%D0%B1" !== new URL("http://a#б").hash || "a1c3" !== r || "x" !== new URL("http://x", void 0).host })) }, function (t, e, r) { "use strict"; r(69); var n = r(0), i = r(29), o = r(148), s = r(16), a = r(47), c = r(32), u = r(96), l = r(17), h = r(39), f = r(10), p = r(36), d = r(63), m = r(4), g = r(3), v = r(35), y = r(34), x = r(356), b = r(62), w = r(5), M = i("fetch"), S = i("Headers"), _ = w("iterator"), T = l.set, E = l.getterFor("URLSearchParams"), A = l.getterFor("URLSearchParamsIterator"), R = /\+/g, L = Array(4), O = function (t) { return L[t - 1] || (L[t - 1] = RegExp("((?:%[\\da-f]{2}){" + t + "})", "gi")) }, P = function (t) { try { return decodeURIComponent(t) } catch (e) { return t } }, I = function (t) { var e = t.replace(R, " "), r = 4; try { return decodeURIComponent(e) } catch (t) { for (; r;)e = e.replace(O(r--), P); return e } }, C = /[!'()~]|%20/g, k = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, N = function (t) { return k[t] }, z = function (t) { return encodeURIComponent(t).replace(C, N) }, U = function (t, e) { if (e) for (var r, n, i = e.split("&"), o = 0; o < i.length;)(r = i[o++]).length && (n = r.split("="), t.push({ key: I(n.shift()), value: I(n.join("=")) })) }, j = function (t) { this.entries.length = 0, U(this.entries, t) }, B = function (t, e) { if (t < e) throw TypeError("Not enough arguments") }, F = u((function (t, e) { T(this, { type: "URLSearchParamsIterator", iterator: x(E(t).entries), kind: e }) }), "Iterator", (function () { var t = A(this), e = t.kind, r = t.iterator.next(), n = r.value; return r.done || (r.value = "keys" === e ? n.key : "values" === e ? n.value : [n.key, n.value]), r })), D = function () { h(this, D, "URLSearchParams"); var t, e, r, n, i, o, s, a, c, u = arguments.length > 0 ? arguments[0] : void 0, l = this, p = []; if (T(l, { type: "URLSearchParams", entries: p, updateURL: function () { }, updateSearchParams: j }), void 0 !== u) if (g(u)) if ("function" == typeof (t = b(u))) for (r = (e = t.call(u)).next; !(n = r.call(e)).done;) { if ((s = (o = (i = x(m(n.value))).next).call(i)).done || (a = o.call(i)).done || !o.call(i).done) throw TypeError("Expected sequence with length 2"); p.push({ key: s.value + "", value: a.value + "" }) } else for (c in u) f(u, c) && p.push({ key: c, value: u[c] + "" }); else U(p, "string" == typeof u ? "?" === u.charAt(0) ? u.slice(1) : u : u + "") }, G = D.prototype; a(G, { append: function (t, e) { B(arguments.length, 2); var r = E(this); r.entries.push({ key: t + "", value: e + "" }), r.updateURL() }, delete: function (t) { B(arguments.length, 1); for (var e = E(this), r = e.entries, n = t + "", i = 0; i < r.length;)r[i].key === n ? r.splice(i, 1) : i++; e.updateURL() }, get: function (t) { B(arguments.length, 1); for (var e = E(this).entries, r = t + "", n = 0; n < e.length; n++)if (e[n].key === r) return e[n].value; return null }, getAll: function (t) { B(arguments.length, 1); for (var e = E(this).entries, r = t + "", n = [], i = 0; i < e.length; i++)e[i].key === r && n.push(e[i].value); return n }, has: function (t) { B(arguments.length, 1); for (var e = E(this).entries, r = t + "", n = 0; n < e.length;)if (e[n++].key === r) return !0; return !1 }, set: function (t, e) { B(arguments.length, 1); for (var r, n = E(this), i = n.entries, o = !1, s = t + "", a = e + "", c = 0; c < i.length; c++)(r = i[c]).key === s && (o ? i.splice(c--, 1) : (o = !0, r.value = a)); o || i.push({ key: s, value: a }), n.updateURL() }, sort: function () { var t, e, r, n = E(this), i = n.entries, o = i.slice(); for (i.length = 0, r = 0; r < o.length; r++) { for (t = o[r], e = 0; e < r; e++)if (i[e].key > t.key) { i.splice(e, 0, t); break } e === r && i.push(t) } n.updateURL() }, forEach: function (t) { for (var e, r = E(this).entries, n = p(t, arguments.length > 1 ? arguments[1] : void 0, 3), i = 0; i < r.length;)n((e = r[i++]).value, e.key, this) }, keys: function () { return new F(this, "keys") }, values: function () { return new F(this, "values") }, entries: function () { return new F(this, "entries") } }, { enumerable: !0 }), s(G, _, G.entries), s(G, "toString", (function () { for (var t, e = E(this).entries, r = [], n = 0; n < e.length;)t = e[n++], r.push(z(t.key) + "=" + z(t.value)); return r.join("&") }), { enumerable: !0 }), c(D, "URLSearchParams"), n({ global: !0, forced: !o }, { URLSearchParams: D }), o || "function" != typeof M || "function" != typeof S || n({ global: !0, enumerable: !0, forced: !0 }, { fetch: function (t) { var e, r, n, i = [t]; return arguments.length > 1 && (g(e = arguments[1]) && (r = e.body, "URLSearchParams" === d(r) && ((n = e.headers ? new S(e.headers) : new S).has("content-type") || n.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"), e = v(e, { body: y(0, String(r)), headers: y(0, n) }))), i.push(e)), M.apply(this, i) } }), t.exports = { URLSearchParams: D, getState: E } }, function (t, e, r) { "use strict"; r.r(e), function (t) { var r, n, i = "undefined" == typeof self && void 0 !== t && t.hrtime ? function () { var e = t.hrtime(); return 1e3 * e[0] + e[1] / 1e6 } : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now.bind(self.performance) : void 0 !== Date.now ? Date.now : function () { return (new Date).getTime() }, o = function () { function t() { this._tweens = {}, this._tweensAddedDuringUpdate = {} } return t.prototype.getAll = function () { var t = this; return Object.keys(this._tweens).map((function (e) { return t._tweens[e] })) }, t.prototype.removeAll = function () { this._tweens = {} }, t.prototype.add = function (t) { this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t }, t.prototype.remove = function (t) { delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()] }, t.prototype.update = function (t, e) { var r = Object.keys(this._tweens); if (0 === r.length) return !1; for (t = void 0 !== t ? t : i(); r.length > 0;) { this._tweensAddedDuringUpdate = {}; for (var n = 0; n < r.length; n++) { var o = this._tweens[r[n]]; o && !1 === o.update(t) && !e && delete this._tweens[r[n]] } r = Object.keys(this._tweensAddedDuringUpdate) } return !0 }, t }(), s = { Linear: { None: function (t) { return t } }, Quadratic: { In: function (t) { return t * t }, Out: function (t) { return t * (2 - t) }, InOut: function (t) { return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1) } }, Cubic: { In: function (t) { return t * t * t }, Out: function (t) { return --t * t * t + 1 }, InOut: function (t) { return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2) } }, Quartic: { In: function (t) { return t * t * t * t }, Out: function (t) { return 1 - --t * t * t * t }, InOut: function (t) { return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2) } }, Quintic: { In: function (t) { return t * t * t * t * t }, Out: function (t) { return --t * t * t * t * t + 1 }, InOut: function (t) { return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2) } }, Sinusoidal: { In: function (t) { return 1 - Math.cos(t * Math.PI / 2) }, Out: function (t) { return Math.sin(t * Math.PI / 2) }, InOut: function (t) { return .5 * (1 - Math.cos(Math.PI * t)) } }, Exponential: { In: function (t) { return 0 === t ? 0 : Math.pow(1024, t - 1) }, Out: function (t) { return 1 === t ? 1 : 1 - Math.pow(2, -10 * t) }, InOut: function (t) { return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1))) } }, Circular: { In: function (t) { return 1 - Math.sqrt(1 - t * t) }, Out: function (t) { return Math.sqrt(1 - --t * t) }, InOut: function (t) { return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) } }, Elastic: { In: function (t) { return 0 === t ? 0 : 1 === t ? 1 : -Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) }, Out: function (t) { return 0 === t ? 0 : 1 === t ? 1 : Math.pow(2, -10 * t) * Math.sin(5 * (t - .1) * Math.PI) + 1 }, InOut: function (t) { return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? -.5 * Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) + 1 } }, Back: { In: function (t) { var e = 1.70158; return t * t * ((e + 1) * t - e) }, Out: function (t) { var e = 1.70158; return --t * t * ((e + 1) * t + e) + 1 }, InOut: function (t) { var e = 2.5949095; return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2) } }, Bounce: { In: function (t) { return 1 - s.Bounce.Out(1 - t) }, Out: function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, InOut: function (t) { return t < .5 ? .5 * s.Bounce.In(2 * t) : .5 * s.Bounce.Out(2 * t - 1) + .5 } } }, a = { Linear: function (t, e) { var r = t.length - 1, n = r * e, i = Math.floor(n), o = a.Utils.Linear; return e < 0 ? o(t[0], t[1], n) : e > 1 ? o(t[r], t[r - 1], r - n) : o(t[i], t[i + 1 > r ? r : i + 1], n - i) }, Bezier: function (t, e) { for (var r = 0, n = t.length - 1, i = Math.pow, o = a.Utils.Bernstein, s = 0; s <= n; s++)r += i(1 - e, n - s) * i(e, s) * t[s] * o(n, s); return r }, CatmullRom: function (t, e) { var r = t.length - 1, n = r * e, i = Math.floor(n), o = a.Utils.CatmullRom; return t[0] === t[r] ? (e < 0 && (i = Math.floor(n = r * (1 + e))), o(t[(i - 1 + r) % r], t[i], t[(i + 1) % r], t[(i + 2) % r], n - i)) : e < 0 ? t[0] - (o(t[0], t[0], t[1], t[1], -n) - t[0]) : e > 1 ? t[r] - (o(t[r], t[r], t[r - 1], t[r - 1], n - r) - t[r]) : o(t[i ? i - 1 : 0], t[i], t[r < i + 1 ? r : i + 1], t[r < i + 2 ? r : i + 2], n - i) }, Utils: { Linear: function (t, e, r) { return (e - t) * r + t }, Bernstein: function (t, e) { var r = a.Utils.Factorial; return r(t) / r(e) / r(t - e) }, Factorial: (r = [1], function (t) { var e = 1; if (r[t]) return r[t]; for (var n = t; n > 1; n--)e *= n; return r[t] = e, e }), CatmullRom: function (t, e, r, n, i) { var o = .5 * (r - t), s = .5 * (n - e), a = i * i; return (2 * e - 2 * r + o + s) * (i * a) + (-3 * e + 3 * r - 2 * o - s) * a + o * i + e } } }, c = function () { function t() { } return t.nextId = function () { return t._nextId++ }, t._nextId = 0, t }(), u = function () { function t(t, e) { void 0 === e && (e = h), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = h.Easing.Linear.None, this._interpolationFunction = h.Interpolation.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._id = h.nextId(), this._isChainStopped = !1 } return t.prototype.getId = function () { return this._id }, t.prototype.isPlaying = function () { return this._isPlaying }, t.prototype.isPaused = function () { return this._isPaused }, t.prototype.to = function (t, e) { for (var r in t) this._valuesEnd[r] = t[r]; return void 0 !== e && (this._duration = e), this }, t.prototype.duration = function (t) { return this._duration = t, this }, t.prototype.start = function (t) { if (this._isPlaying) return this; if (this._group.add(this), this._repeat = this._initialRepeat, this._reversed) for (var e in this._reversed = !1, this._valuesStartRepeat) this._swapEndStartRepeatValues(e), this._valuesStart[e] = this._valuesStartRepeat[e]; return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = void 0 !== t ? "string" == typeof t ? h.now() + parseFloat(t) : t : h.now(), this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat), this }, t.prototype._setupProperties = function (t, e, r, n) { for (var i in r) { var o = t[i], s = Array.isArray(o), a = s ? "array" : typeof o, c = !s && Array.isArray(r[i]); if ("undefined" !== a && "function" !== a) { if (c) { var u = r[i]; if (0 === u.length) continue; u = u.map(this._handleRelativeValue.bind(this, o)), r[i] = [o].concat(u) } if ("object" !== a && !s || !o || c) void 0 === e[i] && (e[i] = o), s || (e[i] *= 1), n[i] = c ? r[i].slice().reverse() : e[i] || 0; else { for (var l in e[i] = s ? [] : {}, o) e[i][l] = o[l]; n[i] = s ? [] : {}, this._setupProperties(o, e[i], r[i], n[i]) } } } }, t.prototype.stop = function () { return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this }, t.prototype.end = function () { return this.update(1 / 0), this }, t.prototype.pause = function (t) { return this._isPaused || !this._isPlaying || (this._isPaused = !0, this._pauseStart = void 0 === t ? h.now() : t, this._group.remove(this)), this }, t.prototype.resume = function (t) { return this._isPaused && this._isPlaying ? (this._isPaused = !1, this._startTime += (void 0 === t ? h.now() : t) - this._pauseStart, this._pauseStart = 0, this._group.add(this), this) : this }, t.prototype.stopChainedTweens = function () { for (var t = 0, e = this._chainedTweens.length; t < e; t++)this._chainedTweens[t].stop(); return this }, t.prototype.group = function (t) { return this._group = t, this }, t.prototype.delay = function (t) { return this._delayTime = t, this }, t.prototype.repeat = function (t) { return this._initialRepeat = t, this._repeat = t, this }, t.prototype.repeatDelay = function (t) { return this._repeatDelayTime = t, this }, t.prototype.yoyo = function (t) { return this._yoyo = t, this }, t.prototype.easing = function (t) { return this._easingFunction = t, this }, t.prototype.interpolation = function (t) { return this._interpolationFunction = t, this }, t.prototype.chain = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return this._chainedTweens = t, this }, t.prototype.onStart = function (t) { return this._onStartCallback = t, this }, t.prototype.onUpdate = function (t) { return this._onUpdateCallback = t, this }, t.prototype.onRepeat = function (t) { return this._onRepeatCallback = t, this }, t.prototype.onComplete = function (t) { return this._onCompleteCallback = t, this }, t.prototype.onStop = function (t) { return this._onStopCallback = t, this }, t.prototype.update = function (t) { var e, r; if (t > this._startTime + this._duration && !this._isPlaying) return !1; if (this.isPlaying || this.start(t), t < this._startTime) return !0; !1 === this._onStartCallbackFired && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), r = (t - this._startTime) / this._duration, r = 0 === this._duration || r > 1 ? 1 : r; var n = this._easingFunction(r); if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, n), this._onUpdateCallback && this._onUpdateCallback(this._object, r), 1 === r) { if (this._repeat > 0) { for (e in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) this._yoyo || "string" != typeof this._valuesEnd[e] || (this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(this._valuesEnd[e])), this._yoyo && this._swapEndStartRepeatValues(e), this._valuesStart[e] = this._valuesStartRepeat[e]; return this._yoyo && (this._reversed = !this._reversed), void 0 !== this._repeatDelayTime ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), !0 } this._onCompleteCallback && this._onCompleteCallback(this._object); for (var i = 0, o = this._chainedTweens.length; i < o; i++)this._chainedTweens[i].start(this._startTime + this._duration); return this._isPlaying = !1, !1 } return !0 }, t.prototype._updateProperties = function (t, e, r, n) { for (var i in r) if (void 0 !== e[i]) { var o = e[i] || 0, s = r[i], a = Array.isArray(t[i]), c = Array.isArray(s); !a && c ? t[i] = this._interpolationFunction(s, n) : "object" == typeof s && s ? this._updateProperties(t[i], o, s, n) : "number" == typeof (s = this._handleRelativeValue(o, s)) && (t[i] = o + (s - o) * n) } }, t.prototype._handleRelativeValue = function (t, e) { return "string" != typeof e ? e : "+" === e.charAt(0) || "-" === e.charAt(0) ? t + parseFloat(e) : parseFloat(e) }, t.prototype._swapEndStartRepeatValues = function (t) { var e = this._valuesStartRepeat[t]; "string" == typeof this._valuesEnd[t] ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(this._valuesEnd[t]) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e }, t }(), l = (n = function (t, e) { return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }, function (t, e) { function r() { this.constructor = t } n(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }), h = new (function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.version = "18.6.0", e.now = i, e.Group = o, e.Easing = s, e.Interpolation = a, e.nextId = c.nextId, e.Tween = u, e } return l(e, t), e }(o)); e.default = h }.call(this, r(359)) }, function (t, e) { t.exports = "attribute float corner;\r\nattribute float colorMix;\r\n\r\nvarying vec2 vUv;\r\nvarying float vOpacity;\r\nvarying vec3 vColor;\r\nvarying vec3 vCornerColor;\r\n\r\nuniform float stretchFactor;\r\nuniform vec3 offset;\r\nuniform vec3 direction;\r\nuniform vec3 bboxMax;\r\nuniform vec3 bboxMin;\r\nuniform vec3 color1;\r\nuniform vec3 color2;\r\nuniform float thickness;\r\nuniform float rayLength;\r\nuniform float time;\r\nuniform sampler2D noise;\r\nuniform float shakeSpeed;\r\nuniform float shakeStrength;\r\nuniform float globalOpacity;\r\n\r\nuniform mat4 rotation;\r\n\r\nfloat remap(float value, float inMin, float inMax, float outMin, float outMax) {\r\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\r\n}\r\n\r\nvec2 rotate(vec2 v, float a) {\r\n\tfloat s = sin(a);\r\n\tfloat c = cos(a);\r\n\tmat2 m = mat2(c, -s, s, c);\r\n\treturn m * v;\r\n}\r\n\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  vOpacity = 1.0;\r\n\r\n  vec3 origin = position;\r\n\r\n  // set particle color based on mix attribute\r\n  vColor = mix(color1, color2, colorMix);\r\n\r\n  vec3 pos = position;\r\n  float zRange = bboxMax.z - bboxMin.z;\r\n  float yRange = bboxMax.y - bboxMin.y;\r\n  float xRange = bboxMax.x - bboxMin.x;\r\n  \r\n  pos += (time * vec3(0.0, 0.0, 1.0));\r\n\r\n  pos.x += offset.x;\r\n  pos.z = mod(pos.z, zRange) - zRange / 2.0;\r\n  pos.x = mod(pos.x, xRange) - xRange / 2.0;\r\n  pos.y -= offset.y;\r\n  pos.y = mod(pos.y, yRange) - (yRange / 2.0);\r\n\r\n  vec4 worldPos = modelMatrix * vec4(pos, 1.0);\r\n  vec4 worldOrigin = worldPos;\r\n  vec4 pOrigin = projectionMatrix * viewMatrix * worldOrigin;\r\n\r\n  float globalSizeFactor = clamp(remap(pOrigin.z, 40.0, 37.0, 0.0, globalOpacity), 0.0, globalOpacity);\r\n\r\n  if (corner == 3.0 || corner == 1.0) {\r\n    worldPos.xyz -= (direction * rayLength * stretchFactor * globalSizeFactor);\r\n  }\r\n\r\n  if (corner == 0.0 || corner == 2.0) {\r\n    worldPos.xyz += (direction * rayLength * stretchFactor * globalSizeFactor);\r\n  }\r\n\r\n  vec4 viewPosition = viewMatrix * worldPos;\r\n\r\n  viewPosition = rotation * vec4(viewPosition.xyz, 1.0);\r\n\r\n  float size =  0.1 * globalSizeFactor;\r\n  float angle = atan(-worldOrigin.y, -worldOrigin.x);\r\n  float verticalStretch = mix(size, thickness, stretchFactor);\r\n\r\n  if (corner == 0.0) {\r\n    viewPosition.xy += rotate(vec2(-size, -verticalStretch), angle);\r\n    vCornerColor = vec3(1.0, 0.0, 0.0);\r\n  }\r\n\r\n  if (corner == 1.0) {\r\n    viewPosition.xy += rotate(vec2(size, -verticalStretch), angle);\r\n    vCornerColor = vec3(0.0, 1.0, 0.0);\r\n  }\r\n\r\n  if (corner == 2.0) {\r\n    viewPosition.xy += rotate(vec2(-size, verticalStretch), angle);\r\n    vCornerColor = vec3(0.0, 0.0, 1.0);\r\n  }\r\n\r\n  if (corner == 3.0) {\r\n    viewPosition.xy += rotate(vec2(size, verticalStretch), angle);\r\n    vCornerColor = vec3(1.0, 0.0, 1.0);\r\n  }\r\n\r\n\r\n  vec4 pPosition = projectionMatrix * viewPosition;\r\n  pPosition.xy /= pPosition.w;\r\n\r\n  // Camera Shake\r\n  float offsetX = remap(texture2D(noise, vec2(time * shakeSpeed, 0)).r, 0.0, 1.0, -1.0, 1.0);\r\n  float offsetY = remap(texture2D(noise, vec2(time * shakeSpeed, 0.5)).r, 0.0, 1.0, -1.0, 1.0);\r\n  vec2 offset = vec2(offsetX, offsetY) * shakeStrength;\r\n  pPosition.xy += offset;\r\n\r\n\r\n  pPosition.xy *= pPosition.w;\r\n\r\n  gl_Position = pPosition;\r\n}" }, function (t, e) { t.exports = "varying vec2 vUv;\r\nvarying float vOpacity;\r\nvarying vec3 vColor;\r\nvarying vec3 vCornerColor;\r\n\r\nuniform vec3 psColor;\r\n\r\nuniform sampler2D map;\r\n\r\nvoid main() {\r\n\r\n  vec4 texel = texture2D( map, vUv );\r\n  float alpha = texel.r * vOpacity;\r\n  vec3 color = mix(vColor, vec3(1.0), texel.r);\r\n\r\n  gl_FragColor = vec4(color, alpha);\r\n}" }, function (t, e) { t.exports = "varying vec2 vUvSample1;\r\nvarying vec2 vUvSample2;\r\nvarying vec2 vUvSample3;\r\nuniform vec4 offsetRepeatMin;\r\nuniform vec4 offsetRepeatMax;\r\nuniform float time;\r\nuniform float intensity;\r\nuniform mat4 rotation;\r\n\r\nvarying vec3 vViewPosition;\r\n\r\nvec2 transformUV(in vec2 uv, in float t, in vec2 offset, in vec2 scale) {\r\n  vec2 result = vec2(uv.x, uv.y);\r\n  result *= scale;\r\n  result += (offset * t);\r\n  return result;\r\n}\r\n\r\nvoid main() {\r\n  vec4 offsetRepeat = mix(offsetRepeatMin, offsetRepeatMax, intensity);\r\n\r\n  vec2 uvOffset1 = offsetRepeat.xy * vec2(1.0, 1.0);\r\n  vec2 uvOffset2 = offsetRepeat.xy * vec2(1.0, 1.0);\r\n  vec2 uvOffset3 = offsetRepeat.xy * vec2(1.0, 1.0);\r\n\r\n  vec2 uvScale1 = offsetRepeat.zw * vec2(1.0, 1.0);\r\n  vec2 uvScale2 = offsetRepeat.zw * vec2(0.5, 1.0);\r\n  vec2 uvScale3 = offsetRepeat.zw * vec2(2.0, 1.0);\r\n\r\n  vUvSample1 = transformUV(uv, time * 2.0, uvOffset1, uvScale1);\r\n  vUvSample2 = transformUV(uv, time * 0.5, uvOffset2, uvScale2);\r\n  vUvSample3 = transformUV(uv, time * 8.0, uvOffset3, uvScale3);\r\n\r\n  vec3 viewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\r\n\r\n  viewPosition = (rotation * vec4(viewPosition, 1.0)).xyz;\r\n\r\n  vViewPosition = viewPosition;\r\n\r\n  gl_Position = projectionMatrix * vec4(viewPosition, 1.0);\r\n}" }, function (t, e) { t.exports = "varying vec2 vUvSample1;\r\nvarying vec2 vUvSample2;\r\nvarying vec2 vUvSample3;\r\nvarying vec3 vViewPosition;\r\n\r\nuniform float time;\r\nuniform sampler2D map;\r\nuniform vec3 colorMin;\r\nuniform vec3 colorMax;\r\nuniform vec2 opacityRange;\r\nuniform float intensity;\r\nuniform float fallOffDistance;\r\nuniform float globalOpacity;\r\n\r\nfloat remap(float value, float inMin, float inMax, float outMin, float outMax) {\r\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\r\n}\r\n\r\nvec2 remap(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\r\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\r\n}\r\n\r\nvec3 remap(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {\r\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\r\n}\r\n\r\nvec4 remap(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {\r\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\r\n}\r\n\r\nfloat multiplyX2(in float a, in float b) {\r\n  return a * b * 2.0;\r\n}\r\n\r\nfloat linearTosRGB(const in float c) {\r\n  if (c >= 1.0) return 1.0;\r\n  float S1 = sqrt(c);\r\n  float S2 = sqrt(S1);\r\n  float S3 = sqrt(S2);\r\n  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;\r\n}\r\n\r\nvec3 linearTosRGB(const in vec3 c) {\r\n  vec3 cm = c;\r\n  vec3 S1 = sqrt(cm);\r\n  vec3 S2 = sqrt(S1);\r\n  vec3 S3 = sqrt(S2);\r\n  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm;\r\n}\r\n\r\nvec4 linearTosRGB(const in vec4 c) {\r\n  vec3 cm = min(c.rgb, 1.0);\r\n  vec3 S1 = sqrt(cm);\r\n  vec3 S2 = sqrt(S1);\r\n  vec3 S3 = sqrt(S2);\r\n  return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * cm, c.a);\r\n}\r\n\r\nvoid main() {\r\n  vec3 color = mix(colorMin, colorMax, intensity);\r\n  float opacity = mix(opacityRange.x, opacityRange.y, intensity) * globalOpacity;\r\n  vec4 outputColor = vec4(color, opacity);\r\n\r\n  vec4 sample1 = texture2D(map, vUvSample1);\r\n  vec4 sample2 = texture2D(map, vUvSample2);\r\n  vec4 sample3 = texture2D(map, vUvSample3);\r\n\r\n  float alpha = multiplyX2(multiplyX2(sample1.r, sample2.r), sample3.r);\r\n\r\n  float falloff = clamp(remap(vViewPosition.z, 0.0, fallOffDistance, 1.0, 0.0), 0.0, 1.0);\r\n\r\n  outputColor.a *= alpha;\r\n\r\n  outputColor.a = linearTosRGB(outputColor.a);\r\n\r\n  outputColor.a *= falloff;\r\n\r\n  gl_FragColor = outputColor;\r\n}" }, function (t, e, r) { "use strict"; var n = r(0), i = r(2), o = r(29), s = r(28), a = r(6), c = r(89), u = r(113), l = r(1), h = r(10), f = r(57), p = r(3), d = r(4), m = r(11), g = r(20), v = r(31), y = r(34), x = r(35), b = r(58), w = r(41), M = r(116), S = r(88), _ = r(13), T = r(9), E = r(66), A = r(15), R = r(16), L = r(85), O = r(67), P = r(54), I = r(53), C = r(5), k = r(117), N = r(18), z = r(32), U = r(17), j = r(12).forEach, B = O("hidden"), F = C("toPrimitive"), D = U.set, G = U.getterFor("Symbol"), V = Object.prototype, H = i.Symbol, W = o("JSON", "stringify"), q = _.f, X = T.f, Y = M.f, Z = E.f, K = L("symbols"), J = L("op-symbols"), Q = L("string-to-symbol-registry"), $ = L("symbol-to-string-registry"), tt = L("wks"), et = i.QObject, rt = !et || !et.prototype || !et.prototype.findChild, nt = a && l((function () { return 7 != x(X({}, "a", { get: function () { return X(this, "a", { value: 7 }).a } })).a })) ? function (t, e, r) { var n = q(V, e); n && delete V[e], X(t, e, r), n && t !== V && X(V, e, n) } : X, it = function (t, e) { var r = K[t] = x(H.prototype); return D(r, { type: "Symbol", tag: t, description: e }), a || (r.description = e), r }, ot = u ? function (t) { return "symbol" == typeof t } : function (t) { return Object(t) instanceof H }, st = function (t, e, r) { t === V && st(J, e, r), d(t); var n = v(e, !0); return d(r), h(K, n) ? (r.enumerable ? (h(t, B) && t[B][n] && (t[B][n] = !1), r = x(r, { enumerable: y(0, !1) })) : (h(t, B) || X(t, B, y(1, {})), t[B][n] = !0), nt(t, n, r)) : X(t, n, r) }, at = function (t, e) { d(t); var r = g(e), n = b(r).concat(ht(r)); return j(n, (function (e) { a && !ct.call(r, e) || st(t, e, r[e]) })), t }, ct = function (t) { var e = v(t, !0), r = Z.call(this, e); return !(this === V && h(K, e) && !h(J, e)) && (!(r || !h(this, e) || !h(K, e) || h(this, B) && this[B][e]) || r) }, ut = function (t, e) { var r = g(t), n = v(e, !0); if (r !== V || !h(K, n) || h(J, n)) { var i = q(r, n); return !i || !h(K, n) || h(r, B) && r[B][n] || (i.enumerable = !0), i } }, lt = function (t) { var e = Y(g(t)), r = []; return j(e, (function (t) { h(K, t) || h(P, t) || r.push(t) })), r }, ht = function (t) { var e = t === V, r = Y(e ? J : g(t)), n = []; return j(r, (function (t) { !h(K, t) || e && !h(V, t) || n.push(K[t]) })), n }; (c || (R((H = function () { if (this instanceof H) throw TypeError("Symbol is not a constructor"); var t = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0, e = I(t), r = function (t) { this === V && r.call(J, t), h(this, B) && h(this[B], e) && (this[B][e] = !1), nt(this, e, y(1, t)) }; return a && rt && nt(V, e, { configurable: !0, set: r }), it(e, t) }).prototype, "toString", (function () { return G(this).tag })), R(H, "withoutSetter", (function (t) { return it(I(t), t) })), E.f = ct, T.f = st, _.f = ut, w.f = M.f = lt, S.f = ht, k.f = function (t) { return it(C(t), t) }, a && (X(H.prototype, "description", { configurable: !0, get: function () { return G(this).description } }), s || R(V, "propertyIsEnumerable", ct, { unsafe: !0 }))), n({ global: !0, wrap: !0, forced: !c, sham: !c }, { Symbol: H }), j(b(tt), (function (t) { N(t) })), n({ target: "Symbol", stat: !0, forced: !c }, { for: function (t) { var e = String(t); if (h(Q, e)) return Q[e]; var r = H(e); return Q[e] = r, $[r] = e, r }, keyFor: function (t) { if (!ot(t)) throw TypeError(t + " is not a symbol"); if (h($, t)) return $[t] }, useSetter: function () { rt = !0 }, useSimple: function () { rt = !1 } }), n({ target: "Object", stat: !0, forced: !c, sham: !a }, { create: function (t, e) { return void 0 === e ? x(t) : at(x(t), e) }, defineProperty: st, defineProperties: at, getOwnPropertyDescriptor: ut }), n({ target: "Object", stat: !0, forced: !c }, { getOwnPropertyNames: lt, getOwnPropertySymbols: ht }), n({ target: "Object", stat: !0, forced: l((function () { S.f(1) })) }, { getOwnPropertySymbols: function (t) { return S.f(m(t)) } }), W) && n({ target: "JSON", stat: !0, forced: !c || l((function () { var t = H(); return "[null]" != W([t]) || "{}" != W({ a: t }) || "{}" != W(Object(t)) })) }, { stringify: function (t, e, r) { for (var n, i = [t], o = 1; arguments.length > o;)i.push(arguments[o++]); if (n = e, (p(e) || void 0 !== t) && !ot(t)) return f(e) || (e = function (t, e) { if ("function" == typeof n && (e = n.call(this, t, e)), !ot(e)) return e }), i[1] = e, W.apply(null, i) } }); H.prototype[F] || A(H.prototype, F, H.prototype.valueOf), z(H, "Symbol"), P[B] = !0 }, function (t, e) { var r; r = function () { return this }(); try { r = r || new Function("return this")() } catch (t) { "object" == typeof window && (r = window) } t.exports = r }, function (t, e, r) { "use strict"; var n = r(0), i = r(6), o = r(2), s = r(10), a = r(3), c = r(9).f, u = r(110), l = o.Symbol; if (i && "function" == typeof l && (!("description" in l.prototype) || void 0 !== l().description)) { var h = {}, f = function () { var t = arguments.length < 1 || void 0 === arguments[0] ? void 0 : String(arguments[0]), e = this instanceof f ? new l(t) : void 0 === t ? l() : l(t); return "" === t && (h[e] = !0), e }; u(f, l); var p = f.prototype = l.prototype; p.constructor = f; var d = p.toString, m = "Symbol(test)" == String(l("test")), g = /^Symbol\((.*)\)[^)]+$/; c(p, "description", { configurable: !0, get: function () { var t = a(this) ? this.valueOf() : this, e = d.call(t); if (s(h, t)) return ""; var r = m ? e.slice(7, -1) : e.replace(g, "$1"); return "" === r ? void 0 : r } }), n({ global: !0, forced: !0 }, { Symbol: f }) } }, function (t, e, r) { r(18)("asyncIterator") }, function (t, e, r) { r(18)("hasInstance") }, function (t, e, r) { r(18)("isConcatSpreadable") }, function (t, e, r) { r(18)("iterator") }, function (t, e, r) { r(18)("match") }, function (t, e, r) { r(18)("matchAll") }, function (t, e, r) { r(18)("replace") }, function (t, e, r) { r(18)("search") }, function (t, e, r) { r(18)("species") }, function (t, e, r) { r(18)("split") }, function (t, e, r) { r(18)("toPrimitive") }, function (t, e, r) { r(18)("toStringTag") }, function (t, e, r) { r(18)("unscopables") }, function (t, e, r) { "use strict"; var n = r(0), i = r(1), o = r(57), s = r(3), a = r(11), c = r(7), u = r(43), l = r(59), h = r(60), f = r(5), p = r(90), d = f("isConcatSpreadable"), m = p >= 51 || !i((function () { var t = []; return t[d] = !1, t.concat()[0] !== t })), g = h("concat"), v = function (t) { if (!s(t)) return !1; var e = t[d]; return void 0 !== e ? !!e : o(t) }; n({ target: "Array", proto: !0, forced: !m || !g }, { concat: function (t) { var e, r, n, i, o, s = a(this), h = l(s, 0), f = 0; for (e = -1, n = arguments.length; e < n; e++)if (v(o = -1 === e ? s : arguments[e])) { if (f + (i = c(o.length)) > 9007199254740991) throw TypeError("Maximum allowed index exceeded"); for (r = 0; r < i; r++, f++)r in o && u(h, f, o[r]) } else { if (f >= 9007199254740991) throw TypeError("Maximum allowed index exceeded"); u(h, f++, o) } return h.length = f, h } }) }, function (t, e, r) { var n = r(0), i = r(118), o = r(37); n({ target: "Array", proto: !0 }, { copyWithin: i }), o("copyWithin") }, function (t, e, r) { "use strict"; var n = r(0), i = r(12).every, o = r(38), s = r(19), a = o("every"), c = s("every"); n({ target: "Array", proto: !0, forced: !a || !c }, { every: function (t) { return i(this, t, arguments.length > 1 ? arguments[1] : void 0) } }) }, function (t, e, r) { var n = r(0), i = r(92), o = r(37); n({ target: "Array", proto: !0 }, { fill: i }), o("fill") }, function (t, e, r) { "use strict"; var n = r(0), i = r(12).filter, o = r(60), s = r(19), a = o("filter"), c = s("filter"); n({ target: "Array", proto: !0, forced: !a || !c }, { filter: function (t) { return i(this, t, arguments.length > 1 ? arguments[1] : void 0) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(12).find, o = r(37), s = r(19), a = !0, c = s("find"); "find" in [] && Array(1).find((function () { a = !1 })), n({ target: "Array", proto: !0, forced: a || !c }, { find: function (t) { return i(this, t, arguments.length > 1 ? arguments[1] : void 0) } }), o("find") }, function (t, e, r) { "use strict"; var n = r(0), i = r(12).findIndex, o = r(37), s = r(19), a = !0, c = s("findIndex"); "findIndex" in [] && Array(1).findIndex((function () { a = !1 })), n({ target: "Array", proto: !0, forced: a || !c }, { findIndex: function (t) { return i(this, t, arguments.length > 1 ? arguments[1] : void 0) } }), o("findIndex") }, function (t, e, r) { "use strict"; var n = r(0), i = r(119), o = r(11), s = r(7), a = r(25), c = r(59); n({ target: "Array", proto: !0 }, { flat: function () { var t = arguments.length ? arguments[0] : void 0, e = o(this), r = s(e.length), n = c(e, 0); return n.length = i(n, e, e, r, 0, void 0 === t ? 1 : a(t)), n } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(119), o = r(11), s = r(7), a = r(21), c = r(59); n({ target: "Array", proto: !0 }, { flatMap: function (t) { var e, r = o(this), n = s(r.length); return a(t), (e = c(r, 0)).length = i(e, r, r, n, 0, 1, t, arguments.length > 1 ? arguments[1] : void 0), e } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(120); n({ target: "Array", proto: !0, forced: [].forEach != i }, { forEach: i }) }, function (t, e, r) { var n = r(0), i = r(121); n({ target: "Array", stat: !0, forced: !r(68)((function (t) { Array.from(t) })) }, { from: i }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(55).includes, o = r(37); n({ target: "Array", proto: !0, forced: !r(19)("indexOf", { ACCESSORS: !0, 1: 0 }) }, { includes: function (t) { return i(this, t, arguments.length > 1 ? arguments[1] : void 0) } }), o("includes") }, function (t, e, r) { "use strict"; var n = r(0), i = r(55).indexOf, o = r(38), s = r(19), a = [].indexOf, c = !!a && 1 / [1].indexOf(1, -0) < 0, u = o("indexOf"), l = s("indexOf", { ACCESSORS: !0, 1: 0 }); n({ target: "Array", proto: !0, forced: c || !u || !l }, { indexOf: function (t) { return c ? a.apply(this, arguments) || 0 : i(this, t, arguments.length > 1 ? arguments[1] : void 0) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(52), o = r(20), s = r(38), a = [].join, c = i != Object, u = s("join", ","); n({ target: "Array", proto: !0, forced: c || !u }, { join: function (t) { return a.call(o(this), void 0 === t ? "," : t) } }) }, function (t, e, r) { var n = r(0), i = r(125); n({ target: "Array", proto: !0, forced: i !== [].lastIndexOf }, { lastIndexOf: i }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(12).map, o = r(60), s = r(19), a = o("map"), c = s("map"); n({ target: "Array", proto: !0, forced: !a || !c }, { map: function (t) { return i(this, t, arguments.length > 1 ? arguments[1] : void 0) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(1), o = r(43); n({ target: "Array", stat: !0, forced: i((function () { function t() { } return !(Array.of.call(t) instanceof t) })) }, { of: function () { for (var t = 0, e = arguments.length, r = new ("function" == typeof this ? this : Array)(e); e > t;)o(r, t, arguments[t++]); return r.length = e, r } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(70).left, o = r(38), s = r(19), a = o("reduce"), c = s("reduce", { 1: 0 }); n({ target: "Array", proto: !0, forced: !a || !c }, { reduce: function (t) { return i(this, t, arguments.length, arguments.length > 1 ? arguments[1] : void 0) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(70).right, o = r(38), s = r(19), a = o("reduceRight"), c = s("reduce", { 1: 0 }); n({ target: "Array", proto: !0, forced: !a || !c }, { reduceRight: function (t) { return i(this, t, arguments.length, arguments.length > 1 ? arguments[1] : void 0) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(3), o = r(57), s = r(42), a = r(7), c = r(20), u = r(43), l = r(5), h = r(60), f = r(19), p = h("slice"), d = f("slice", { ACCESSORS: !0, 0: 0, 1: 2 }), m = l("species"), g = [].slice, v = Math.max; n({ target: "Array", proto: !0, forced: !p || !d }, { slice: function (t, e) { var r, n, l, h = c(this), f = a(h.length), p = s(t, f), d = s(void 0 === e ? f : e, f); if (o(h) && ("function" != typeof (r = h.constructor) || r !== Array && !o(r.prototype) ? i(r) && null === (r = r[m]) && (r = void 0) : r = void 0, r === Array || void 0 === r)) return g.call(h, p, d); for (n = new (void 0 === r ? Array : r)(v(d - p, 0)), l = 0; p < d; p++, l++)p in h && u(n, l, h[p]); return n.length = l, n } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(12).some, o = r(38), s = r(19), a = o("some"), c = s("some"); n({ target: "Array", proto: !0, forced: !a || !c }, { some: function (t) { return i(this, t, arguments.length > 1 ? arguments[1] : void 0) } }) }, function (t, e, r) { r(46)("Array") }, function (t, e, r) { "use strict"; var n = r(0), i = r(42), o = r(25), s = r(7), a = r(11), c = r(59), u = r(43), l = r(60), h = r(19), f = l("splice"), p = h("splice", { ACCESSORS: !0, 0: 0, 1: 2 }), d = Math.max, m = Math.min; n({ target: "Array", proto: !0, forced: !f || !p }, { splice: function (t, e) { var r, n, l, h, f, p, g = a(this), v = s(g.length), y = i(t, v), x = arguments.length; if (0 === x ? r = n = 0 : 1 === x ? (r = 0, n = v - y) : (r = x - 2, n = m(d(o(e), 0), v - y)), v + r - n > 9007199254740991) throw TypeError("Maximum allowed length exceeded"); for (l = c(g, n), h = 0; h < n; h++)(f = y + h) in g && u(l, h, g[f]); if (l.length = n, r < n) { for (h = y; h < v - n; h++)p = h + r, (f = h + n) in g ? g[p] = g[f] : delete g[p]; for (h = v; h > v - n + r; h--)delete g[h - 1] } else if (r > n) for (h = v - n; h > y; h--)p = h + r - 1, (f = h + n - 1) in g ? g[p] = g[f] : delete g[p]; for (h = 0; h < r; h++)g[h + y] = arguments[h + 2]; return g.length = v - n + r, l } }) }, function (t, e, r) { r(37)("flat") }, function (t, e, r) { r(37)("flatMap") }, function (t, e, r) { "use strict"; var n = r(0), i = r(2), o = r(126), s = r(46), a = o.ArrayBuffer; n({ global: !0, forced: i.ArrayBuffer !== a }, { ArrayBuffer: a }), s("ArrayBuffer") }, function (t, e) { var r = Math.abs, n = Math.pow, i = Math.floor, o = Math.log, s = Math.LN2; t.exports = { pack: function (t, e, a) { var c, u, l, h = new Array(a), f = 8 * a - e - 1, p = (1 << f) - 1, d = p >> 1, m = 23 === e ? n(2, -24) - n(2, -77) : 0, g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0, v = 0; for ((t = r(t)) != t || t === 1 / 0 ? (u = t != t ? 1 : 0, c = p) : (c = i(o(t) / s), t * (l = n(2, -c)) < 1 && (c--, l *= 2), (t += c + d >= 1 ? m / l : m * n(2, 1 - d)) * l >= 2 && (c++, l /= 2), c + d >= p ? (u = 0, c = p) : c + d >= 1 ? (u = (t * l - 1) * n(2, e), c += d) : (u = t * n(2, d - 1) * n(2, e), c = 0)); e >= 8; h[v++] = 255 & u, u /= 256, e -= 8); for (c = c << e | u, f += e; f > 0; h[v++] = 255 & c, c /= 256, f -= 8); return h[--v] |= 128 * g, h }, unpack: function (t, e) { var r, i = t.length, o = 8 * i - e - 1, s = (1 << o) - 1, a = s >> 1, c = o - 7, u = i - 1, l = t[u--], h = 127 & l; for (l >>= 7; c > 0; h = 256 * h + t[u], u--, c -= 8); for (r = h & (1 << -c) - 1, h >>= -c, c += e; c > 0; r = 256 * r + t[u], u--, c -= 8); if (0 === h) h = 1 - a; else { if (h === s) return r ? NaN : l ? -1 / 0 : 1 / 0; r += n(2, e), h -= a } return (l ? -1 : 1) * r * n(2, h - e) } } }, function (t, e, r) { var n = r(15), i = r(199), o = r(5)("toPrimitive"), s = Date.prototype; o in s || n(s, o, i) }, function (t, e, r) { "use strict"; var n = r(4), i = r(31); t.exports = function (t) { if ("string" !== t && "number" !== t && "default" !== t) throw TypeError("Incorrect hint"); return i(n(this), "number" !== t) } }, function (t, e, r) { "use strict"; var n = r(3), i = r(9), o = r(30), s = r(5)("hasInstance"), a = Function.prototype; s in a || i.f(a, s, { value: function (t) { if ("function" != typeof this || !n(t)) return !1; if (!n(this.prototype)) return t instanceof this; for (; t = o(t);)if (this.prototype === t) return !0; return !1 } }) }, function (t, e, r) { var n = r(6), i = r(9).f, o = Function.prototype, s = o.toString, a = /^\s*function ([^ (]*)/; n && !("name" in o) && i(o, "name", { configurable: !0, get: function () { try { return s.call(this).match(a)[1] } catch (t) { return "" } } }) }, function (t, e, r) { r(0)({ global: !0 }, { globalThis: r(2) }) }, function (t, e, r) { var n = r(2); r(32)(n.JSON, "JSON", !0) }, function (t, e, r) { "use strict"; var n = r(71), i = r(129); t.exports = n("Map", (function (t) { return function () { return t(this, arguments.length ? arguments[0] : void 0) } }), i) }, function (t, e, r) { var n = r(0), i = r(130), o = Math.acosh, s = Math.log, a = Math.sqrt, c = Math.LN2; n({ target: "Math", stat: !0, forced: !o || 710 != Math.floor(o(Number.MAX_VALUE)) || o(1 / 0) != 1 / 0 }, { acosh: function (t) { return (t = +t) < 1 ? NaN : t > 94906265.62425156 ? s(t) + c : i(t - 1 + a(t - 1) * a(t + 1)) } }) }, function (t, e, r) { var n = r(0), i = Math.asinh, o = Math.log, s = Math.sqrt; n({ target: "Math", stat: !0, forced: !(i && 1 / i(0) > 0) }, { asinh: function t(e) { return isFinite(e = +e) && 0 != e ? e < 0 ? -t(-e) : o(e + s(e * e + 1)) : e } }) }, function (t, e, r) { var n = r(0), i = Math.atanh, o = Math.log; n({ target: "Math", stat: !0, forced: !(i && 1 / i(-0) < 0) }, { atanh: function (t) { return 0 == (t = +t) ? t : o((1 + t) / (1 - t)) / 2 } }) }, function (t, e, r) { var n = r(0), i = r(98), o = Math.abs, s = Math.pow; n({ target: "Math", stat: !0 }, { cbrt: function (t) { return i(t = +t) * s(o(t), 1 / 3) } }) }, function (t, e, r) { var n = r(0), i = Math.floor, o = Math.log, s = Math.LOG2E; n({ target: "Math", stat: !0 }, { clz32: function (t) { return (t >>>= 0) ? 31 - i(o(t + .5) * s) : 32 } }) }, function (t, e, r) { var n = r(0), i = r(73), o = Math.cosh, s = Math.abs, a = Math.E; n({ target: "Math", stat: !0, forced: !o || o(710) === 1 / 0 }, { cosh: function (t) { var e = i(s(t) - 1) + 1; return (e + 1 / (e * a * a)) * (a / 2) } }) }, function (t, e, r) { var n = r(0), i = r(73); n({ target: "Math", stat: !0, forced: i != Math.expm1 }, { expm1: i }) }, function (t, e, r) { r(0)({ target: "Math", stat: !0 }, { fround: r(213) }) }, function (t, e, r) { var n = r(98), i = Math.abs, o = Math.pow, s = o(2, -52), a = o(2, -23), c = o(2, 127) * (2 - a), u = o(2, -126); t.exports = Math.fround || function (t) { var e, r, o = i(t), l = n(t); return o < u ? l * (o / u / a + 1 / s - 1 / s) * u * a : (r = (e = (1 + a / s) * o) - (e - o)) > c || r != r ? l * (1 / 0) : l * r } }, function (t, e, r) { var n = r(0), i = Math.hypot, o = Math.abs, s = Math.sqrt; n({ target: "Math", stat: !0, forced: !!i && i(1 / 0, NaN) !== 1 / 0 }, { hypot: function (t, e) { for (var r, n, i = 0, a = 0, c = arguments.length, u = 0; a < c;)u < (r = o(arguments[a++])) ? (i = i * (n = u / r) * n + 1, u = r) : i += r > 0 ? (n = r / u) * n : r; return u === 1 / 0 ? 1 / 0 : u * s(i) } }) }, function (t, e, r) { var n = r(0), i = r(1), o = Math.imul; n({ target: "Math", stat: !0, forced: i((function () { return -5 != o(4294967295, 5) || 2 != o.length })) }, { imul: function (t, e) { var r = +t, n = +e, i = 65535 & r, o = 65535 & n; return 0 | i * o + ((65535 & r >>> 16) * o + i * (65535 & n >>> 16) << 16 >>> 0) } }) }, function (t, e, r) { var n = r(0), i = Math.log, o = Math.LOG10E; n({ target: "Math", stat: !0 }, { log10: function (t) { return i(t) * o } }) }, function (t, e, r) { r(0)({ target: "Math", stat: !0 }, { log1p: r(130) }) }, function (t, e, r) { var n = r(0), i = Math.log, o = Math.LN2; n({ target: "Math", stat: !0 }, { log2: function (t) { return i(t) / o } }) }, function (t, e, r) { r(0)({ target: "Math", stat: !0 }, { sign: r(98) }) }, function (t, e, r) { var n = r(0), i = r(1), o = r(73), s = Math.abs, a = Math.exp, c = Math.E; n({ target: "Math", stat: !0, forced: i((function () { return -2e-17 != Math.sinh(-2e-17) })) }, { sinh: function (t) { return s(t = +t) < 1 ? (o(t) - o(-t)) / 2 : (a(t - 1) - a(-t - 1)) * (c / 2) } }) }, function (t, e, r) { var n = r(0), i = r(73), o = Math.exp; n({ target: "Math", stat: !0 }, { tanh: function (t) { var e = i(t = +t), r = i(-t); return e == 1 / 0 ? 1 : r == 1 / 0 ? -1 : (e - r) / (o(t) + o(-t)) } }) }, function (t, e, r) { r(32)(Math, "Math", !0) }, function (t, e, r) { var n = r(0), i = Math.ceil, o = Math.floor; n({ target: "Math", stat: !0 }, { trunc: function (t) { return (t > 0 ? o : i)(t) } }) }, function (t, e, r) { "use strict"; var n = r(6), i = r(2), o = r(56), s = r(16), a = r(10), c = r(24), u = r(72), l = r(31), h = r(1), f = r(35), p = r(41).f, d = r(13).f, m = r(9).f, g = r(49).trim, v = i.Number, y = v.prototype, x = "Number" == c(f(y)), b = function (t) { var e, r, n, i, o, s, a, c, u = l(t, !1); if ("string" == typeof u && u.length > 2) if (43 === (e = (u = g(u)).charCodeAt(0)) || 45 === e) { if (88 === (r = u.charCodeAt(2)) || 120 === r) return NaN } else if (48 === e) { switch (u.charCodeAt(1)) { case 66: case 98: n = 2, i = 49; break; case 79: case 111: n = 8, i = 55; break; default: return +u }for (s = (o = u.slice(2)).length, a = 0; a < s; a++)if ((c = o.charCodeAt(a)) < 48 || c > i) return NaN; return parseInt(o, n) } return +u }; if (o("Number", !v(" 0o1") || !v("0b1") || v("+0x1"))) { for (var w, M = function (t) { var e = arguments.length < 1 ? 0 : t, r = this; return r instanceof M && (x ? h((function () { y.valueOf.call(r) })) : "Number" != c(r)) ? u(new v(b(e)), r, M) : b(e) }, S = n ? p(v) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), _ = 0; S.length > _; _++)a(v, w = S[_]) && !a(M, w) && m(M, w, d(v, w)); M.prototype = y, y.constructor = M, s(i, "Number", M) } }, function (t, e, r) { r(0)({ target: "Number", stat: !0 }, { EPSILON: Math.pow(2, -52) }) }, function (t, e, r) { r(0)({ target: "Number", stat: !0 }, { isFinite: r(227) }) }, function (t, e, r) { var n = r(2).isFinite; t.exports = Number.isFinite || function (t) { return "number" == typeof t && n(t) } }, function (t, e, r) { r(0)({ target: "Number", stat: !0 }, { isInteger: r(131) }) }, function (t, e, r) { r(0)({ target: "Number", stat: !0 }, { isNaN: function (t) { return t != t } }) }, function (t, e, r) { var n = r(0), i = r(131), o = Math.abs; n({ target: "Number", stat: !0 }, { isSafeInteger: function (t) { return i(t) && o(t) <= 9007199254740991 } }) }, function (t, e, r) { r(0)({ target: "Number", stat: !0 }, { MAX_SAFE_INTEGER: 9007199254740991 }) }, function (t, e, r) { r(0)({ target: "Number", stat: !0 }, { MIN_SAFE_INTEGER: -9007199254740991 }) }, function (t, e, r) { var n = r(0), i = r(234); n({ target: "Number", stat: !0, forced: Number.parseFloat != i }, { parseFloat: i }) }, function (t, e, r) { var n = r(2), i = r(49).trim, o = r(74), s = n.parseFloat, a = 1 / s(o + "-0") != -1 / 0; t.exports = a ? function (t) { var e = i(String(t)), r = s(e); return 0 === r && "-" == e.charAt(0) ? -0 : r } : s }, function (t, e, r) { var n = r(0), i = r(236); n({ target: "Number", stat: !0, forced: Number.parseInt != i }, { parseInt: i }) }, function (t, e, r) { var n = r(2), i = r(49).trim, o = r(74), s = n.parseInt, a = /^[+-]?0[Xx]/, c = 8 !== s(o + "08") || 22 !== s(o + "0x16"); t.exports = c ? function (t, e) { var r = i(String(t)); return s(r, e >>> 0 || (a.test(r) ? 16 : 10)) } : s }, function (t, e, r) { "use strict"; var n = r(0), i = r(25), o = r(238), s = r(99), a = r(1), c = 1..toFixed, u = Math.floor, l = function (t, e, r) { return 0 === e ? r : e % 2 == 1 ? l(t, e - 1, r * t) : l(t * t, e / 2, r) }; n({ target: "Number", proto: !0, forced: c && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !a((function () { c.call({}) })) }, { toFixed: function (t) { var e, r, n, a, c = o(this), h = i(t), f = [0, 0, 0, 0, 0, 0], p = "", d = "0", m = function (t, e) { for (var r = -1, n = e; ++r < 6;)n += t * f[r], f[r] = n % 1e7, n = u(n / 1e7) }, g = function (t) { for (var e = 6, r = 0; --e >= 0;)r += f[e], f[e] = u(r / t), r = r % t * 1e7 }, v = function () { for (var t = 6, e = ""; --t >= 0;)if ("" !== e || 0 === t || 0 !== f[t]) { var r = String(f[t]); e = "" === e ? r : e + s.call("0", 7 - r.length) + r } return e }; if (h < 0 || h > 20) throw RangeError("Incorrect fraction digits"); if (c != c) return "NaN"; if (c <= -1e21 || c >= 1e21) return String(c); if (c < 0 && (p = "-", c = -c), c > 1e-21) if (r = (e = function (t) { for (var e = 0, r = t; r >= 4096;)e += 12, r /= 4096; for (; r >= 2;)e += 1, r /= 2; return e }(c * l(2, 69, 1)) - 69) < 0 ? c * l(2, -e, 1) : c / l(2, e, 1), r *= 4503599627370496, (e = 52 - e) > 0) { for (m(0, r), n = h; n >= 7;)m(1e7, 0), n -= 7; for (m(l(10, n, 1), 0), n = e - 1; n >= 23;)g(1 << 23), n -= 23; g(1 << n), m(1, 1), g(2), d = v() } else m(0, r), m(1 << -e, 0), d = v() + s.call("0", h); return d = h > 0 ? p + ((a = d.length) <= h ? "0." + s.call("0", h - a) + d : d.slice(0, a - h) + "." + d.slice(a - h)) : p + d } }) }, function (t, e, r) { var n = r(24); t.exports = function (t) { if ("number" != typeof t && "Number" != n(t)) throw TypeError("Incorrect invocation"); return +t } }, function (t, e, r) { var n = r(0), i = r(132); n({ target: "Object", stat: !0, forced: Object.assign !== i }, { assign: i }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(6), o = r(75), s = r(11), a = r(21), c = r(9); i && n({ target: "Object", proto: !0, forced: o }, { __defineGetter__: function (t, e) { c.f(s(this), t, { get: a(e), enumerable: !0, configurable: !0 }) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(6), o = r(75), s = r(11), a = r(21), c = r(9); i && n({ target: "Object", proto: !0, forced: o }, { __defineSetter__: function (t, e) { c.f(s(this), t, { set: a(e), enumerable: !0, configurable: !0 }) } }) }, function (t, e, r) { var n = r(0), i = r(133).entries; n({ target: "Object", stat: !0 }, { entries: function (t) { return i(t) } }) }, function (t, e, r) { var n = r(0), i = r(64), o = r(1), s = r(3), a = r(44).onFreeze, c = Object.freeze; n({ target: "Object", stat: !0, forced: o((function () { c(1) })), sham: !i }, { freeze: function (t) { return c && s(t) ? c(a(t)) : t } }) }, function (t, e, r) { var n = r(0), i = r(48), o = r(43); n({ target: "Object", stat: !0 }, { fromEntries: function (t) { var e = {}; return i(t, (function (t, r) { o(e, t, r) }), void 0, !0), e } }) }, function (t, e, r) { var n = r(0), i = r(1), o = r(20), s = r(13).f, a = r(6), c = i((function () { s(1) })); n({ target: "Object", stat: !0, forced: !a || c, sham: !a }, { getOwnPropertyDescriptor: function (t, e) { return s(o(t), e) } }) }, function (t, e, r) { var n = r(0), i = r(6), o = r(86), s = r(20), a = r(13), c = r(43); n({ target: "Object", stat: !0, sham: !i }, { getOwnPropertyDescriptors: function (t) { for (var e, r, n = s(t), i = a.f, u = o(n), l = {}, h = 0; u.length > h;)void 0 !== (r = i(n, e = u[h++])) && c(l, e, r); return l } }) }, function (t, e, r) { var n = r(0), i = r(1), o = r(116).f; n({ target: "Object", stat: !0, forced: i((function () { return !Object.getOwnPropertyNames(1) })) }, { getOwnPropertyNames: o }) }, function (t, e, r) { var n = r(0), i = r(1), o = r(11), s = r(30), a = r(97); n({ target: "Object", stat: !0, forced: i((function () { s(1) })), sham: !a }, { getPrototypeOf: function (t) { return s(o(t)) } }) }, function (t, e, r) { r(0)({ target: "Object", stat: !0 }, { is: r(134) }) }, function (t, e, r) { var n = r(0), i = r(1), o = r(3), s = Object.isExtensible; n({ target: "Object", stat: !0, forced: i((function () { s(1) })) }, { isExtensible: function (t) { return !!o(t) && (!s || s(t)) } }) }, function (t, e, r) { var n = r(0), i = r(1), o = r(3), s = Object.isFrozen; n({ target: "Object", stat: !0, forced: i((function () { s(1) })) }, { isFrozen: function (t) { return !o(t) || !!s && s(t) } }) }, function (t, e, r) { var n = r(0), i = r(1), o = r(3), s = Object.isSealed; n({ target: "Object", stat: !0, forced: i((function () { s(1) })) }, { isSealed: function (t) { return !o(t) || !!s && s(t) } }) }, function (t, e, r) { var n = r(0), i = r(11), o = r(58); n({ target: "Object", stat: !0, forced: r(1)((function () { o(1) })) }, { keys: function (t) { return o(i(t)) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(6), o = r(75), s = r(11), a = r(31), c = r(30), u = r(13).f; i && n({ target: "Object", proto: !0, forced: o }, { __lookupGetter__: function (t) { var e, r = s(this), n = a(t, !0); do { if (e = u(r, n)) return e.get } while (r = c(r)) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(6), o = r(75), s = r(11), a = r(31), c = r(30), u = r(13).f; i && n({ target: "Object", proto: !0, forced: o }, { __lookupSetter__: function (t) { var e, r = s(this), n = a(t, !0); do { if (e = u(r, n)) return e.set } while (r = c(r)) } }) }, function (t, e, r) { var n = r(0), i = r(3), o = r(44).onFreeze, s = r(64), a = r(1), c = Object.preventExtensions; n({ target: "Object", stat: !0, forced: a((function () { c(1) })), sham: !s }, { preventExtensions: function (t) { return c && i(t) ? c(o(t)) : t } }) }, function (t, e, r) { var n = r(0), i = r(3), o = r(44).onFreeze, s = r(64), a = r(1), c = Object.seal; n({ target: "Object", stat: !0, forced: a((function () { c(1) })), sham: !s }, { seal: function (t) { return c && i(t) ? c(o(t)) : t } }) }, function (t, e, r) { var n = r(94), i = r(16), o = r(259); n || i(Object.prototype, "toString", o, { unsafe: !0 }) }, function (t, e, r) { "use strict"; var n = r(94), i = r(63); t.exports = n ? {}.toString : function () { return "[object " + i(this) + "]" } }, function (t, e, r) { var n = r(0), i = r(133).values; n({ target: "Object", stat: !0 }, { values: function (t) { return i(t) } }) }, function (t, e, r) { "use strict"; var n, i, o, s, a = r(0), c = r(28), u = r(2), l = r(29), h = r(135), f = r(16), p = r(47), d = r(32), m = r(46), g = r(3), v = r(21), y = r(39), x = r(24), b = r(84), w = r(48), M = r(68), S = r(40), _ = r(100).set, T = r(137), E = r(138), A = r(262), R = r(101), L = r(139), O = r(17), P = r(56), I = r(5), C = r(90), k = I("species"), N = "Promise", z = O.get, U = O.set, j = O.getterFor(N), B = h, F = u.TypeError, D = u.document, G = u.process, V = l("fetch"), H = R.f, W = H, q = "process" == x(G), X = !!(D && D.createEvent && u.dispatchEvent), Y = P(N, (function () { if (!(b(B) !== String(B))) { if (66 === C) return !0; if (!q && "function" != typeof PromiseRejectionEvent) return !0 } if (c && !B.prototype.finally) return !0; if (C >= 51 && /native code/.test(B)) return !1; var t = B.resolve(1), e = function (t) { t((function () { }), (function () { })) }; return (t.constructor = {})[k] = e, !(t.then((function () { })) instanceof e) })), Z = Y || !M((function (t) { B.all(t).catch((function () { })) })), K = function (t) { var e; return !(!g(t) || "function" != typeof (e = t.then)) && e }, J = function (t, e, r) { if (!e.notified) { e.notified = !0; var n = e.reactions; T((function () { for (var i = e.value, o = 1 == e.state, s = 0; n.length > s;) { var a, c, u, l = n[s++], h = o ? l.ok : l.fail, f = l.resolve, p = l.reject, d = l.domain; try { h ? (o || (2 === e.rejection && et(t, e), e.rejection = 1), !0 === h ? a = i : (d && d.enter(), a = h(i), d && (d.exit(), u = !0)), a === l.promise ? p(F("Promise-chain cycle")) : (c = K(a)) ? c.call(a, f, p) : f(a)) : p(i) } catch (t) { d && !u && d.exit(), p(t) } } e.reactions = [], e.notified = !1, r && !e.rejection && $(t, e) })) } }, Q = function (t, e, r) { var n, i; X ? ((n = D.createEvent("Event")).promise = e, n.reason = r, n.initEvent(t, !1, !0), u.dispatchEvent(n)) : n = { promise: e, reason: r }, (i = u["on" + t]) ? i(n) : "unhandledrejection" === t && A("Unhandled promise rejection", r) }, $ = function (t, e) { _.call(u, (function () { var r, n = e.value; if (tt(e) && (r = L((function () { q ? G.emit("unhandledRejection", n, t) : Q("unhandledrejection", t, n) })), e.rejection = q || tt(e) ? 2 : 1, r.error)) throw r.value })) }, tt = function (t) { return 1 !== t.rejection && !t.parent }, et = function (t, e) { _.call(u, (function () { q ? G.emit("rejectionHandled", t) : Q("rejectionhandled", t, e.value) })) }, rt = function (t, e, r, n) { return function (i) { t(e, r, i, n) } }, nt = function (t, e, r, n) { e.done || (e.done = !0, n && (e = n), e.value = r, e.state = 2, J(t, e, !0)) }, it = function (t, e, r, n) { if (!e.done) { e.done = !0, n && (e = n); try { if (t === r) throw F("Promise can't be resolved itself"); var i = K(r); i ? T((function () { var n = { done: !1 }; try { i.call(r, rt(it, t, n, e), rt(nt, t, n, e)) } catch (r) { nt(t, n, r, e) } })) : (e.value = r, e.state = 1, J(t, e, !1)) } catch (r) { nt(t, { done: !1 }, r, e) } } }; Y && (B = function (t) { y(this, B, N), v(t), n.call(this); var e = z(this); try { t(rt(it, this, e), rt(nt, this, e)) } catch (t) { nt(this, e, t) } }, (n = function (t) { U(this, { type: N, done: !1, notified: !1, parent: !1, reactions: [], rejection: !1, state: 0, value: void 0 }) }).prototype = p(B.prototype, { then: function (t, e) { var r = j(this), n = H(S(this, B)); return n.ok = "function" != typeof t || t, n.fail = "function" == typeof e && e, n.domain = q ? G.domain : void 0, r.parent = !0, r.reactions.push(n), 0 != r.state && J(this, r, !1), n.promise }, catch: function (t) { return this.then(void 0, t) } }), i = function () { var t = new n, e = z(t); this.promise = t, this.resolve = rt(it, t, e), this.reject = rt(nt, t, e) }, R.f = H = function (t) { return t === B || t === o ? new i(t) : W(t) }, c || "function" != typeof h || (s = h.prototype.then, f(h.prototype, "then", (function (t, e) { var r = this; return new B((function (t, e) { s.call(r, t, e) })).then(t, e) }), { unsafe: !0 }), "function" == typeof V && a({ global: !0, enumerable: !0, forced: !0 }, { fetch: function (t) { return E(B, V.apply(u, arguments)) } }))), a({ global: !0, wrap: !0, forced: Y }, { Promise: B }), d(B, N, !1, !0), m(N), o = l(N), a({ target: N, stat: !0, forced: Y }, { reject: function (t) { var e = H(this); return e.reject.call(void 0, t), e.promise } }), a({ target: N, stat: !0, forced: c || Y }, { resolve: function (t) { return E(c && this === o ? B : this, t) } }), a({ target: N, stat: !0, forced: Z }, { all: function (t) { var e = this, r = H(e), n = r.resolve, i = r.reject, o = L((function () { var r = v(e.resolve), o = [], s = 0, a = 1; w(t, (function (t) { var c = s++, u = !1; o.push(void 0), a++, r.call(e, t).then((function (t) { u || (u = !0, o[c] = t, --a || n(o)) }), i) })), --a || n(o) })); return o.error && i(o.value), r.promise }, race: function (t) { var e = this, r = H(e), n = r.reject, i = L((function () { var i = v(e.resolve); w(t, (function (t) { i.call(e, t).then(r.resolve, n) })) })); return i.error && n(i.value), r.promise } }) }, function (t, e, r) { var n = r(2); t.exports = function (t, e) { var r = n.console; r && r.error && (1 === arguments.length ? r.error(t) : r.error(t, e)) } }, function (t, e, r) { "use strict"; var n = r(0), i = r(21), o = r(101), s = r(139), a = r(48); n({ target: "Promise", stat: !0 }, { allSettled: function (t) { var e = this, r = o.f(e), n = r.resolve, c = r.reject, u = s((function () { var r = i(e.resolve), o = [], s = 0, c = 1; a(t, (function (t) { var i = s++, a = !1; o.push(void 0), c++, r.call(e, t).then((function (t) { a || (a = !0, o[i] = { status: "fulfilled", value: t }, --c || n(o)) }), (function (t) { a || (a = !0, o[i] = { status: "rejected", reason: t }, --c || n(o)) })) })), --c || n(o) })); return u.error && c(u.value), r.promise } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(28), o = r(135), s = r(1), a = r(29), c = r(40), u = r(138), l = r(16); n({ target: "Promise", proto: !0, real: !0, forced: !!o && s((function () { o.prototype.finally.call({ then: function () { } }, (function () { })) })) }, { finally: function (t) { var e = c(this, a("Promise")), r = "function" == typeof t; return this.then(r ? function (r) { return u(e, t()).then((function () { return r })) } : t, r ? function (r) { return u(e, t()).then((function () { throw r })) } : t) } }), i || "function" != typeof o || o.prototype.finally || l(o.prototype, "finally", a("Promise").prototype.finally) }, function (t, e, r) { var n = r(0), i = r(29), o = r(21), s = r(4), a = r(1), c = i("Reflect", "apply"), u = Function.apply; n({ target: "Reflect", stat: !0, forced: !a((function () { c((function () { })) })) }, { apply: function (t, e, r) { return o(t), s(r), c ? c(t, e, r) : u.call(t, e, r) } }) }, function (t, e, r) { var n = r(0), i = r(29), o = r(21), s = r(4), a = r(3), c = r(35), u = r(267), l = r(1), h = i("Reflect", "construct"), f = l((function () { function t() { } return !(h((function () { }), [], t) instanceof t) })), p = !l((function () { h((function () { })) })), d = f || p; n({ target: "Reflect", stat: !0, forced: d, sham: d }, { construct: function (t, e) { o(t), s(e); var r = arguments.length < 3 ? t : o(arguments[2]); if (p && !f) return h(t, e, r); if (t == r) { switch (e.length) { case 0: return new t; case 1: return new t(e[0]); case 2: return new t(e[0], e[1]); case 3: return new t(e[0], e[1], e[2]); case 4: return new t(e[0], e[1], e[2], e[3]) }var n = [null]; return n.push.apply(n, e), new (u.apply(t, n)) } var i = r.prototype, l = c(a(i) ? i : Object.prototype), d = Function.apply.call(t, l, e); return a(d) ? d : l } }) }, function (t, e, r) { "use strict"; var n = r(21), i = r(3), o = [].slice, s = {}, a = function (t, e, r) { if (!(e in s)) { for (var n = [], i = 0; i < e; i++)n[i] = "a[" + i + "]"; s[e] = Function("C,a", "return new C(" + n.join(",") + ")") } return s[e](t, r) }; t.exports = Function.bind || function (t) { var e = n(this), r = o.call(arguments, 1), s = function () { var n = r.concat(o.call(arguments)); return this instanceof s ? a(e, n.length, n) : e.apply(t, n) }; return i(e.prototype) && (s.prototype = e.prototype), s } }, function (t, e, r) { var n = r(0), i = r(6), o = r(4), s = r(31), a = r(9); n({ target: "Reflect", stat: !0, forced: r(1)((function () { Reflect.defineProperty(a.f({}, 1, { value: 1 }), 1, { value: 2 }) })), sham: !i }, { defineProperty: function (t, e, r) { o(t); var n = s(e, !0); o(r); try { return a.f(t, n, r), !0 } catch (t) { return !1 } } }) }, function (t, e, r) { var n = r(0), i = r(4), o = r(13).f; n({ target: "Reflect", stat: !0 }, { deleteProperty: function (t, e) { var r = o(i(t), e); return !(r && !r.configurable) && delete t[e] } }) }, function (t, e, r) { var n = r(0), i = r(3), o = r(4), s = r(10), a = r(13), c = r(30); n({ target: "Reflect", stat: !0 }, { get: function t(e, r) { var n, u, l = arguments.length < 3 ? e : arguments[2]; return o(e) === l ? e[r] : (n = a.f(e, r)) ? s(n, "value") ? n.value : void 0 === n.get ? void 0 : n.get.call(l) : i(u = c(e)) ? t(u, r, l) : void 0 } }) }, function (t, e, r) { var n = r(0), i = r(6), o = r(4), s = r(13); n({ target: "Reflect", stat: !0, sham: !i }, { getOwnPropertyDescriptor: function (t, e) { return s.f(o(t), e) } }) }, function (t, e, r) { var n = r(0), i = r(4), o = r(30); n({ target: "Reflect", stat: !0, sham: !r(97) }, { getPrototypeOf: function (t) { return o(i(t)) } }) }, function (t, e, r) { r(0)({ target: "Reflect", stat: !0 }, { has: function (t, e) { return e in t } }) }, function (t, e, r) { var n = r(0), i = r(4), o = Object.isExtensible; n({ target: "Reflect", stat: !0 }, { isExtensible: function (t) { return i(t), !o || o(t) } }) }, function (t, e, r) { r(0)({ target: "Reflect", stat: !0 }, { ownKeys: r(86) }) }, function (t, e, r) { var n = r(0), i = r(29), o = r(4); n({ target: "Reflect", stat: !0, sham: !r(64) }, { preventExtensions: function (t) { o(t); try { var e = i("Object", "preventExtensions"); return e && e(t), !0 } catch (t) { return !1 } } }) }, function (t, e, r) { var n = r(0), i = r(4), o = r(3), s = r(10), a = r(1), c = r(9), u = r(13), l = r(30), h = r(34); n({ target: "Reflect", stat: !0, forced: a((function () { var t = c.f({}, "a", { configurable: !0 }); return !1 !== Reflect.set(l(t), "a", 1, t) })) }, { set: function t(e, r, n) { var a, f, p = arguments.length < 4 ? e : arguments[3], d = u.f(i(e), r); if (!d) { if (o(f = l(e))) return t(f, r, n, p); d = h(0) } if (s(d, "value")) { if (!1 === d.writable || !o(p)) return !1; if (a = u.f(p, r)) { if (a.get || a.set || !1 === a.writable) return !1; a.value = n, c.f(p, r, a) } else c.f(p, r, h(0, n)); return !0 } return void 0 !== d.set && (d.set.call(p, n), !0) } }) }, function (t, e, r) { var n = r(0), i = r(4), o = r(124), s = r(45); s && n({ target: "Reflect", stat: !0 }, { setPrototypeOf: function (t, e) { i(t), o(e); try { return s(t, e), !0 } catch (t) { return !1 } } }) }, function (t, e, r) { var n = r(6), i = r(2), o = r(56), s = r(72), a = r(9).f, c = r(41).f, u = r(76), l = r(65), h = r(102), f = r(16), p = r(1), d = r(17).set, m = r(46), g = r(5)("match"), v = i.RegExp, y = v.prototype, x = /a/g, b = /a/g, w = new v(x) !== x, M = h.UNSUPPORTED_Y; if (n && o("RegExp", !w || M || p((function () { return b[g] = !1, v(x) != x || v(b) == b || "/a/i" != v(x, "i") })))) { for (var S = function (t, e) { var r, n = this instanceof S, i = u(t), o = void 0 === e; if (!n && i && t.constructor === S && o) return t; w ? i && !o && (t = t.source) : t instanceof S && (o && (e = l.call(t)), t = t.source), M && (r = !!e && e.indexOf("y") > -1) && (e = e.replace(/y/g, "")); var a = s(w ? new v(t, e) : v(t, e), n ? this : y, S); return M && r && d(a, { sticky: r }), a }, _ = function (t) { t in S || a(S, t, { configurable: !0, get: function () { return v[t] }, set: function (e) { v[t] = e } }) }, T = c(v), E = 0; T.length > E;)_(T[E++]); y.constructor = S, S.prototype = y, f(i, "RegExp", S) } m("RegExp") }, function (t, e, r) { var n = r(6), i = r(9), o = r(65), s = r(102).UNSUPPORTED_Y; n && ("g" != /./g.flags || s) && i.f(RegExp.prototype, "flags", { configurable: !0, get: o }) }, function (t, e, r) { "use strict"; var n = r(16), i = r(4), o = r(1), s = r(65), a = RegExp.prototype, c = a.toString, u = o((function () { return "/a/b" != c.call({ source: "a", flags: "b" }) })), l = "toString" != c.name; (u || l) && n(RegExp.prototype, "toString", (function () { var t = i(this), e = String(t.source), r = t.flags; return "/" + e + "/" + String(void 0 === r && t instanceof RegExp && !("flags" in a) ? s.call(t) : r) }), { unsafe: !0 }) }, function (t, e, r) { "use strict"; var n = r(71), i = r(129); t.exports = n("Set", (function (t) { return function () { return t(this, arguments.length ? arguments[0] : void 0) } }), i) }, function (t, e, r) { "use strict"; var n = r(0), i = r(78).codeAt; n({ target: "String", proto: !0 }, { codePointAt: function (t) { return i(this, t) } }) }, function (t, e, r) { "use strict"; var n, i = r(0), o = r(13).f, s = r(7), a = r(103), c = r(14), u = r(104), l = r(28), h = "".endsWith, f = Math.min, p = u("endsWith"); i({ target: "String", proto: !0, forced: !!(l || p || (n = o(String.prototype, "endsWith"), !n || n.writable)) && !p }, { endsWith: function (t) { var e = String(c(this)); a(t); var r = arguments.length > 1 ? arguments[1] : void 0, n = s(e.length), i = void 0 === r ? n : f(s(r), n), o = String(t); return h ? h.call(e, o, i) : e.slice(i - o.length, i) === o } }) }, function (t, e, r) { var n = r(0), i = r(42), o = String.fromCharCode, s = String.fromCodePoint; n({ target: "String", stat: !0, forced: !!s && 1 != s.length }, { fromCodePoint: function (t) { for (var e, r = [], n = arguments.length, s = 0; n > s;) { if (e = +arguments[s++], i(e, 1114111) !== e) throw RangeError(e + " is not a valid code point"); r.push(e < 65536 ? o(e) : o(55296 + ((e -= 65536) >> 10), e % 1024 + 56320)) } return r.join("") } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(103), o = r(14); n({ target: "String", proto: !0, forced: !r(104)("includes") }, { includes: function (t) { return !!~String(o(this)).indexOf(i(t), arguments.length > 1 ? arguments[1] : void 0) } }) }, function (t, e, r) { "use strict"; var n = r(79), i = r(4), o = r(7), s = r(14), a = r(80), c = r(81); n("match", 1, (function (t, e, r) { return [function (e) { var r = s(this), n = null == e ? void 0 : e[t]; return void 0 !== n ? n.call(e, r) : new RegExp(e)[t](String(r)) }, function (t) { var n = r(e, t, this); if (n.done) return n.value; var s = i(t), u = String(this); if (!s.global) return c(s, u); var l = s.unicode; s.lastIndex = 0; for (var h, f = [], p = 0; null !== (h = c(s, u));) { var d = String(h[0]); f[p] = d, "" === d && (s.lastIndex = a(u, o(s.lastIndex), l)), p++ } return 0 === p ? null : f }] })) }, function (t, e, r) { "use strict"; var n = r(0), i = r(96), o = r(14), s = r(7), a = r(21), c = r(4), u = r(24), l = r(76), h = r(65), f = r(15), p = r(1), d = r(5), m = r(40), g = r(80), v = r(17), y = r(28), x = d("matchAll"), b = v.set, w = v.getterFor("RegExp String Iterator"), M = RegExp.prototype, S = M.exec, _ = "".matchAll, T = !!_ && !p((function () { "a".matchAll(/./) })), E = i((function (t, e, r, n) { b(this, { type: "RegExp String Iterator", regexp: t, string: e, global: r, unicode: n, done: !1 }) }), "RegExp String", (function () { var t = w(this); if (t.done) return { value: void 0, done: !0 }; var e = t.regexp, r = t.string, n = function (t, e) { var r, n = t.exec; if ("function" == typeof n) { if ("object" != typeof (r = n.call(t, e))) throw TypeError("Incorrect exec result"); return r } return S.call(t, e) }(e, r); return null === n ? { value: void 0, done: t.done = !0 } : t.global ? ("" == String(n[0]) && (e.lastIndex = g(r, s(e.lastIndex), t.unicode)), { value: n, done: !1 }) : (t.done = !0, { value: n, done: !1 }) })), A = function (t) { var e, r, n, i, o, a, u = c(this), l = String(t); return e = m(u, RegExp), void 0 === (r = u.flags) && u instanceof RegExp && !("flags" in M) && (r = h.call(u)), n = void 0 === r ? "" : String(r), i = new e(e === RegExp ? u.source : u, n), o = !!~n.indexOf("g"), a = !!~n.indexOf("u"), i.lastIndex = s(u.lastIndex), new E(i, l, o, a) }; n({ target: "String", proto: !0, forced: T }, { matchAll: function (t) { var e, r, n, i = o(this); if (null != t) { if (l(t) && !~String(o("flags" in M ? t.flags : h.call(t))).indexOf("g")) throw TypeError("`.matchAll` does not allow non-global regexes"); if (T) return _.apply(i, arguments); if (void 0 === (r = t[x]) && y && "RegExp" == u(t) && (r = A), null != r) return a(r).call(t, i) } else if (T) return _.apply(i, arguments); return e = String(i), n = new RegExp(t, "g"), y ? A.call(n, e) : n[x](e) } }), y || x in M || f(M, x, A) }, function (t, e, r) { "use strict"; var n = r(0), i = r(142).end; n({ target: "String", proto: !0, forced: r(143) }, { padEnd: function (t) { return i(this, t, arguments.length > 1 ? arguments[1] : void 0) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(142).start; n({ target: "String", proto: !0, forced: r(143) }, { padStart: function (t) { return i(this, t, arguments.length > 1 ? arguments[1] : void 0) } }) }, function (t, e, r) { var n = r(0), i = r(20), o = r(7); n({ target: "String", stat: !0 }, { raw: function (t) { for (var e = i(t.raw), r = o(e.length), n = arguments.length, s = [], a = 0; r > a;)s.push(String(e[a++])), a < n && s.push(String(arguments[a])); return s.join("") } }) }, function (t, e, r) { r(0)({ target: "String", proto: !0 }, { repeat: r(99) }) }, function (t, e, r) { "use strict"; var n = r(79), i = r(4), o = r(11), s = r(7), a = r(25), c = r(14), u = r(80), l = r(81), h = Math.max, f = Math.min, p = Math.floor, d = /\$([$&'`]|\d\d?|<[^>]*>)/g, m = /\$([$&'`]|\d\d?)/g; n("replace", 2, (function (t, e, r, n) { var g = n.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, v = n.REPLACE_KEEPS_$0, y = g ? "$" : "$0"; return [function (r, n) { var i = c(this), o = null == r ? void 0 : r[t]; return void 0 !== o ? o.call(r, i, n) : e.call(String(i), r, n) }, function (t, n) { if (!g && v || "string" == typeof n && -1 === n.indexOf(y)) { var o = r(e, t, this, n); if (o.done) return o.value } var c = i(t), p = String(this), d = "function" == typeof n; d || (n = String(n)); var m = c.global; if (m) { var b = c.unicode; c.lastIndex = 0 } for (var w = []; ;) { var M = l(c, p); if (null === M) break; if (w.push(M), !m) break; "" === String(M[0]) && (c.lastIndex = u(p, s(c.lastIndex), b)) } for (var S, _ = "", T = 0, E = 0; E < w.length; E++) { M = w[E]; for (var A = String(M[0]), R = h(f(a(M.index), p.length), 0), L = [], O = 1; O < M.length; O++)L.push(void 0 === (S = M[O]) ? S : String(S)); var P = M.groups; if (d) { var I = [A].concat(L, R, p); void 0 !== P && I.push(P); var C = String(n.apply(void 0, I)) } else C = x(A, p, R, L, P, n); R >= T && (_ += p.slice(T, R) + C, T = R + A.length) } return _ + p.slice(T) }]; function x(t, r, n, i, s, a) { var c = n + t.length, u = i.length, l = m; return void 0 !== s && (s = o(s), l = d), e.call(a, l, (function (e, o) { var a; switch (o.charAt(0)) { case "$": return "$"; case "&": return t; case "`": return r.slice(0, n); case "'": return r.slice(c); case "<": a = s[o.slice(1, -1)]; break; default: var l = +o; if (0 === l) return e; if (l > u) { var h = p(l / 10); return 0 === h ? e : h <= u ? void 0 === i[h - 1] ? o.charAt(1) : i[h - 1] + o.charAt(1) : e } a = i[l - 1] }return void 0 === a ? "" : a })) } })) }, function (t, e, r) { "use strict"; var n = r(79), i = r(4), o = r(14), s = r(134), a = r(81); n("search", 1, (function (t, e, r) { return [function (e) { var r = o(this), n = null == e ? void 0 : e[t]; return void 0 !== n ? n.call(e, r) : new RegExp(e)[t](String(r)) }, function (t) { var n = r(e, t, this); if (n.done) return n.value; var o = i(t), c = String(this), u = o.lastIndex; s(u, 0) || (o.lastIndex = 0); var l = a(o, c); return s(o.lastIndex, u) || (o.lastIndex = u), null === l ? -1 : l.index }] })) }, function (t, e, r) { "use strict"; var n = r(79), i = r(76), o = r(4), s = r(14), a = r(40), c = r(80), u = r(7), l = r(81), h = r(77), f = r(1), p = [].push, d = Math.min, m = !f((function () { return !RegExp(4294967295, "y") })); n("split", 2, (function (t, e, r) { var n; return n = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function (t, r) { var n = String(s(this)), o = void 0 === r ? 4294967295 : r >>> 0; if (0 === o) return []; if (void 0 === t) return [n]; if (!i(t)) return e.call(n, t, o); for (var a, c, u, l = [], f = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), d = 0, m = new RegExp(t.source, f + "g"); (a = h.call(m, n)) && !((c = m.lastIndex) > d && (l.push(n.slice(d, a.index)), a.length > 1 && a.index < n.length && p.apply(l, a.slice(1)), u = a[0].length, d = c, l.length >= o));)m.lastIndex === a.index && m.lastIndex++; return d === n.length ? !u && m.test("") || l.push("") : l.push(n.slice(d)), l.length > o ? l.slice(0, o) : l } : "0".split(void 0, 0).length ? function (t, r) { return void 0 === t && 0 === r ? [] : e.call(this, t, r) } : e, [function (e, r) { var i = s(this), o = null == e ? void 0 : e[t]; return void 0 !== o ? o.call(e, i, r) : n.call(String(i), e, r) }, function (t, i) { var s = r(n, t, this, i, n !== e); if (s.done) return s.value; var h = o(t), f = String(this), p = a(h, RegExp), g = h.unicode, v = (h.ignoreCase ? "i" : "") + (h.multiline ? "m" : "") + (h.unicode ? "u" : "") + (m ? "y" : "g"), y = new p(m ? h : "^(?:" + h.source + ")", v), x = void 0 === i ? 4294967295 : i >>> 0; if (0 === x) return []; if (0 === f.length) return null === l(y, f) ? [f] : []; for (var b = 0, w = 0, M = []; w < f.length;) { y.lastIndex = m ? w : 0; var S, _ = l(y, m ? f : f.slice(w)); if (null === _ || (S = d(u(y.lastIndex + (m ? 0 : w)), f.length)) === b) w = c(f, w, g); else { if (M.push(f.slice(b, w)), M.length === x) return M; for (var T = 1; T <= _.length - 1; T++)if (M.push(_[T]), M.length === x) return M; w = b = S } } return M.push(f.slice(b)), M }] }), !m) }, function (t, e, r) { "use strict"; var n, i = r(0), o = r(13).f, s = r(7), a = r(103), c = r(14), u = r(104), l = r(28), h = "".startsWith, f = Math.min, p = u("startsWith"); i({ target: "String", proto: !0, forced: !!(l || p || (n = o(String.prototype, "startsWith"), !n || n.writable)) && !p }, { startsWith: function (t) { var e = String(c(this)); a(t); var r = s(f(arguments.length > 1 ? arguments[1] : void 0, e.length)), n = String(t); return h ? h.call(e, n, r) : e.slice(r, r + n.length) === n } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(49).trim; n({ target: "String", proto: !0, forced: r(105)("trim") }, { trim: function () { return i(this) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(49).end, o = r(105)("trimEnd"), s = o ? function () { return i(this) } : "".trimEnd; n({ target: "String", proto: !0, forced: o }, { trimEnd: s, trimRight: s }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(49).start, o = r(105)("trimStart"), s = o ? function () { return i(this) } : "".trimStart; n({ target: "String", proto: !0, forced: o }, { trimStart: s, trimLeft: s }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("anchor") }, { anchor: function (t) { return i(this, "a", "name", t) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("big") }, { big: function () { return i(this, "big", "", "") } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("blink") }, { blink: function () { return i(this, "blink", "", "") } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("bold") }, { bold: function () { return i(this, "b", "", "") } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("fixed") }, { fixed: function () { return i(this, "tt", "", "") } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("fontcolor") }, { fontcolor: function (t) { return i(this, "font", "color", t) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("fontsize") }, { fontsize: function (t) { return i(this, "font", "size", t) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("italics") }, { italics: function () { return i(this, "i", "", "") } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("link") }, { link: function (t) { return i(this, "a", "href", t) } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("small") }, { small: function () { return i(this, "small", "", "") } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("strike") }, { strike: function () { return i(this, "strike", "", "") } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("sub") }, { sub: function () { return i(this, "sub", "", "") } }) }, function (t, e, r) { "use strict"; var n = r(0), i = r(22); n({ target: "String", proto: !0, forced: r(23)("sup") }, { sup: function () { return i(this, "sup", "", "") } }) }, function (t, e, r) { r(33)("Float32", (function (t) { return function (e, r, n) { return t(this, e, r, n) } })) }, function (t, e, r) { var n = r(25); t.exports = function (t) { var e = n(t); if (e < 0) throw RangeError("The argument can't be less than 0"); return e } }, function (t, e, r) { r(33)("Float64", (function (t) { return function (e, r, n) { return t(this, e, r, n) } })) }, function (t, e, r) { r(33)("Int8", (function (t) { return function (e, r, n) { return t(this, e, r, n) } })) }, function (t, e, r) { r(33)("Int16", (function (t) { return function (e, r, n) { return t(this, e, r, n) } })) }, function (t, e, r) { r(33)("Int32", (function (t) { return function (e, r, n) { return t(this, e, r, n) } })) }, function (t, e, r) { r(33)("Uint8", (function (t) { return function (e, r, n) { return t(this, e, r, n) } })) }, function (t, e, r) { r(33)("Uint8", (function (t) { return function (e, r, n) { return t(this, e, r, n) } }), !0) }, function (t, e, r) { r(33)("Uint16", (function (t) { return function (e, r, n) { return t(this, e, r, n) } })) }, function (t, e, r) { r(33)("Uint32", (function (t) { return function (e, r, n) { return t(this, e, r, n) } })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(118), o = n.aTypedArray; (0, n.exportTypedArrayMethod)("copyWithin", (function (t, e) { return i.call(o(this), t, e, arguments.length > 2 ? arguments[2] : void 0) })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(12).every, o = n.aTypedArray; (0, n.exportTypedArrayMethod)("every", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(92), o = n.aTypedArray; (0, n.exportTypedArrayMethod)("fill", (function (t) { return i.apply(o(this), arguments) })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(12).filter, o = r(40), s = n.aTypedArray, a = n.aTypedArrayConstructor; (0, n.exportTypedArrayMethod)("filter", (function (t) { for (var e = i(s(this), t, arguments.length > 1 ? arguments[1] : void 0), r = o(this, this.constructor), n = 0, c = e.length, u = new (a(r))(c); c > n;)u[n] = e[n++]; return u })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(12).find, o = n.aTypedArray; (0, n.exportTypedArrayMethod)("find", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(12).findIndex, o = n.aTypedArray; (0, n.exportTypedArrayMethod)("findIndex", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(12).forEach, o = n.aTypedArray; (0, n.exportTypedArrayMethod)("forEach", (function (t) { i(o(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, function (t, e, r) { "use strict"; var n = r(106); (0, r(8).exportTypedArrayStaticMethod)("from", r(145), n) }, function (t, e, r) { "use strict"; var n = r(8), i = r(55).includes, o = n.aTypedArray; (0, n.exportTypedArrayMethod)("includes", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(55).indexOf, o = n.aTypedArray; (0, n.exportTypedArrayMethod)("indexOf", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, function (t, e, r) { "use strict"; var n = r(2), i = r(8), o = r(69), s = r(5)("iterator"), a = n.Uint8Array, c = o.values, u = o.keys, l = o.entries, h = i.aTypedArray, f = i.exportTypedArrayMethod, p = a && a.prototype[s], d = !!p && ("values" == p.name || null == p.name), m = function () { return c.call(h(this)) }; f("entries", (function () { return l.call(h(this)) })), f("keys", (function () { return u.call(h(this)) })), f("values", m, !d), f(s, m, !d) }, function (t, e, r) { "use strict"; var n = r(8), i = n.aTypedArray, o = n.exportTypedArrayMethod, s = [].join; o("join", (function (t) { return s.apply(i(this), arguments) })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(125), o = n.aTypedArray; (0, n.exportTypedArrayMethod)("lastIndexOf", (function (t) { return i.apply(o(this), arguments) })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(12).map, o = r(40), s = n.aTypedArray, a = n.aTypedArrayConstructor; (0, n.exportTypedArrayMethod)("map", (function (t) { return i(s(this), t, arguments.length > 1 ? arguments[1] : void 0, (function (t, e) { return new (a(o(t, t.constructor)))(e) })) })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(106), o = n.aTypedArrayConstructor; (0, n.exportTypedArrayStaticMethod)("of", (function () { for (var t = 0, e = arguments.length, r = new (o(this))(e); e > t;)r[t] = arguments[t++]; return r }), i) }, function (t, e, r) { "use strict"; var n = r(8), i = r(70).left, o = n.aTypedArray; (0, n.exportTypedArrayMethod)("reduce", (function (t) { return i(o(this), t, arguments.length, arguments.length > 1 ? arguments[1] : void 0) })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(70).right, o = n.aTypedArray; (0, n.exportTypedArrayMethod)("reduceRight", (function (t) { return i(o(this), t, arguments.length, arguments.length > 1 ? arguments[1] : void 0) })) }, function (t, e, r) { "use strict"; var n = r(8), i = n.aTypedArray, o = n.exportTypedArrayMethod, s = Math.floor; o("reverse", (function () { for (var t, e = i(this).length, r = s(e / 2), n = 0; n < r;)t = this[n], this[n++] = this[--e], this[e] = t; return this })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(7), o = r(144), s = r(11), a = r(1), c = n.aTypedArray; (0, n.exportTypedArrayMethod)("set", (function (t) { c(this); var e = o(arguments.length > 1 ? arguments[1] : void 0, 1), r = this.length, n = s(t), a = i(n.length), u = 0; if (a + e > r) throw RangeError("Wrong length"); for (; u < a;)this[e + u] = n[u++] }), a((function () { new Int8Array(1).set({}) }))) }, function (t, e, r) { "use strict"; var n = r(8), i = r(40), o = r(1), s = n.aTypedArray, a = n.aTypedArrayConstructor, c = n.exportTypedArrayMethod, u = [].slice; c("slice", (function (t, e) { for (var r = u.call(s(this), t, e), n = i(this, this.constructor), o = 0, c = r.length, l = new (a(n))(c); c > o;)l[o] = r[o++]; return l }), o((function () { new Int8Array(1).slice() }))) }, function (t, e, r) { "use strict"; var n = r(8), i = r(12).some, o = n.aTypedArray; (0, n.exportTypedArrayMethod)("some", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, function (t, e, r) { "use strict"; var n = r(8), i = n.aTypedArray, o = n.exportTypedArrayMethod, s = [].sort; o("sort", (function (t) { return s.call(i(this), t) })) }, function (t, e, r) { "use strict"; var n = r(8), i = r(7), o = r(42), s = r(40), a = n.aTypedArray; (0, n.exportTypedArrayMethod)("subarray", (function (t, e) { var r = a(this), n = r.length, c = o(t, n); return new (s(r, r.constructor))(r.buffer, r.byteOffset + c * r.BYTES_PER_ELEMENT, i((void 0 === e ? n : o(e, n)) - c)) })) }, function (t, e, r) { "use strict"; var n = r(2), i = r(8), o = r(1), s = n.Int8Array, a = i.aTypedArray, c = i.exportTypedArrayMethod, u = [].toLocaleString, l = [].slice, h = !!s && o((function () { u.call(new s(1)) })); c("toLocaleString", (function () { return u.apply(h ? l.call(a(this)) : a(this), arguments) }), o((function () { return [1, 2].toLocaleString() != new s([1, 2]).toLocaleString() })) || !o((function () { s.prototype.toLocaleString.call([1, 2]) }))) }, function (t, e, r) { "use strict"; var n = r(8).exportTypedArrayMethod, i = r(1), o = r(2).Uint8Array, s = o && o.prototype || {}, a = [].toString, c = [].join; i((function () { a.call({}) })) && (a = function () { return c.call(this) }); var u = s.toString != a; n("toString", a, u) }, function (t, e, r) { "use strict"; var n, i = r(2), o = r(47), s = r(44), a = r(71), c = r(146), u = r(3), l = r(17).enforce, h = r(109), f = !i.ActiveXObject && "ActiveXObject" in i, p = Object.isExtensible, d = function (t) { return function () { return t(this, arguments.length ? arguments[0] : void 0) } }, m = t.exports = a("WeakMap", d, c); if (h && f) { n = c.getConstructor(d, "WeakMap", !0), s.REQUIRED = !0; var g = m.prototype, v = g.delete, y = g.has, x = g.get, b = g.set; o(g, { delete: function (t) { if (u(t) && !p(t)) { var e = l(this); return e.frozen || (e.frozen = new n), v.call(this, t) || e.frozen.delete(t) } return v.call(this, t) }, has: function (t) { if (u(t) && !p(t)) { var e = l(this); return e.frozen || (e.frozen = new n), y.call(this, t) || e.frozen.has(t) } return y.call(this, t) }, get: function (t) { if (u(t) && !p(t)) { var e = l(this); return e.frozen || (e.frozen = new n), y.call(this, t) ? x.call(this, t) : e.frozen.get(t) } return x.call(this, t) }, set: function (t, e) { if (u(t) && !p(t)) { var r = l(this); r.frozen || (r.frozen = new n), y.call(this, t) ? b.call(this, t, e) : r.frozen.set(t, e) } else b.call(this, t, e); return this } }) } }, function (t, e, r) { "use strict"; r(71)("WeakSet", (function (t) { return function () { return t(this, arguments.length ? arguments[0] : void 0) } }), r(146)) }, function (t, e, r) { var n = r(2), i = r(147), o = r(120), s = r(15); for (var a in i) { var c = n[a], u = c && c.prototype; if (u && u.forEach !== o) try { s(u, "forEach", o) } catch (t) { u.forEach = o } } }, function (t, e, r) { var n = r(2), i = r(147), o = r(69), s = r(15), a = r(5), c = a("iterator"), u = a("toStringTag"), l = o.values; for (var h in i) { var f = n[h], p = f && f.prototype; if (p) { if (p[c] !== l) try { s(p, c, l) } catch (t) { p[c] = l } if (p[u] || s(p, u, h), i[h]) for (var d in o) if (p[d] !== o[d]) try { s(p, d, o[d]) } catch (t) { p[d] = o[d] } } } }, function (t, e, r) { var n = r(0), i = r(2), o = r(100); n({ global: !0, bind: !0, enumerable: !0, forced: !i.setImmediate || !i.clearImmediate }, { setImmediate: o.set, clearImmediate: o.clear }) }, function (t, e, r) { var n = r(0), i = r(2), o = r(137), s = r(24), a = i.process, c = "process" == s(a); n({ global: !0, enumerable: !0, noTargetGet: !0 }, { queueMicrotask: function (t) { var e = c && a.domain; o(e ? e.bind(t) : t) } }) }, function (t, e, r) { "use strict"; r(141); var n, i = r(0), o = r(6), s = r(148), a = r(2), c = r(114), u = r(16), l = r(39), h = r(10), f = r(132), p = r(121), d = r(78).codeAt, m = r(355), g = r(32), v = r(149), y = r(17), x = a.URL, b = v.URLSearchParams, w = v.getState, M = y.set, S = y.getterFor("URL"), _ = Math.floor, T = Math.pow, E = /[A-Za-z]/, A = /[\d+-.A-Za-z]/, R = /\d/, L = /^(0x|0X)/, O = /^[0-7]+$/, P = /^\d+$/, I = /^[\dA-Fa-f]+$/, C = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/, k = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/, N = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g, z = /[\u0009\u000A\u000D]/g, U = function (t, e) { var r, n, i; if ("[" == e.charAt(0)) { if ("]" != e.charAt(e.length - 1)) return "Invalid host"; if (!(r = B(e.slice(1, -1)))) return "Invalid host"; t.host = r } else if (X(t)) { if (e = m(e), C.test(e)) return "Invalid host"; if (null === (r = j(e))) return "Invalid host"; t.host = r } else { if (k.test(e)) return "Invalid host"; for (r = "", n = p(e), i = 0; i < n.length; i++)r += W(n[i], D); t.host = r } }, j = function (t) { var e, r, n, i, o, s, a, c = t.split("."); if (c.length && "" == c[c.length - 1] && c.pop(), (e = c.length) > 4) return t; for (r = [], n = 0; n < e; n++) { if ("" == (i = c[n])) return t; if (o = 10, i.length > 1 && "0" == i.charAt(0) && (o = L.test(i) ? 16 : 8, i = i.slice(8 == o ? 1 : 2)), "" === i) s = 0; else { if (!(10 == o ? P : 8 == o ? O : I).test(i)) return t; s = parseInt(i, o) } r.push(s) } for (n = 0; n < e; n++)if (s = r[n], n == e - 1) { if (s >= T(256, 5 - e)) return null } else if (s > 255) return null; for (a = r.pop(), n = 0; n < r.length; n++)a += r[n] * T(256, 3 - n); return a }, B = function (t) { var e, r, n, i, o, s, a, c = [0, 0, 0, 0, 0, 0, 0, 0], u = 0, l = null, h = 0, f = function () { return t.charAt(h) }; if (":" == f()) { if (":" != t.charAt(1)) return; h += 2, l = ++u } for (; f();) { if (8 == u) return; if (":" != f()) { for (e = r = 0; r < 4 && I.test(f());)e = 16 * e + parseInt(f(), 16), h++, r++; if ("." == f()) { if (0 == r) return; if (h -= r, u > 6) return; for (n = 0; f();) { if (i = null, n > 0) { if (!("." == f() && n < 4)) return; h++ } if (!R.test(f())) return; for (; R.test(f());) { if (o = parseInt(f(), 10), null === i) i = o; else { if (0 == i) return; i = 10 * i + o } if (i > 255) return; h++ } c[u] = 256 * c[u] + i, 2 != ++n && 4 != n || u++ } if (4 != n) return; break } if (":" == f()) { if (h++, !f()) return } else if (f()) return; c[u++] = e } else { if (null !== l) return; h++, l = ++u } } if (null !== l) for (s = u - l, u = 7; 0 != u && s > 0;)a = c[u], c[u--] = c[l + s - 1], c[l + --s] = a; else if (8 != u) return; return c }, F = function (t) { var e, r, n, i; if ("number" == typeof t) { for (e = [], r = 0; r < 4; r++)e.unshift(t % 256), t = _(t / 256); return e.join(".") } if ("object" == typeof t) { for (e = "", n = function (t) { for (var e = null, r = 1, n = null, i = 0, o = 0; o < 8; o++)0 !== t[o] ? (i > r && (e = n, r = i), n = null, i = 0) : (null === n && (n = o), ++i); return i > r && (e = n, r = i), e }(t), r = 0; r < 8; r++)i && 0 === t[r] || (i && (i = !1), n === r ? (e += r ? ":" : "::", i = !0) : (e += t[r].toString(16), r < 7 && (e += ":"))); return "[" + e + "]" } return t }, D = {}, G = f({}, D, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), V = f({}, G, { "#": 1, "?": 1, "{": 1, "}": 1 }), H = f({}, V, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), W = function (t, e) { var r = d(t, 0); return r > 32 && r < 127 && !h(e, t) ? t : encodeURIComponent(t) }, q = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, X = function (t) { return h(q, t.scheme) }, Y = function (t) { return "" != t.username || "" != t.password }, Z = function (t) { return !t.host || t.cannotBeABaseURL || "file" == t.scheme }, K = function (t, e) { var r; return 2 == t.length && E.test(t.charAt(0)) && (":" == (r = t.charAt(1)) || !e && "|" == r) }, J = function (t) { var e; return t.length > 1 && K(t.slice(0, 2)) && (2 == t.length || "/" === (e = t.charAt(2)) || "\\" === e || "?" === e || "#" === e) }, Q = function (t) { var e = t.path, r = e.length; !r || "file" == t.scheme && 1 == r && K(e[0], !0) || e.pop() }, $ = function (t) { return "." === t || "%2e" === t.toLowerCase() }, tt = {}, et = {}, rt = {}, nt = {}, it = {}, ot = {}, st = {}, at = {}, ct = {}, ut = {}, lt = {}, ht = {}, ft = {}, pt = {}, dt = {}, mt = {}, gt = {}, vt = {}, yt = {}, xt = {}, bt = {}, wt = function (t, e, r, i) { var o, s, a, c, u, l = r || tt, f = 0, d = "", m = !1, g = !1, v = !1; for (r || (t.scheme = "", t.username = "", t.password = "", t.host = null, t.port = null, t.path = [], t.query = null, t.fragment = null, t.cannotBeABaseURL = !1, e = e.replace(N, "")), e = e.replace(z, ""), o = p(e); f <= o.length;) { switch (s = o[f], l) { case tt: if (!s || !E.test(s)) { if (r) return "Invalid scheme"; l = rt; continue } d += s.toLowerCase(), l = et; break; case et: if (s && (A.test(s) || "+" == s || "-" == s || "." == s)) d += s.toLowerCase(); else { if (":" != s) { if (r) return "Invalid scheme"; d = "", l = rt, f = 0; continue } if (r && (X(t) != h(q, d) || "file" == d && (Y(t) || null !== t.port) || "file" == t.scheme && !t.host)) return; if (t.scheme = d, r) return void (X(t) && q[t.scheme] == t.port && (t.port = null)); d = "", "file" == t.scheme ? l = pt : X(t) && i && i.scheme == t.scheme ? l = nt : X(t) ? l = at : "/" == o[f + 1] ? (l = it, f++) : (t.cannotBeABaseURL = !0, t.path.push(""), l = yt) } break; case rt: if (!i || i.cannotBeABaseURL && "#" != s) return "Invalid scheme"; if (i.cannotBeABaseURL && "#" == s) { t.scheme = i.scheme, t.path = i.path.slice(), t.query = i.query, t.fragment = "", t.cannotBeABaseURL = !0, l = bt; break } l = "file" == i.scheme ? pt : ot; continue; case nt: if ("/" != s || "/" != o[f + 1]) { l = ot; continue } l = ct, f++; break; case it: if ("/" == s) { l = ut; break } l = vt; continue; case ot: if (t.scheme = i.scheme, s == n) t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, t.path = i.path.slice(), t.query = i.query; else if ("/" == s || "\\" == s && X(t)) l = st; else if ("?" == s) t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, t.path = i.path.slice(), t.query = "", l = xt; else { if ("#" != s) { t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, t.path = i.path.slice(), t.path.pop(), l = vt; continue } t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, t.path = i.path.slice(), t.query = i.query, t.fragment = "", l = bt } break; case st: if (!X(t) || "/" != s && "\\" != s) { if ("/" != s) { t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, l = vt; continue } l = ut } else l = ct; break; case at: if (l = ct, "/" != s || "/" != d.charAt(f + 1)) continue; f++; break; case ct: if ("/" != s && "\\" != s) { l = ut; continue } break; case ut: if ("@" == s) { m && (d = "%40" + d), m = !0, a = p(d); for (var y = 0; y < a.length; y++) { var x = a[y]; if (":" != x || v) { var b = W(x, H); v ? t.password += b : t.username += b } else v = !0 } d = "" } else if (s == n || "/" == s || "?" == s || "#" == s || "\\" == s && X(t)) { if (m && "" == d) return "Invalid authority"; f -= p(d).length + 1, d = "", l = lt } else d += s; break; case lt: case ht: if (r && "file" == t.scheme) { l = mt; continue } if (":" != s || g) { if (s == n || "/" == s || "?" == s || "#" == s || "\\" == s && X(t)) { if (X(t) && "" == d) return "Invalid host"; if (r && "" == d && (Y(t) || null !== t.port)) return; if (c = U(t, d)) return c; if (d = "", l = gt, r) return; continue } "[" == s ? g = !0 : "]" == s && (g = !1), d += s } else { if ("" == d) return "Invalid host"; if (c = U(t, d)) return c; if (d = "", l = ft, r == ht) return } break; case ft: if (!R.test(s)) { if (s == n || "/" == s || "?" == s || "#" == s || "\\" == s && X(t) || r) { if ("" != d) { var w = parseInt(d, 10); if (w > 65535) return "Invalid port"; t.port = X(t) && w === q[t.scheme] ? null : w, d = "" } if (r) return; l = gt; continue } return "Invalid port" } d += s; break; case pt: if (t.scheme = "file", "/" == s || "\\" == s) l = dt; else { if (!i || "file" != i.scheme) { l = vt; continue } if (s == n) t.host = i.host, t.path = i.path.slice(), t.query = i.query; else if ("?" == s) t.host = i.host, t.path = i.path.slice(), t.query = "", l = xt; else { if ("#" != s) { J(o.slice(f).join("")) || (t.host = i.host, t.path = i.path.slice(), Q(t)), l = vt; continue } t.host = i.host, t.path = i.path.slice(), t.query = i.query, t.fragment = "", l = bt } } break; case dt: if ("/" == s || "\\" == s) { l = mt; break } i && "file" == i.scheme && !J(o.slice(f).join("")) && (K(i.path[0], !0) ? t.path.push(i.path[0]) : t.host = i.host), l = vt; continue; case mt: if (s == n || "/" == s || "\\" == s || "?" == s || "#" == s) { if (!r && K(d)) l = vt; else if ("" == d) { if (t.host = "", r) return; l = gt } else { if (c = U(t, d)) return c; if ("localhost" == t.host && (t.host = ""), r) return; d = "", l = gt } continue } d += s; break; case gt: if (X(t)) { if (l = vt, "/" != s && "\\" != s) continue } else if (r || "?" != s) if (r || "#" != s) { if (s != n && (l = vt, "/" != s)) continue } else t.fragment = "", l = bt; else t.query = "", l = xt; break; case vt: if (s == n || "/" == s || "\\" == s && X(t) || !r && ("?" == s || "#" == s)) { if (".." === (u = (u = d).toLowerCase()) || "%2e." === u || ".%2e" === u || "%2e%2e" === u ? (Q(t), "/" == s || "\\" == s && X(t) || t.path.push("")) : $(d) ? "/" == s || "\\" == s && X(t) || t.path.push("") : ("file" == t.scheme && !t.path.length && K(d) && (t.host && (t.host = ""), d = d.charAt(0) + ":"), t.path.push(d)), d = "", "file" == t.scheme && (s == n || "?" == s || "#" == s)) for (; t.path.length > 1 && "" === t.path[0];)t.path.shift(); "?" == s ? (t.query = "", l = xt) : "#" == s && (t.fragment = "", l = bt) } else d += W(s, V); break; case yt: "?" == s ? (t.query = "", l = xt) : "#" == s ? (t.fragment = "", l = bt) : s != n && (t.path[0] += W(s, D)); break; case xt: r || "#" != s ? s != n && ("'" == s && X(t) ? t.query += "%27" : t.query += "#" == s ? "%23" : W(s, D)) : (t.fragment = "", l = bt); break; case bt: s != n && (t.fragment += W(s, G)) }f++ } }, Mt = function (t) { var e, r, n = l(this, Mt, "URL"), i = arguments.length > 1 ? arguments[1] : void 0, s = String(t), a = M(n, { type: "URL" }); if (void 0 !== i) if (i instanceof Mt) e = S(i); else if (r = wt(e = {}, String(i))) throw TypeError(r); if (r = wt(a, s, null, e)) throw TypeError(r); var c = a.searchParams = new b, u = w(c); u.updateSearchParams(a.query), u.updateURL = function () { a.query = String(c) || null }, o || (n.href = _t.call(n), n.origin = Tt.call(n), n.protocol = Et.call(n), n.username = At.call(n), n.password = Rt.call(n), n.host = Lt.call(n), n.hostname = Ot.call(n), n.port = Pt.call(n), n.pathname = It.call(n), n.search = Ct.call(n), n.searchParams = kt.call(n), n.hash = Nt.call(n)) }, St = Mt.prototype, _t = function () { var t = S(this), e = t.scheme, r = t.username, n = t.password, i = t.host, o = t.port, s = t.path, a = t.query, c = t.fragment, u = e + ":"; return null !== i ? (u += "//", Y(t) && (u += r + (n ? ":" + n : "") + "@"), u += F(i), null !== o && (u += ":" + o)) : "file" == e && (u += "//"), u += t.cannotBeABaseURL ? s[0] : s.length ? "/" + s.join("/") : "", null !== a && (u += "?" + a), null !== c && (u += "#" + c), u }, Tt = function () { var t = S(this), e = t.scheme, r = t.port; if ("blob" == e) try { return new URL(e.path[0]).origin } catch (t) { return "null" } return "file" != e && X(t) ? e + "://" + F(t.host) + (null !== r ? ":" + r : "") : "null" }, Et = function () { return S(this).scheme + ":" }, At = function () { return S(this).username }, Rt = function () { return S(this).password }, Lt = function () { var t = S(this), e = t.host, r = t.port; return null === e ? "" : null === r ? F(e) : F(e) + ":" + r }, Ot = function () { var t = S(this).host; return null === t ? "" : F(t) }, Pt = function () { var t = S(this).port; return null === t ? "" : String(t) }, It = function () { var t = S(this), e = t.path; return t.cannotBeABaseURL ? e[0] : e.length ? "/" + e.join("/") : "" }, Ct = function () { var t = S(this).query; return t ? "?" + t : "" }, kt = function () { return S(this).searchParams }, Nt = function () { var t = S(this).fragment; return t ? "#" + t : "" }, zt = function (t, e) { return { get: t, set: e, configurable: !0, enumerable: !0 } }; if (o && c(St, { href: zt(_t, (function (t) { var e = S(this), r = String(t), n = wt(e, r); if (n) throw TypeError(n); w(e.searchParams).updateSearchParams(e.query) })), origin: zt(Tt), protocol: zt(Et, (function (t) { var e = S(this); wt(e, String(t) + ":", tt) })), username: zt(At, (function (t) { var e = S(this), r = p(String(t)); if (!Z(e)) { e.username = ""; for (var n = 0; n < r.length; n++)e.username += W(r[n], H) } })), password: zt(Rt, (function (t) { var e = S(this), r = p(String(t)); if (!Z(e)) { e.password = ""; for (var n = 0; n < r.length; n++)e.password += W(r[n], H) } })), host: zt(Lt, (function (t) { var e = S(this); e.cannotBeABaseURL || wt(e, String(t), lt) })), hostname: zt(Ot, (function (t) { var e = S(this); e.cannotBeABaseURL || wt(e, String(t), ht) })), port: zt(Pt, (function (t) { var e = S(this); Z(e) || ("" == (t = String(t)) ? e.port = null : wt(e, t, ft)) })), pathname: zt(It, (function (t) { var e = S(this); e.cannotBeABaseURL || (e.path = [], wt(e, t + "", gt)) })), search: zt(Ct, (function (t) { var e = S(this); "" == (t = String(t)) ? e.query = null : ("?" == t.charAt(0) && (t = t.slice(1)), e.query = "", wt(e, t, xt)), w(e.searchParams).updateSearchParams(e.query) })), searchParams: zt(kt), hash: zt(Nt, (function (t) { var e = S(this); "" != (t = String(t)) ? ("#" == t.charAt(0) && (t = t.slice(1)), e.fragment = "", wt(e, t, bt)) : e.fragment = null })) }), u(St, "toJSON", (function () { return _t.call(this) }), { enumerable: !0 }), u(St, "toString", (function () { return _t.call(this) }), { enumerable: !0 }), x) { var Ut = x.createObjectURL, jt = x.revokeObjectURL; Ut && u(Mt, "createObjectURL", (function (t) { return Ut.apply(x, arguments) })), jt && u(Mt, "revokeObjectURL", (function (t) { return jt.apply(x, arguments) })) } g(Mt, "URL"), i({ global: !0, forced: !s, sham: !o }, { URL: Mt }) }, function (t, e, r) { "use strict"; var n = /[^\0-\u007E]/, i = /[.\u3002\uFF0E\uFF61]/g, o = "Overflow: input needs wider integers to process", s = Math.floor, a = String.fromCharCode, c = function (t) { return t + 22 + 75 * (t < 26) }, u = function (t, e, r) { var n = 0; for (t = r ? s(t / 700) : t >> 1, t += s(t / e); t > 455; n += 36)t = s(t / 35); return s(n + 36 * t / (t + 38)) }, l = function (t) { var e, r, n = [], i = (t = function (t) { for (var e = [], r = 0, n = t.length; r < n;) { var i = t.charCodeAt(r++); if (i >= 55296 && i <= 56319 && r < n) { var o = t.charCodeAt(r++); 56320 == (64512 & o) ? e.push(((1023 & i) << 10) + (1023 & o) + 65536) : (e.push(i), r--) } else e.push(i) } return e }(t)).length, l = 128, h = 0, f = 72; for (e = 0; e < t.length; e++)(r = t[e]) < 128 && n.push(a(r)); var p = n.length, d = p; for (p && n.push("-"); d < i;) { var m = 2147483647; for (e = 0; e < t.length; e++)(r = t[e]) >= l && r < m && (m = r); var g = d + 1; if (m - l > s((2147483647 - h) / g)) throw RangeError(o); for (h += (m - l) * g, l = m, e = 0; e < t.length; e++) { if ((r = t[e]) < l && ++h > 2147483647) throw RangeError(o); if (r == l) { for (var v = h, y = 36; ; y += 36) { var x = y <= f ? 1 : y >= f + 26 ? 26 : y - f; if (v < x) break; var b = v - x, w = 36 - x; n.push(a(c(x + b % w))), v = s(b / w) } n.push(a(c(v))), f = u(h, g, d == p), h = 0, ++d } } ++h, ++l } return n.join("") }; t.exports = function (t) { var e, r, o = [], s = t.toLowerCase().replace(i, ".").split("."); for (e = 0; e < s.length; e++)r = s[e], o.push(n.test(r) ? "xn--" + l(r) : r); return o.join(".") } }, function (t, e, r) { var n = r(4), i = r(62); t.exports = function (t) { var e = i(t); if ("function" != typeof e) throw TypeError(String(t) + " is not iterable"); return n(e.call(t)) } }, function (t, e, r) { "use strict"; r(0)({ target: "URL", proto: !0, enumerable: !0 }, { toJSON: function () { return URL.prototype.toString.call(this) } }) }, function (t, e, r) { var n = function (t) { "use strict"; var e = Object.prototype, r = e.hasOwnProperty, n = "function" == typeof Symbol ? Symbol : {}, i = n.iterator || "@@iterator", o = n.asyncIterator || "@@asyncIterator", s = n.toStringTag || "@@toStringTag"; function a(t, e, r, n) { var i = e && e.prototype instanceof l ? e : l, o = Object.create(i.prototype), s = new M(n || []); return o._invoke = function (t, e, r) { var n = "suspendedStart"; return function (i, o) { if ("executing" === n) throw new Error("Generator is already running"); if ("completed" === n) { if ("throw" === i) throw o; return _() } for (r.method = i, r.arg = o; ;) { var s = r.delegate; if (s) { var a = x(s, r); if (a) { if (a === u) continue; return a } } if ("next" === r.method) r.sent = r._sent = r.arg; else if ("throw" === r.method) { if ("suspendedStart" === n) throw n = "completed", r.arg; r.dispatchException(r.arg) } else "return" === r.method && r.abrupt("return", r.arg); n = "executing"; var l = c(t, e, r); if ("normal" === l.type) { if (n = r.done ? "completed" : "suspendedYield", l.arg === u) continue; return { value: l.arg, done: r.done } } "throw" === l.type && (n = "completed", r.method = "throw", r.arg = l.arg) } } }(t, r, s), o } function c(t, e, r) { try { return { type: "normal", arg: t.call(e, r) } } catch (t) { return { type: "throw", arg: t } } } t.wrap = a; var u = {}; function l() { } function h() { } function f() { } var p = {}; p[i] = function () { return this }; var d = Object.getPrototypeOf, m = d && d(d(S([]))); m && m !== e && r.call(m, i) && (p = m); var g = f.prototype = l.prototype = Object.create(p); function v(t) { ["next", "throw", "return"].forEach((function (e) { t[e] = function (t) { return this._invoke(e, t) } })) } function y(t, e) { var n; this._invoke = function (i, o) { function s() { return new e((function (n, s) { !function n(i, o, s, a) { var u = c(t[i], t, o); if ("throw" !== u.type) { var l = u.arg, h = l.value; return h && "object" == typeof h && r.call(h, "__await") ? e.resolve(h.__await).then((function (t) { n("next", t, s, a) }), (function (t) { n("throw", t, s, a) })) : e.resolve(h).then((function (t) { l.value = t, s(l) }), (function (t) { return n("throw", t, s, a) })) } a(u.arg) }(i, o, n, s) })) } return n = n ? n.then(s, s) : s() } } function x(t, e) { var r = t.iterator[e.method]; if (void 0 === r) { if (e.delegate = null, "throw" === e.method) { if (t.iterator.return && (e.method = "return", e.arg = void 0, x(t, e), "throw" === e.method)) return u; e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method") } return u } var n = c(r, t.iterator, e.arg); if ("throw" === n.type) return e.method = "throw", e.arg = n.arg, e.delegate = null, u; var i = n.arg; return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = void 0), e.delegate = null, u) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, u) } function b(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e) } function w(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e } function M(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(b, this), this.reset(!0) } function S(t) { if (t) { var e = t[i]; if (e) return e.call(t); if ("function" == typeof t.next) return t; if (!isNaN(t.length)) { var n = -1, o = function e() { for (; ++n < t.length;)if (r.call(t, n)) return e.value = t[n], e.done = !1, e; return e.value = void 0, e.done = !0, e }; return o.next = o } } return { next: _ } } function _() { return { value: void 0, done: !0 } } return h.prototype = g.constructor = f, f.constructor = h, f[s] = h.displayName = "GeneratorFunction", t.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === h || "GeneratorFunction" === (e.displayName || e.name)) }, t.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, f) : (t.__proto__ = f, s in t || (t[s] = "GeneratorFunction")), t.prototype = Object.create(g), t }, t.awrap = function (t) { return { __await: t } }, v(y.prototype), y.prototype[o] = function () { return this }, t.AsyncIterator = y, t.async = function (e, r, n, i, o) { void 0 === o && (o = Promise); var s = new y(a(e, r, n, i), o); return t.isGeneratorFunction(r) ? s : s.next().then((function (t) { return t.done ? t.value : s.next() })) }, v(g), g[s] = "Generator", g[i] = function () { return this }, g.toString = function () { return "[object Generator]" }, t.keys = function (t) { var e = []; for (var r in t) e.push(r); return e.reverse(), function r() { for (; e.length;) { var n = e.pop(); if (n in t) return r.value = n, r.done = !1, r } return r.done = !0, r } }, t.values = S, M.prototype = { constructor: M, reset: function (t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(w), !t) for (var e in this) "t" === e.charAt(0) && r.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = void 0) }, stop: function () { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval }, dispatchException: function (t) { if (this.done) throw t; var e = this; function n(r, n) { return s.type = "throw", s.arg = t, e.next = r, n && (e.method = "next", e.arg = void 0), !!n } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var o = this.tryEntries[i], s = o.completion; if ("root" === o.tryLoc) return n("end"); if (o.tryLoc <= this.prev) { var a = r.call(o, "catchLoc"), c = r.call(o, "finallyLoc"); if (a && c) { if (this.prev < o.catchLoc) return n(o.catchLoc, !0); if (this.prev < o.finallyLoc) return n(o.finallyLoc) } else if (a) { if (this.prev < o.catchLoc) return n(o.catchLoc, !0) } else { if (!c) throw new Error("try statement without catch or finally"); if (this.prev < o.finallyLoc) return n(o.finallyLoc) } } } }, abrupt: function (t, e) { for (var n = this.tryEntries.length - 1; n >= 0; --n) { var i = this.tryEntries[n]; if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) { var o = i; break } } o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null); var s = o ? o.completion : {}; return s.type = t, s.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, u) : this.complete(s) }, complete: function (t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), u }, finish: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), w(r), u } }, catch: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var i = n.arg; w(r) } return i } } throw new Error("illegal catch attempt") }, delegateYield: function (t, e, r) { return this.delegate = { iterator: S(t), resultName: e, nextLoc: r }, "next" === this.method && (this.arg = void 0), u } }, t }(t.exports); try { regeneratorRuntime = n } catch (t) { Function("r", "regeneratorRuntime = r")(n) } }, function (t, e) { var r, n, i = t.exports = {}; function o() { throw new Error("setTimeout has not been defined") } function s() { throw new Error("clearTimeout has not been defined") } function a(t) { if (r === setTimeout) return setTimeout(t, 0); if ((r === o || !r) && setTimeout) return r = setTimeout, setTimeout(t, 0); try { return r(t, 0) } catch (e) { try { return r.call(null, t, 0) } catch (e) { return r.call(this, t, 0) } } } !function () { try { r = "function" == typeof setTimeout ? setTimeout : o } catch (t) { r = o } try { n = "function" == typeof clearTimeout ? clearTimeout : s } catch (t) { n = s } }(); var c, u = [], l = !1, h = -1; function f() { l && c && (l = !1, c.length ? u = c.concat(u) : h = -1, u.length && p()) } function p() { if (!l) { var t = a(f); l = !0; for (var e = u.length; e;) { for (c = u, u = []; ++h < e;)c && c[h].run(); h = -1, e = u.length } c = null, l = !1, function (t) { if (n === clearTimeout) return clearTimeout(t); if ((n === s || !n) && clearTimeout) return n = clearTimeout, clearTimeout(t); try { n(t) } catch (e) { try { return n.call(null, t) } catch (e) { return n.call(this, t) } } }(t) } } function d(t, e) { this.fun = t, this.array = e } function m() { } i.nextTick = function (t) { var e = new Array(arguments.length - 1); if (arguments.length > 1) for (var r = 1; r < arguments.length; r++)e[r - 1] = arguments[r]; u.push(new d(t, e)), 1 !== u.length || l || a(p) }, d.prototype.run = function () { this.fun.apply(null, this.array) }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = m, i.addListener = m, i.once = m, i.off = m, i.removeListener = m, i.removeAllListeners = m, i.emit = m, i.prependListener = m, i.prependOnceListener = m, i.listeners = function (t) { return [] }, i.binding = function (t) { throw new Error("process.binding is not supported") }, i.cwd = function () { return "/" }, i.chdir = function (t) { throw new Error("process.chdir is not supported") }, i.umask = function () { return 0 } }, function (t, e, r) { var n = r(361), i = r(362), o = r(363), s = r(364), a = r(365), c = r(366), u = r(367); u.alea = n, u.xor128 = i, u.xorwow = o, u.xorshift7 = s, u.xor4096 = a, u.tychei = c, t.exports = u }, function (t, e, r) { (function (t) { var n; !function (t, i, o) { function s(t) { var e, r = this, n = (e = 4022871197, function (t) { t = String(t); for (var r = 0; r < t.length; r++) { var n = .02519603282416938 * (e += t.charCodeAt(r)); n -= e = n >>> 0, e = (n *= e) >>> 0, e += 4294967296 * (n -= e) } return 2.3283064365386963e-10 * (e >>> 0) }); r.next = function () { var t = 2091639 * r.s0 + 2.3283064365386963e-10 * r.c; return r.s0 = r.s1, r.s1 = r.s2, r.s2 = t - (r.c = 0 | t) }, r.c = 1, r.s0 = n(" "), r.s1 = n(" "), r.s2 = n(" "), r.s0 -= n(t), r.s0 < 0 && (r.s0 += 1), r.s1 -= n(t), r.s1 < 0 && (r.s1 += 1), r.s2 -= n(t), r.s2 < 0 && (r.s2 += 1), n = null } function a(t, e) { return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e } function c(t, e) { var r = new s(t), n = e && e.state, i = r.next; return i.int32 = function () { return 4294967296 * r.next() | 0 }, i.double = function () { return i() + 11102230246251565e-32 * (2097152 * i() | 0) }, i.quick = i, n && ("object" == typeof n && a(n, r), i.state = function () { return a(r, {}) }), i } i && i.exports ? i.exports = c : r(26) && r(51) ? void 0 === (n = function () { return c }.call(e, r, e, i)) || (i.exports = n) : this.alea = c }(0, t, r(26)) }).call(this, r(50)(t)) }, function (t, e, r) { (function (t) { var n; !function (t, i, o) { function s(t) { var e = this, r = ""; e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function () { var t = e.x ^ e.x << 11; return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8 }, t === (0 | t) ? e.x = t : r += t; for (var n = 0; n < r.length + 64; n++)e.x ^= 0 | r.charCodeAt(n), e.next() } function a(t, e) { return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e } function c(t, e) { var r = new s(t), n = e && e.state, i = function () { return (r.next() >>> 0) / 4294967296 }; return i.double = function () { do { var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21) } while (0 === t); return t }, i.int32 = r.next, i.quick = i, n && ("object" == typeof n && a(n, r), i.state = function () { return a(r, {}) }), i } i && i.exports ? i.exports = c : r(26) && r(51) ? void 0 === (n = function () { return c }.call(e, r, e, i)) || (i.exports = n) : this.xor128 = c }(0, t, r(26)) }).call(this, r(50)(t)) }, function (t, e, r) { (function (t) { var n; !function (t, i, o) { function s(t) { var e = this, r = ""; e.next = function () { var t = e.x ^ e.x >>> 2; return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0 }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : r += t; for (var n = 0; n < r.length + 64; n++)e.x ^= 0 | r.charCodeAt(n), n == r.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next() } function a(t, e) { return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e } function c(t, e) { var r = new s(t), n = e && e.state, i = function () { return (r.next() >>> 0) / 4294967296 }; return i.double = function () { do { var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21) } while (0 === t); return t }, i.int32 = r.next, i.quick = i, n && ("object" == typeof n && a(n, r), i.state = function () { return a(r, {}) }), i } i && i.exports ? i.exports = c : r(26) && r(51) ? void 0 === (n = function () { return c }.call(e, r, e, i)) || (i.exports = n) : this.xorwow = c }(0, t, r(26)) }).call(this, r(50)(t)) }, function (t, e, r) { (function (t) { var n; !function (t, i, o) { function s(t) { var e = this; e.next = function () { var t, r, n = e.x, i = e.i; return t = n[i], r = (t ^= t >>> 7) ^ t << 24, r ^= (t = n[i + 1 & 7]) ^ t >>> 10, r ^= (t = n[i + 3 & 7]) ^ t >>> 3, r ^= (t = n[i + 4 & 7]) ^ t << 7, t = n[i + 7 & 7], r ^= (t ^= t << 13) ^ t << 9, n[i] = r, e.i = i + 1 & 7, r }, function (t, e) { var r, n = []; if (e === (0 | e)) n[0] = e; else for (e = "" + e, r = 0; r < e.length; ++r)n[7 & r] = n[7 & r] << 15 ^ e.charCodeAt(r) + n[r + 1 & 7] << 13; for (; n.length < 8;)n.push(0); for (r = 0; r < 8 && 0 === n[r]; ++r); for (8 == r ? n[7] = -1 : n[r], t.x = n, t.i = 0, r = 256; r > 0; --r)t.next() }(e, t) } function a(t, e) { return e.x = t.x.slice(), e.i = t.i, e } function c(t, e) { null == t && (t = +new Date); var r = new s(t), n = e && e.state, i = function () { return (r.next() >>> 0) / 4294967296 }; return i.double = function () { do { var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21) } while (0 === t); return t }, i.int32 = r.next, i.quick = i, n && (n.x && a(n, r), i.state = function () { return a(r, {}) }), i } i && i.exports ? i.exports = c : r(26) && r(51) ? void 0 === (n = function () { return c }.call(e, r, e, i)) || (i.exports = n) : this.xorshift7 = c }(0, t, r(26)) }).call(this, r(50)(t)) }, function (t, e, r) { (function (t) { var n; !function (t, i, o) { function s(t) { var e = this; e.next = function () { var t, r, n = e.w, i = e.X, o = e.i; return e.w = n = n + 1640531527 | 0, r = i[o + 34 & 127], t = i[o = o + 1 & 127], r ^= r << 13, t ^= t << 17, r ^= r >>> 15, t ^= t >>> 12, r = i[o] = r ^ t, e.i = o, r + (n ^ n >>> 16) | 0 }, function (t, e) { var r, n, i, o, s, a = [], c = 128; for (e === (0 | e) ? (n = e, e = null) : (e += "\0", n = 0, c = Math.max(c, e.length)), i = 0, o = -32; o < c; ++o)e && (n ^= e.charCodeAt((o + 32) % e.length)), 0 === o && (s = n), n ^= n << 10, n ^= n >>> 15, n ^= n << 4, n ^= n >>> 13, o >= 0 && (s = s + 1640531527 | 0, i = 0 == (r = a[127 & o] ^= n + s) ? i + 1 : 0); for (i >= 128 && (a[127 & (e && e.length || 0)] = -1), i = 127, o = 512; o > 0; --o)n = a[i + 34 & 127], r = a[i = i + 1 & 127], n ^= n << 13, r ^= r << 17, n ^= n >>> 15, r ^= r >>> 12, a[i] = n ^ r; t.w = s, t.X = a, t.i = i }(e, t) } function a(t, e) { return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e } function c(t, e) { null == t && (t = +new Date); var r = new s(t), n = e && e.state, i = function () { return (r.next() >>> 0) / 4294967296 }; return i.double = function () { do { var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21) } while (0 === t); return t }, i.int32 = r.next, i.quick = i, n && (n.X && a(n, r), i.state = function () { return a(r, {}) }), i } i && i.exports ? i.exports = c : r(26) && r(51) ? void 0 === (n = function () { return c }.call(e, r, e, i)) || (i.exports = n) : this.xor4096 = c }(0, t, r(26)) }).call(this, r(50)(t)) }, function (t, e, r) { (function (t) { var n; !function (t, i, o) { function s(t) { var e = this, r = ""; e.next = function () { var t = e.b, r = e.c, n = e.d, i = e.a; return t = t << 25 ^ t >>> 7 ^ r, r = r - n | 0, n = n << 24 ^ n >>> 8 ^ i, i = i - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ r, e.c = r = r - n | 0, e.d = n << 16 ^ r >>> 16 ^ i, e.a = i - t | 0 }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : r += t; for (var n = 0; n < r.length + 20; n++)e.b ^= 0 | r.charCodeAt(n), e.next() } function a(t, e) { return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e } function c(t, e) { var r = new s(t), n = e && e.state, i = function () { return (r.next() >>> 0) / 4294967296 }; return i.double = function () { do { var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21) } while (0 === t); return t }, i.int32 = r.next, i.quick = i, n && ("object" == typeof n && a(n, r), i.state = function () { return a(r, {}) }), i } i && i.exports ? i.exports = c : r(26) && r(51) ? void 0 === (n = function () { return c }.call(e, r, e, i)) || (i.exports = n) : this.tychei = c }(0, t, r(26)) }).call(this, r(50)(t)) }, function (t, e, r) { var n; !function (i, o, s) { var a, c = s.pow(256, 6), u = s.pow(2, 52), l = 2 * u; function h(t, e, r) { var n = [], h = d(function t(e, r) { var n, i = [], o = typeof e; if (r && "object" == o) for (n in e) try { i.push(t(e[n], r - 1)) } catch (t) { } return i.length ? i : "string" == o ? e : e + "\0" }((e = 1 == e ? { entropy: !0 } : e || {}).entropy ? [t, m(o)] : null == t ? function () { try { var t; return a && (t = a.randomBytes) ? t = t(256) : (t = new Uint8Array(256), (i.crypto || i.msCrypto).getRandomValues(t)), m(t) } catch (t) { var e = i.navigator, r = e && e.plugins; return [+new Date, i, r, i.screen, m(o)] } }() : t, 3), n), g = new f(n), v = function () { for (var t = g.g(6), e = c, r = 0; t < u;)t = 256 * (t + r), e *= 256, r = g.g(1); for (; t >= l;)t /= 2, e /= 2, r >>>= 1; return (t + r) / e }; return v.int32 = function () { return 0 | g.g(4) }, v.quick = function () { return g.g(4) / 4294967296 }, v.double = v, d(m(g.S), o), (e.pass || r || function (t, e, r, n) { return n && (n.S && p(n, g), t.state = function () { return p(g, {}) }), r ? (s.random = t, e) : t })(v, h, "global" in e ? e.global : this == s, e.state) } function f(t) { var e, r = t.length, n = this, i = 0, o = n.i = n.j = 0, s = n.S = []; for (r || (t = [r++]); i < 256;)s[i] = i++; for (i = 0; i < 256; i++)s[i] = s[o = 255 & o + t[i % r] + (e = s[i])], s[o] = e; (n.g = function (t) { for (var e, r = 0, i = n.i, o = n.j, s = n.S; t--;)e = s[i = 255 & i + 1], r = 256 * r + s[255 & (s[i] = s[o = 255 & o + e]) + (s[o] = e)]; return n.i = i, n.j = o, r })(256) } function p(t, e) { return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e } function d(t, e) { for (var r, n = t + "", i = 0; i < n.length;)e[255 & i] = 255 & (r ^= 19 * e[255 & i]) + n.charCodeAt(i++); return m(e) } function m(t) { return String.fromCharCode.apply(0, t) } if (d(s.random(), o), t.exports) { t.exports = h; try { a = r(368) } catch (t) { } } else void 0 === (n = function () { return h }.call(e, r, e, t)) || (t.exports = n) }("undefined" != typeof self ? self : this, [], Math) }, function (t, e) { }, function (t, e, r) { "use strict"; r.r(e); r(155), r(157), r(158), r(159), r(160), r(161), r(162), r(163), r(164), r(165), r(166), r(167), r(168), r(169), r(170), r(171), r(172), r(173), r(174), r(175), r(176), r(177), r(178), r(179), r(180), r(181), r(182), r(183), r(69), r(184), r(185), r(186), r(187), r(188), r(189), r(190), r(191), r(192), r(193), r(194), r(195), r(196), r(198), r(200), r(201), r(202), r(203), r(204), r(205), r(206), r(207), r(208), r(209), r(210), r(211), r(212), r(214), r(215), r(216), r(217), r(218), r(219), r(220), r(221), r(222), r(223), r(224), r(225), r(226), r(228), r(229), r(230), r(231), r(232), r(233), r(235), r(237), r(239), r(240), r(241), r(242), r(243), r(244), r(245), r(246), r(247), r(248), r(249), r(250), r(251), r(252), r(253), r(254), r(255), r(256), r(257), r(258), r(260), r(261), r(263), r(264), r(265), r(266), r(268), r(269), r(270), r(271), r(272), r(273), r(274), r(275), r(276), r(277), r(278), r(279), r(140), r(280), r(281), r(282), r(283), r(284), r(285), r(286), r(141), r(287), r(288), r(289), r(290), r(291), r(292), r(293), r(294), r(295), r(296), r(297), r(298), r(299), r(300), r(301), r(302), r(303), r(304), r(305), r(306), r(307), r(308), r(309), r(310), r(311), r(312), r(313), r(315), r(316), r(317), r(318), r(319), r(320), r(321), r(322), r(323), r(324), r(325), r(326), r(327), r(328), r(329), r(330), r(331), r(332), r(333), r(334), r(335), r(336), r(337), r(338), r(339), r(340), r(341), r(342), r(343), r(344), r(345), r(346), r(347), r(348), r(349), r(350), r(351), r(352), r(353), r(354), r(357), r(149), r(358); class n { constructor(t) { this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let t = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const e = ("undefined" == typeof performance ? Date : performance).now(); t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t } return t } } const i = 0, o = 1, s = 2, a = 0, c = 1, u = 2, l = 3, h = []; for (let t = 0; t < 256; t++)h[t] = (t < 16 ? "0" : "") + t.toString(16); let f = 1234567; const p = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () { const t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0; return (h[255 & t] + h[t >> 8 & 255] + h[t >> 16 & 255] + h[t >> 24 & 255] + "-" + h[255 & e] + h[e >> 8 & 255] + "-" + h[e >> 16 & 15 | 64] + h[e >> 24 & 255] + "-" + h[63 & r | 128] + h[r >> 8 & 255] + "-" + h[r >> 16 & 255] + h[r >> 24 & 255] + h[255 & n] + h[n >> 8 & 255] + h[n >> 16 & 255] + h[n >> 24 & 255]).toUpperCase() }, clamp: function (t, e, r) { return Math.max(e, Math.min(r, t)) }, euclideanModulo: function (t, e) { return (t % e + e) % e }, mapLinear: function (t, e, r, n, i) { return n + (t - e) * (i - n) / (r - e) }, lerp: function (t, e, r) { return (1 - r) * t + r * e }, smoothstep: function (t, e, r) { return t <= e ? 0 : t >= r ? 1 : (t = (t - e) / (r - e)) * t * (3 - 2 * t) }, smootherstep: function (t, e, r) { return t <= e ? 0 : t >= r ? 1 : (t = (t - e) / (r - e)) * t * t * (t * (6 * t - 15) + 10) }, randInt: function (t, e) { return t + Math.floor(Math.random() * (e - t + 1)) }, randFloat: function (t, e) { return t + Math.random() * (e - t) }, randFloatSpread: function (t) { return t * (.5 - Math.random()) }, seededRandom: function (t) { return void 0 !== t && (f = t % 2147483647), f = 16807 * f % 2147483647, (f - 1) / 2147483646 }, degToRad: function (t) { return t * p.DEG2RAD }, radToDeg: function (t) { return t * p.RAD2DEG }, isPowerOfTwo: function (t) { return 0 == (t & t - 1) && 0 !== t }, ceilPowerOfTwo: function (t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }, floorPowerOfTwo: function (t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) }, setQuaternionFromProperEuler: function (t, e, r, n, i) { const o = Math.cos, s = Math.sin, a = o(r / 2), c = s(r / 2), u = o((e + n) / 2), l = s((e + n) / 2), h = o((e - n) / 2), f = s((e - n) / 2), p = o((n - e) / 2), d = s((n - e) / 2); switch (i) { case "XYX": t.set(a * l, c * h, c * f, a * u); break; case "YZY": t.set(c * f, a * l, c * h, a * u); break; case "ZXZ": t.set(c * h, c * f, a * l, a * u); break; case "XZX": t.set(a * l, c * d, c * p, a * u); break; case "YXY": t.set(c * p, a * l, c * d, a * u); break; case "ZYZ": t.set(c * d, c * p, a * l, a * u); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i) } } }; function d() { } Object.assign(d.prototype, { addEventListener: function (t, e) { void 0 === this._listeners && (this._listeners = {}); const r = this._listeners; void 0 === r[t] && (r[t] = []), -1 === r[t].indexOf(e) && r[t].push(e) }, hasEventListener: function (t, e) { if (void 0 === this._listeners) return !1; const r = this._listeners; return void 0 !== r[t] && -1 !== r[t].indexOf(e) }, removeEventListener: function (t, e) { if (void 0 === this._listeners) return; const r = this._listeners[t]; if (void 0 !== r) { const t = r.indexOf(e); -1 !== t && r.splice(t, 1) } }, dispatchEvent: function (t) { if (void 0 === this._listeners) return; const e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; const r = e.slice(0); for (let e = 0, n = r.length; e < n; e++)r[e].call(this, t) } } }); class m { constructor(t = 0, e = 0) { Object.defineProperty(this, "isVector2", { value: !0 }), this.x = t, this.y = e } get width() { return this.x } set width(t) { this.x = t } get height() { return this.y } set height(t) { this.y = t } set(t, e) { return this.x = t, this.y = e, this } setScalar(t) { return this.x = t, this.y = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y) } copy(t) { return this.x = t.x, this.y = t.y, this } add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) } addScalar(t) { return this.x += t, this.y += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this } sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) } subScalar(t) { return this.x -= t, this.y -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this } multiply(t) { return this.x *= t.x, this.y *= t.y, this } multiplyScalar(t) { return this.x *= t, this.y *= t, this } divide(t) { return this.x /= t.x, this.y /= t.y, this } divideScalar(t) { return this.multiplyScalar(1 / t) } applyMatrix3(t) { const e = this.x, r = this.y, n = t.elements; return this.x = n[0] * e + n[3] * r + n[6], this.y = n[1] * e + n[4] * r + n[7], this } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this } clampLength(t, e) { const r = this.length(); return this.divideScalar(r || 1).multiplyScalar(Math.max(t, Math.min(e, r))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(t) { return this.x * t.x + this.y * t.y } cross(t) { return this.x * t.y - this.y * t.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) } distanceToSquared(t) { const e = this.x - t.x, r = this.y - t.y; return e * e + r * r } manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this } lerpVectors(t, e, r) { return this.x = t.x + (e.x - t.x) * r, this.y = t.y + (e.y - t.y) * r, this } equals(t) { return t.x === this.x && t.y === this.y } fromArray(t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this } toArray(t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t } fromBufferAttribute(t, e, r) { return void 0 !== r && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this } rotateAround(t, e) { const r = Math.cos(e), n = Math.sin(e), i = this.x - t.x, o = this.y - t.y; return this.x = i * r - o * n + t.x, this.y = i * n + o * r + t.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } } class g { constructor() { Object.defineProperty(this, "isMatrix3", { value: !0 }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } set(t, e, r, n, i, o, s, a, c) { const u = this.elements; return u[0] = t, u[1] = n, u[2] = s, u[3] = e, u[4] = i, u[5] = a, u[6] = r, u[7] = o, u[8] = c, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } clone() { return (new this.constructor).fromArray(this.elements) } copy(t) { const e = this.elements, r = t.elements; return e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e[4] = r[4], e[5] = r[5], e[6] = r[6], e[7] = r[7], e[8] = r[8], this } extractBasis(t, e, r) { return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this } setFromMatrix4(t) { const e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this } multiply(t) { return this.multiplyMatrices(this, t) } premultiply(t) { return this.multiplyMatrices(t, this) } multiplyMatrices(t, e) { const r = t.elements, n = e.elements, i = this.elements, o = r[0], s = r[3], a = r[6], c = r[1], u = r[4], l = r[7], h = r[2], f = r[5], p = r[8], d = n[0], m = n[3], g = n[6], v = n[1], y = n[4], x = n[7], b = n[2], w = n[5], M = n[8]; return i[0] = o * d + s * v + a * b, i[3] = o * m + s * y + a * w, i[6] = o * g + s * x + a * M, i[1] = c * d + u * v + l * b, i[4] = c * m + u * y + l * w, i[7] = c * g + u * x + l * M, i[2] = h * d + f * v + p * b, i[5] = h * m + f * y + p * w, i[8] = h * g + f * x + p * M, this } multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this } determinant() { const t = this.elements, e = t[0], r = t[1], n = t[2], i = t[3], o = t[4], s = t[5], a = t[6], c = t[7], u = t[8]; return e * o * u - e * s * c - r * i * u + r * s * a + n * i * c - n * o * a } getInverse(t, e) { void 0 !== e && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate."); const r = t.elements, n = this.elements, i = r[0], o = r[1], s = r[2], a = r[3], c = r[4], u = r[5], l = r[6], h = r[7], f = r[8], p = f * c - u * h, d = u * l - f * a, m = h * a - c * l, g = i * p + o * d + s * m; if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const v = 1 / g; return n[0] = p * v, n[1] = (s * h - f * o) * v, n[2] = (u * o - s * c) * v, n[3] = d * v, n[4] = (f * i - s * l) * v, n[5] = (s * a - u * i) * v, n[6] = m * v, n[7] = (o * l - h * i) * v, n[8] = (c * i - o * a) * v, this } transpose() { let t; const e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this } getNormalMatrix(t) { return this.setFromMatrix4(t).getInverse(this).transpose() } transposeIntoArray(t) { const e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this } setUvTransform(t, e, r, n, i, o, s) { const a = Math.cos(i), c = Math.sin(i); this.set(r * a, r * c, -r * (a * o + c * s) + o + t, -n * c, n * a, -n * (-c * o + a * s) + s + e, 0, 0, 1) } scale(t, e) { const r = this.elements; return r[0] *= t, r[3] *= t, r[6] *= t, r[1] *= e, r[4] *= e, r[7] *= e, this } rotate(t) { const e = Math.cos(t), r = Math.sin(t), n = this.elements, i = n[0], o = n[3], s = n[6], a = n[1], c = n[4], u = n[7]; return n[0] = e * i + r * a, n[3] = e * o + r * c, n[6] = e * s + r * u, n[1] = -r * i + e * a, n[4] = -r * o + e * c, n[7] = -r * s + e * u, this } translate(t, e) { const r = this.elements; return r[0] += t * r[2], r[3] += t * r[5], r[6] += t * r[8], r[1] += e * r[2], r[4] += e * r[5], r[7] += e * r[8], this } equals(t) { const e = this.elements, r = t.elements; for (let t = 0; t < 9; t++)if (e[t] !== r[t]) return !1; return !0 } fromArray(t, e) { void 0 === e && (e = 0); for (let r = 0; r < 9; r++)this.elements[r] = t[r + e]; return this } toArray(t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); const r = this.elements; return t[e] = r[0], t[e + 1] = r[1], t[e + 2] = r[2], t[e + 3] = r[3], t[e + 4] = r[4], t[e + 5] = r[5], t[e + 6] = r[6], t[e + 7] = r[7], t[e + 8] = r[8], t } } let v; const y = function (t) { if (/^data:/i.test(t.src)) return t.src; if ("undefined" == typeof HTMLCanvasElement) return t.src; let e; if (t instanceof HTMLCanvasElement) e = t; else { void 0 === v && (v = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), v.width = t.width, v.height = t.height; const r = v.getContext("2d"); t instanceof ImageData ? r.putImageData(t, 0, 0) : r.drawImage(t, 0, 0, t.width, t.height), e = v } return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png") }; let x = 0; function b(t, e, r, n, i, o, s, a, c, u) { Object.defineProperty(this, "id", { value: x++ }), this.uuid = p.generateUUID(), this.name = "", this.image = void 0 !== t ? t : b.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : b.DEFAULT_MAPPING, this.wrapS = void 0 !== r ? r : 1001, this.wrapT = void 0 !== n ? n : 1001, this.magFilter = void 0 !== i ? i : 1006, this.minFilter = void 0 !== o ? o : 1008, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== s ? s : 1023, this.internalFormat = null, this.type = void 0 !== a ? a : 1009, this.offset = new m(0, 0), this.repeat = new m(1, 1), this.center = new m(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new g, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== u ? u : 3e3, this.version = 0, this.onUpdate = null } function w(t, e, r, n, i, o, s, a, c, u, l, h) { b.call(this, null, o, s, a, c, u, n, i, l, h), this.image = { data: t || null, width: e || 1, height: r || 1 }, this.magFilter = void 0 !== c ? c : 1003, this.minFilter = void 0 !== u ? u : 1003, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } b.DEFAULT_IMAGE = void 0, b.DEFAULT_MAPPING = 300, b.prototype = Object.assign(Object.create(d.prototype), { constructor: b, isTexture: !0, updateMatrix: function () { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this }, toJSON: function (t) { const e = void 0 === t || "string" == typeof t; if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]; const r = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { const n = this.image; if (void 0 === n.uuid && (n.uuid = p.generateUUID()), !e && void 0 === t.images[n.uuid]) { let e; if (Array.isArray(n)) { e = []; for (let t = 0, r = n.length; t < r; t++)e.push(y(n[t])) } else e = y(n); t.images[n.uuid] = { uuid: n.uuid, url: e } } r.image = n.uuid } return e || (t.textures[this.uuid] = r), r }, dispose: function () { this.dispatchEvent({ type: "dispose" }) }, transformUv: function (t) { if (300 !== this.mapping) return t; if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) { case 1e3: t.x = t.x - Math.floor(t.x); break; case 1001: t.x = t.x < 0 ? 0 : 1; break; case 1002: 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x) }if (t.y < 0 || t.y > 1) switch (this.wrapT) { case 1e3: t.y = t.y - Math.floor(t.y); break; case 1001: t.y = t.y < 0 ? 0 : 1; break; case 1002: 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y) }return this.flipY && (t.y = 1 - t.y), t } }), Object.defineProperty(b.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), w.prototype = Object.create(b.prototype), w.prototype.constructor = w, w.prototype.isDataTexture = !0; class M { constructor(t = 0, e = 0, r = 0, n = 1) { Object.defineProperty(this, "isQuaternion", { value: !0 }), this._x = t, this._y = e, this._z = r, this._w = n } static slerp(t, e, r, n) { return r.copy(t).slerp(e, n) } static slerpFlat(t, e, r, n, i, o, s) { let a = r[n + 0], c = r[n + 1], u = r[n + 2], l = r[n + 3]; const h = i[o + 0], f = i[o + 1], p = i[o + 2], d = i[o + 3]; if (l !== d || a !== h || c !== f || u !== p) { let t = 1 - s; const e = a * h + c * f + u * p + l * d, r = e >= 0 ? 1 : -1, n = 1 - e * e; if (n > Number.EPSILON) { const i = Math.sqrt(n), o = Math.atan2(i, e * r); t = Math.sin(t * o) / i, s = Math.sin(s * o) / i } const i = s * r; if (a = a * t + h * i, c = c * t + f * i, u = u * t + p * i, l = l * t + d * i, t === 1 - s) { const t = 1 / Math.sqrt(a * a + c * c + u * u + l * l); a *= t, c *= t, u *= t, l *= t } } t[e] = a, t[e + 1] = c, t[e + 2] = u, t[e + 3] = l } static multiplyQuaternionsFlat(t, e, r, n, i, o) { const s = r[n], a = r[n + 1], c = r[n + 2], u = r[n + 3], l = i[o], h = i[o + 1], f = i[o + 2], p = i[o + 3]; return t[e] = s * p + u * l + a * f - c * h, t[e + 1] = a * p + u * h + c * l - s * f, t[e + 2] = c * p + u * f + s * h - a * l, t[e + 3] = u * p - s * l - a * h - c * f, t } get x() { return this._x } set x(t) { this._x = t, this._onChangeCallback() } get y() { return this._y } set y(t) { this._y = t, this._onChangeCallback() } get z() { return this._z } set z(t) { this._z = t, this._onChangeCallback() } get w() { return this._w } set w(t) { this._w = t, this._onChangeCallback() } set(t, e, r, n) { return this._x = t, this._y = e, this._z = r, this._w = n, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this } setFromEuler(t, e) { if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); const r = t._x, n = t._y, i = t._z, o = t._order, s = Math.cos, a = Math.sin, c = s(r / 2), u = s(n / 2), l = s(i / 2), h = a(r / 2), f = a(n / 2), p = a(i / 2); switch (o) { case "XYZ": this._x = h * u * l + c * f * p, this._y = c * f * l - h * u * p, this._z = c * u * p + h * f * l, this._w = c * u * l - h * f * p; break; case "YXZ": this._x = h * u * l + c * f * p, this._y = c * f * l - h * u * p, this._z = c * u * p - h * f * l, this._w = c * u * l + h * f * p; break; case "ZXY": this._x = h * u * l - c * f * p, this._y = c * f * l + h * u * p, this._z = c * u * p + h * f * l, this._w = c * u * l - h * f * p; break; case "ZYX": this._x = h * u * l - c * f * p, this._y = c * f * l + h * u * p, this._z = c * u * p - h * f * l, this._w = c * u * l + h * f * p; break; case "YZX": this._x = h * u * l + c * f * p, this._y = c * f * l + h * u * p, this._z = c * u * p - h * f * l, this._w = c * u * l - h * f * p; break; case "XZY": this._x = h * u * l - c * f * p, this._y = c * f * l - h * u * p, this._z = c * u * p + h * f * l, this._w = c * u * l + h * f * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o) }return !1 !== e && this._onChangeCallback(), this } setFromAxisAngle(t, e) { const r = e / 2, n = Math.sin(r); return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(r), this._onChangeCallback(), this } setFromRotationMatrix(t) { const e = t.elements, r = e[0], n = e[4], i = e[8], o = e[1], s = e[5], a = e[9], c = e[2], u = e[6], l = e[10], h = r + s + l; if (h > 0) { const t = .5 / Math.sqrt(h + 1); this._w = .25 / t, this._x = (u - a) * t, this._y = (i - c) * t, this._z = (o - n) * t } else if (r > s && r > l) { const t = 2 * Math.sqrt(1 + r - s - l); this._w = (u - a) / t, this._x = .25 * t, this._y = (n + o) / t, this._z = (i + c) / t } else if (s > l) { const t = 2 * Math.sqrt(1 + s - r - l); this._w = (i - c) / t, this._x = (n + o) / t, this._y = .25 * t, this._z = (a + u) / t } else { const t = 2 * Math.sqrt(1 + l - r - s); this._w = (o - n) / t, this._x = (i + c) / t, this._y = (a + u) / t, this._z = .25 * t } return this._onChangeCallback(), this } setFromUnitVectors(t, e) { let r = t.dot(e) + 1; return r < 1e-6 ? (r = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = r)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = r), this.normalize() } angleTo(t) { return 2 * Math.acos(Math.abs(p.clamp(this.dot(t), -1, 1))) } rotateTowards(t, e) { const r = this.angleTo(t); if (0 === r) return this; const n = Math.min(1, e / r); return this.slerp(t, n), this } identity() { return this.set(0, 0, 0, 1) } inverse() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this } multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) } premultiply(t) { return this.multiplyQuaternions(t, this) } multiplyQuaternions(t, e) { const r = t._x, n = t._y, i = t._z, o = t._w, s = e._x, a = e._y, c = e._z, u = e._w; return this._x = r * u + o * s + n * c - i * a, this._y = n * u + o * a + i * s - r * c, this._z = i * u + o * c + r * a - n * s, this._w = o * u - r * s - n * a - i * c, this._onChangeCallback(), this } slerp(t, e) { if (0 === e) return this; if (1 === e) return this.copy(t); const r = this._x, n = this._y, i = this._z, o = this._w; let s = o * t._w + r * t._x + n * t._y + i * t._z; if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = o, this._x = r, this._y = n, this._z = i, this; const a = 1 - s * s; if (a <= Number.EPSILON) { const t = 1 - e; return this._w = t * o + e * this._w, this._x = t * r + e * this._x, this._y = t * n + e * this._y, this._z = t * i + e * this._z, this.normalize(), this._onChangeCallback(), this } const c = Math.sqrt(a), u = Math.atan2(c, s), l = Math.sin((1 - e) * u) / c, h = Math.sin(e * u) / c; return this._w = o * l + this._w * h, this._x = r * l + this._x * h, this._y = n * l + this._y * h, this._z = i * l + this._z * h, this._onChangeCallback(), this } equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w } fromArray(t, e) { return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this } toArray(t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t } fromBufferAttribute(t, e) { return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this } _onChange(t) { return this._onChangeCallback = t, this } _onChangeCallback() { } } class S { constructor(t = 0, e = 0, r = 0) { Object.defineProperty(this, "isVector3", { value: !0 }), this.x = t, this.y = e, this.z = r } set(t, e, r) { return void 0 === r && (r = this.z), this.x = t, this.y = e, this.z = r, this } setScalar(t) { return this.x = t, this.y = t, this.z = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setZ(t) { return this.z = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this } add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) } addScalar(t) { return this.x += t, this.y += t, this.z += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this } sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) } subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this } multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) } multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this } multiplyVectors(t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this } applyEuler(t) { return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(T.setFromEuler(t)) } applyAxisAngle(t, e) { return this.applyQuaternion(T.setFromAxisAngle(t, e)) } applyMatrix3(t) { const e = this.x, r = this.y, n = this.z, i = t.elements; return this.x = i[0] * e + i[3] * r + i[6] * n, this.y = i[1] * e + i[4] * r + i[7] * n, this.z = i[2] * e + i[5] * r + i[8] * n, this } applyNormalMatrix(t) { return this.applyMatrix3(t).normalize() } applyMatrix4(t) { const e = this.x, r = this.y, n = this.z, i = t.elements, o = 1 / (i[3] * e + i[7] * r + i[11] * n + i[15]); return this.x = (i[0] * e + i[4] * r + i[8] * n + i[12]) * o, this.y = (i[1] * e + i[5] * r + i[9] * n + i[13]) * o, this.z = (i[2] * e + i[6] * r + i[10] * n + i[14]) * o, this } applyQuaternion(t) { const e = this.x, r = this.y, n = this.z, i = t.x, o = t.y, s = t.z, a = t.w, c = a * e + o * n - s * r, u = a * r + s * e - i * n, l = a * n + i * r - o * e, h = -i * e - o * r - s * n; return this.x = c * a + h * -i + u * -s - l * -o, this.y = u * a + h * -o + l * -i - c * -s, this.z = l * a + h * -s + c * -o - u * -i, this } project(t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) } unproject(t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) } transformDirection(t) { const e = this.x, r = this.y, n = this.z, i = t.elements; return this.x = i[0] * e + i[4] * r + i[8] * n, this.y = i[1] * e + i[5] * r + i[9] * n, this.z = i[2] * e + i[6] * r + i[10] * n, this.normalize() } divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this } divideScalar(t) { return this.multiplyScalar(1 / t) } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this } clampLength(t, e) { const r = this.length(); return this.divideScalar(r || 1).multiplyScalar(Math.max(t, Math.min(e, r))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this } lerpVectors(t, e, r) { return this.x = t.x + (e.x - t.x) * r, this.y = t.y + (e.y - t.y) * r, this.z = t.z + (e.z - t.z) * r, this } cross(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t) } crossVectors(t, e) { const r = t.x, n = t.y, i = t.z, o = e.x, s = e.y, a = e.z; return this.x = n * a - i * s, this.y = i * o - r * a, this.z = r * s - n * o, this } projectOnVector(t) { const e = t.lengthSq(); if (0 === e) return this.set(0, 0, 0); const r = t.dot(this) / e; return this.copy(t).multiplyScalar(r) } projectOnPlane(t) { return _.copy(this).projectOnVector(t), this.sub(_) } reflect(t) { return this.sub(_.copy(t).multiplyScalar(2 * this.dot(t))) } angleTo(t) { const e = Math.sqrt(this.lengthSq() * t.lengthSq()); if (0 === e) return Math.PI / 2; const r = this.dot(t) / e; return Math.acos(p.clamp(r, -1, 1)) } distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) } distanceToSquared(t) { const e = this.x - t.x, r = this.y - t.y, n = this.z - t.z; return e * e + r * r + n * n } manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) } setFromSpherical(t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) } setFromSphericalCoords(t, e, r) { const n = Math.sin(e) * t; return this.x = n * Math.sin(r), this.y = Math.cos(e) * t, this.z = n * Math.cos(r), this } setFromCylindrical(t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) } setFromCylindricalCoords(t, e, r) { return this.x = t * Math.sin(e), this.y = r, this.z = t * Math.cos(e), this } setFromMatrixPosition(t) { const e = t.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this } setFromMatrixScale(t) { const e = this.setFromMatrixColumn(t, 0).length(), r = this.setFromMatrixColumn(t, 1).length(), n = this.setFromMatrixColumn(t, 2).length(); return this.x = e, this.y = r, this.z = n, this } setFromMatrixColumn(t, e) { return this.fromArray(t.elements, 4 * e) } setFromMatrix3Column(t, e) { return this.fromArray(t.elements, 3 * e) } equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z } fromArray(t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this } toArray(t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t } fromBufferAttribute(t, e, r) { return void 0 !== r && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } } const _ = new S, T = new M; class E { constructor(t, e) { Object.defineProperty(this, "isBox3", { value: !0 }), this.min = void 0 !== t ? t : new S(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new S(-1 / 0, -1 / 0, -1 / 0) } set(t, e) { return this.min.copy(t), this.max.copy(e), this } setFromArray(t) { let e = 1 / 0, r = 1 / 0, n = 1 / 0, i = -1 / 0, o = -1 / 0, s = -1 / 0; for (let a = 0, c = t.length; a < c; a += 3) { const c = t[a], u = t[a + 1], l = t[a + 2]; c < e && (e = c), u < r && (r = u), l < n && (n = l), c > i && (i = c), u > o && (o = u), l > s && (s = l) } return this.min.set(e, r, n), this.max.set(i, o, s), this } setFromBufferAttribute(t) { let e = 1 / 0, r = 1 / 0, n = 1 / 0, i = -1 / 0, o = -1 / 0, s = -1 / 0; for (let a = 0, c = t.count; a < c; a++) { const c = t.getX(a), u = t.getY(a), l = t.getZ(a); c < e && (e = c), u < r && (r = u), l < n && (n = l), c > i && (i = c), u > o && (o = u), l > s && (s = l) } return this.min.set(e, r, n), this.max.set(i, o, s), this } setFromPoints(t) { this.makeEmpty(); for (let e = 0, r = t.length; e < r; e++)this.expandByPoint(t[e]); return this } setFromCenterAndSize(t, e) { const r = L.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(r), this.max.copy(t).add(r), this } setFromObject(t) { return this.makeEmpty(), this.expandByObject(t) } clone() { return (new this.constructor).copy(this) } copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(t) { return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new S), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(t) { return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new S), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) } expandByPoint(t) { return this.min.min(t), this.max.max(t), this } expandByVector(t) { return this.min.sub(t), this.max.add(t), this } expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this } expandByObject(t) { t.updateWorldMatrix(!1, !1); const e = t.geometry; void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), O.copy(e.boundingBox), O.applyMatrix4(t.matrixWorld), this.union(O)); const r = t.children; for (let t = 0, e = r.length; t < e; t++)this.expandByObject(r[t]); return this } containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) } containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z } getParameter(t, e) { return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new S), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) } intersectsSphere(t) { return this.clampPoint(t.center, L), L.distanceToSquared(t.center) <= t.radius * t.radius } intersectsPlane(t) { let e, r; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, r = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, r = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, r += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, r += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, r += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, r += t.normal.z * this.min.z), e <= -t.constant && r >= -t.constant } intersectsTriangle(t) { if (this.isEmpty()) return !1; this.getCenter(U), j.subVectors(this.max, U), P.subVectors(t.a, U), I.subVectors(t.b, U), C.subVectors(t.c, U), k.subVectors(I, P), N.subVectors(C, I), z.subVectors(P, C); let e = [0, -k.z, k.y, 0, -N.z, N.y, 0, -z.z, z.y, k.z, 0, -k.x, N.z, 0, -N.x, z.z, 0, -z.x, -k.y, k.x, 0, -N.y, N.x, 0, -z.y, z.x, 0]; return !!A(e, P, I, C, j) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!A(e, P, I, C, j) && (B.crossVectors(k, N), e = [B.x, B.y, B.z], A(e, P, I, C, j))) } clampPoint(t, e) { return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new S), e.copy(t).clamp(this.min, this.max) } distanceToPoint(t) { return L.copy(t).clamp(this.min, this.max).sub(t).length() } getBoundingSphere(t) { return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(L).length(), t } intersect(t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this } union(t) { return this.min.min(t.min), this.max.max(t.max), this } applyMatrix4(t) { return this.isEmpty() || (R[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), R[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), R[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), R[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), R[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), R[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), R[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), R[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(R)), this } translate(t) { return this.min.add(t), this.max.add(t), this } equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) } } function A(t, e, r, n, i) { for (let o = 0, s = t.length - 3; o <= s; o += 3) { F.fromArray(t, o); const s = i.x * Math.abs(F.x) + i.y * Math.abs(F.y) + i.z * Math.abs(F.z), a = e.dot(F), c = r.dot(F), u = n.dot(F); if (Math.max(-Math.max(a, c, u), Math.min(a, c, u)) > s) return !1 } return !0 } const R = [new S, new S, new S, new S, new S, new S, new S, new S], L = new S, O = new E, P = new S, I = new S, C = new S, k = new S, N = new S, z = new S, U = new S, j = new S, B = new S, F = new S, D = new E; class G { constructor(t, e) { this.center = void 0 !== t ? t : new S, this.radius = void 0 !== e ? e : -1 } set(t, e) { return this.center.copy(t), this.radius = e, this } setFromPoints(t, e) { const r = this.center; void 0 !== e ? r.copy(e) : D.setFromPoints(t).getCenter(r); let n = 0; for (let e = 0, i = t.length; e < i; e++)n = Math.max(n, r.distanceToSquared(t[e])); return this.radius = Math.sqrt(n), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.center.copy(t.center), this.radius = t.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(t) { return t.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(t) { return t.distanceTo(this.center) - this.radius } intersectsSphere(t) { const e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e } intersectsBox(t) { return t.intersectsSphere(this) } intersectsPlane(t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius } clampPoint(t, e) { const r = this.center.distanceToSquared(t); return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new S), e.copy(t), r > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e } getBoundingBox(t) { return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new E), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t) } applyMatrix4(t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this } translate(t) { return this.center.add(t), this } equals(t) { return t.center.equals(this.center) && t.radius === this.radius } } const V = new S, H = new S, W = new g; class q { constructor(t, e) { Object.defineProperty(this, "isPlane", { value: !0 }), this.normal = void 0 !== t ? t : new S(1, 0, 0), this.constant = void 0 !== e ? e : 0 } set(t, e) { return this.normal.copy(t), this.constant = e, this } setComponents(t, e, r, n) { return this.normal.set(t, e, r), this.constant = n, this } setFromNormalAndCoplanarPoint(t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this } setFromCoplanarPoints(t, e, r) { const n = V.subVectors(r, e).cross(H.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(n, t), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.normal.copy(t.normal), this.constant = t.constant, this } normalize() { const t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(t) { return this.normal.dot(t) + this.constant } distanceToSphere(t) { return this.distanceToPoint(t.center) - t.radius } projectPoint(t, e) { return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new S), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) } intersectLine(t, e) { void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new S); const r = t.delta(V), n = this.normal.dot(r); if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0; const i = -(t.start.dot(this.normal) + this.constant) / n; return i < 0 || i > 1 ? void 0 : e.copy(r).multiplyScalar(i).add(t.start) } intersectsLine(t) { const e = this.distanceToPoint(t.start), r = this.distanceToPoint(t.end); return e < 0 && r > 0 || r < 0 && e > 0 } intersectsBox(t) { return t.intersectsPlane(this) } intersectsSphere(t) { return t.intersectsPlane(this) } coplanarPoint(t) { return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new S), t.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(t, e) { const r = e || W.getNormalMatrix(t), n = this.coplanarPoint(V).applyMatrix4(t), i = this.normal.applyMatrix3(r).normalize(); return this.constant = -n.dot(i), this } translate(t) { return this.constant -= t.dot(this.normal), this } equals(t) { return t.normal.equals(this.normal) && t.constant === this.constant } } const X = new G, Y = new S; class Z { constructor(t, e, r, n, i, o) { this.planes = [void 0 !== t ? t : new q, void 0 !== e ? e : new q, void 0 !== r ? r : new q, void 0 !== n ? n : new q, void 0 !== i ? i : new q, void 0 !== o ? o : new q] } set(t, e, r, n, i, o) { const s = this.planes; return s[0].copy(t), s[1].copy(e), s[2].copy(r), s[3].copy(n), s[4].copy(i), s[5].copy(o), this } clone() { return (new this.constructor).copy(this) } copy(t) { const e = this.planes; for (let r = 0; r < 6; r++)e[r].copy(t.planes[r]); return this } setFromProjectionMatrix(t) { const e = this.planes, r = t.elements, n = r[0], i = r[1], o = r[2], s = r[3], a = r[4], c = r[5], u = r[6], l = r[7], h = r[8], f = r[9], p = r[10], d = r[11], m = r[12], g = r[13], v = r[14], y = r[15]; return e[0].setComponents(s - n, l - a, d - h, y - m).normalize(), e[1].setComponents(s + n, l + a, d + h, y + m).normalize(), e[2].setComponents(s + i, l + c, d + f, y + g).normalize(), e[3].setComponents(s - i, l - c, d - f, y - g).normalize(), e[4].setComponents(s - o, l - u, d - p, y - v).normalize(), e[5].setComponents(s + o, l + u, d + p, y + v).normalize(), this } intersectsObject(t) { const e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), X.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(X) } intersectsSprite(t) { return X.center.set(0, 0, 0), X.radius = .7071067811865476, X.applyMatrix4(t.matrixWorld), this.intersectsSphere(X) } intersectsSphere(t) { const e = this.planes, r = t.center, n = -t.radius; for (let t = 0; t < 6; t++) { if (e[t].distanceToPoint(r) < n) return !1 } return !0 } intersectsBox(t) { const e = this.planes; for (let r = 0; r < 6; r++) { const n = e[r]; if (Y.x = n.normal.x > 0 ? t.max.x : t.min.x, Y.y = n.normal.y > 0 ? t.max.y : t.min.y, Y.z = n.normal.z > 0 ? t.max.z : t.min.z, n.distanceToPoint(Y) < 0) return !1 } return !0 } containsPoint(t) { const e = this.planes; for (let r = 0; r < 6; r++)if (e[r].distanceToPoint(t) < 0) return !1; return !0 } } class K { constructor() { Object.defineProperty(this, "isMatrix4", { value: !0 }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } set(t, e, r, n, i, o, s, a, c, u, l, h, f, p, d, m) { const g = this.elements; return g[0] = t, g[4] = e, g[8] = r, g[12] = n, g[1] = i, g[5] = o, g[9] = s, g[13] = a, g[2] = c, g[6] = u, g[10] = l, g[14] = h, g[3] = f, g[7] = p, g[11] = d, g[15] = m, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new K).fromArray(this.elements) } copy(t) { const e = this.elements, r = t.elements; return e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e[4] = r[4], e[5] = r[5], e[6] = r[6], e[7] = r[7], e[8] = r[8], e[9] = r[9], e[10] = r[10], e[11] = r[11], e[12] = r[12], e[13] = r[13], e[14] = r[14], e[15] = r[15], this } copyPosition(t) { const e = this.elements, r = t.elements; return e[12] = r[12], e[13] = r[13], e[14] = r[14], this } extractBasis(t, e, r) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this } makeBasis(t, e, r) { return this.set(t.x, e.x, r.x, 0, t.y, e.y, r.y, 0, t.z, e.z, r.z, 0, 0, 0, 0, 1), this } extractRotation(t) { const e = this.elements, r = t.elements, n = 1 / J.setFromMatrixColumn(t, 0).length(), i = 1 / J.setFromMatrixColumn(t, 1).length(), o = 1 / J.setFromMatrixColumn(t, 2).length(); return e[0] = r[0] * n, e[1] = r[1] * n, e[2] = r[2] * n, e[3] = 0, e[4] = r[4] * i, e[5] = r[5] * i, e[6] = r[6] * i, e[7] = 0, e[8] = r[8] * o, e[9] = r[9] * o, e[10] = r[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this } makeRotationFromEuler(t) { t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); const e = this.elements, r = t.x, n = t.y, i = t.z, o = Math.cos(r), s = Math.sin(r), a = Math.cos(n), c = Math.sin(n), u = Math.cos(i), l = Math.sin(i); if ("XYZ" === t.order) { const t = o * u, r = o * l, n = s * u, i = s * l; e[0] = a * u, e[4] = -a * l, e[8] = c, e[1] = r + n * c, e[5] = t - i * c, e[9] = -s * a, e[2] = i - t * c, e[6] = n + r * c, e[10] = o * a } else if ("YXZ" === t.order) { const t = a * u, r = a * l, n = c * u, i = c * l; e[0] = t + i * s, e[4] = n * s - r, e[8] = o * c, e[1] = o * l, e[5] = o * u, e[9] = -s, e[2] = r * s - n, e[6] = i + t * s, e[10] = o * a } else if ("ZXY" === t.order) { const t = a * u, r = a * l, n = c * u, i = c * l; e[0] = t - i * s, e[4] = -o * l, e[8] = n + r * s, e[1] = r + n * s, e[5] = o * u, e[9] = i - t * s, e[2] = -o * c, e[6] = s, e[10] = o * a } else if ("ZYX" === t.order) { const t = o * u, r = o * l, n = s * u, i = s * l; e[0] = a * u, e[4] = n * c - r, e[8] = t * c + i, e[1] = a * l, e[5] = i * c + t, e[9] = r * c - n, e[2] = -c, e[6] = s * a, e[10] = o * a } else if ("YZX" === t.order) { const t = o * a, r = o * c, n = s * a, i = s * c; e[0] = a * u, e[4] = i - t * l, e[8] = n * l + r, e[1] = l, e[5] = o * u, e[9] = -s * u, e[2] = -c * u, e[6] = r * l + n, e[10] = t - i * l } else if ("XZY" === t.order) { const t = o * a, r = o * c, n = s * a, i = s * c; e[0] = a * u, e[4] = -l, e[8] = c * u, e[1] = t * l + i, e[5] = o * u, e[9] = r * l - n, e[2] = n * l - r, e[6] = s * u, e[10] = i * l + t } return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this } makeRotationFromQuaternion(t) { return this.compose($, t, tt) } lookAt(t, e, r) { const n = this.elements; return nt.subVectors(t, e), 0 === nt.lengthSq() && (nt.z = 1), nt.normalize(), et.crossVectors(r, nt), 0 === et.lengthSq() && (1 === Math.abs(r.z) ? nt.x += 1e-4 : nt.z += 1e-4, nt.normalize(), et.crossVectors(r, nt)), et.normalize(), rt.crossVectors(nt, et), n[0] = et.x, n[4] = rt.x, n[8] = nt.x, n[1] = et.y, n[5] = rt.y, n[9] = nt.y, n[2] = et.z, n[6] = rt.z, n[10] = nt.z, this } multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) } premultiply(t) { return this.multiplyMatrices(t, this) } multiplyMatrices(t, e) { const r = t.elements, n = e.elements, i = this.elements, o = r[0], s = r[4], a = r[8], c = r[12], u = r[1], l = r[5], h = r[9], f = r[13], p = r[2], d = r[6], m = r[10], g = r[14], v = r[3], y = r[7], x = r[11], b = r[15], w = n[0], M = n[4], S = n[8], _ = n[12], T = n[1], E = n[5], A = n[9], R = n[13], L = n[2], O = n[6], P = n[10], I = n[14], C = n[3], k = n[7], N = n[11], z = n[15]; return i[0] = o * w + s * T + a * L + c * C, i[4] = o * M + s * E + a * O + c * k, i[8] = o * S + s * A + a * P + c * N, i[12] = o * _ + s * R + a * I + c * z, i[1] = u * w + l * T + h * L + f * C, i[5] = u * M + l * E + h * O + f * k, i[9] = u * S + l * A + h * P + f * N, i[13] = u * _ + l * R + h * I + f * z, i[2] = p * w + d * T + m * L + g * C, i[6] = p * M + d * E + m * O + g * k, i[10] = p * S + d * A + m * P + g * N, i[14] = p * _ + d * R + m * I + g * z, i[3] = v * w + y * T + x * L + b * C, i[7] = v * M + y * E + x * O + b * k, i[11] = v * S + y * A + x * P + b * N, i[15] = v * _ + y * R + x * I + b * z, this } multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this } determinant() { const t = this.elements, e = t[0], r = t[4], n = t[8], i = t[12], o = t[1], s = t[5], a = t[9], c = t[13], u = t[2], l = t[6], h = t[10], f = t[14]; return t[3] * (+i * a * l - n * c * l - i * s * h + r * c * h + n * s * f - r * a * f) + t[7] * (+e * a * f - e * c * h + i * o * h - n * o * f + n * c * u - i * a * u) + t[11] * (+e * c * l - e * s * f - i * o * l + r * o * f + i * s * u - r * c * u) + t[15] * (-n * s * u - e * a * l + e * s * h + n * o * l - r * o * h + r * a * u) } transpose() { const t = this.elements; let e; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this } setPosition(t, e, r) { const n = this.elements; return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = r), this } getInverse(t, e) { void 0 !== e && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate."); const r = this.elements, n = t.elements, i = n[0], o = n[1], s = n[2], a = n[3], c = n[4], u = n[5], l = n[6], h = n[7], f = n[8], p = n[9], d = n[10], m = n[11], g = n[12], v = n[13], y = n[14], x = n[15], b = p * y * h - v * d * h + v * l * m - u * y * m - p * l * x + u * d * x, w = g * d * h - f * y * h - g * l * m + c * y * m + f * l * x - c * d * x, M = f * v * h - g * p * h + g * u * m - c * v * m - f * u * x + c * p * x, S = g * p * l - f * v * l - g * u * d + c * v * d + f * u * y - c * p * y, _ = i * b + o * w + s * M + a * S; if (0 === _) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const T = 1 / _; return r[0] = b * T, r[1] = (v * d * a - p * y * a - v * s * m + o * y * m + p * s * x - o * d * x) * T, r[2] = (u * y * a - v * l * a + v * s * h - o * y * h - u * s * x + o * l * x) * T, r[3] = (p * l * a - u * d * a - p * s * h + o * d * h + u * s * m - o * l * m) * T, r[4] = w * T, r[5] = (f * y * a - g * d * a + g * s * m - i * y * m - f * s * x + i * d * x) * T, r[6] = (g * l * a - c * y * a - g * s * h + i * y * h + c * s * x - i * l * x) * T, r[7] = (c * d * a - f * l * a + f * s * h - i * d * h - c * s * m + i * l * m) * T, r[8] = M * T, r[9] = (g * p * a - f * v * a - g * o * m + i * v * m + f * o * x - i * p * x) * T, r[10] = (c * v * a - g * u * a + g * o * h - i * v * h - c * o * x + i * u * x) * T, r[11] = (f * u * a - c * p * a - f * o * h + i * p * h + c * o * m - i * u * m) * T, r[12] = S * T, r[13] = (f * v * s - g * p * s + g * o * d - i * v * d - f * o * y + i * p * y) * T, r[14] = (g * u * s - c * v * s - g * o * l + i * v * l + c * o * y - i * u * y) * T, r[15] = (c * p * s - f * u * s + f * o * l - i * p * l - c * o * d + i * u * d) * T, this } scale(t) { const e = this.elements, r = t.x, n = t.y, i = t.z; return e[0] *= r, e[4] *= n, e[8] *= i, e[1] *= r, e[5] *= n, e[9] *= i, e[2] *= r, e[6] *= n, e[10] *= i, e[3] *= r, e[7] *= n, e[11] *= i, this } getMaxScaleOnAxis() { const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], r = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]; return Math.sqrt(Math.max(e, r, n)) } makeTranslation(t, e, r) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, r, 0, 0, 0, 1), this } makeRotationX(t) { const e = Math.cos(t), r = Math.sin(t); return this.set(1, 0, 0, 0, 0, e, -r, 0, 0, r, e, 0, 0, 0, 0, 1), this } makeRotationY(t) { const e = Math.cos(t), r = Math.sin(t); return this.set(e, 0, r, 0, 0, 1, 0, 0, -r, 0, e, 0, 0, 0, 0, 1), this } makeRotationZ(t) { const e = Math.cos(t), r = Math.sin(t); return this.set(e, -r, 0, 0, r, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(t, e) { const r = Math.cos(e), n = Math.sin(e), i = 1 - r, o = t.x, s = t.y, a = t.z, c = i * o, u = i * s; return this.set(c * o + r, c * s - n * a, c * a + n * s, 0, c * s + n * a, u * s + r, u * a - n * o, 0, c * a - n * s, u * a + n * o, i * a * a + r, 0, 0, 0, 0, 1), this } makeScale(t, e, r) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this } makeShear(t, e, r) { return this.set(1, e, r, 0, t, 1, r, 0, t, e, 1, 0, 0, 0, 0, 1), this } compose(t, e, r) { const n = this.elements, i = e._x, o = e._y, s = e._z, a = e._w, c = i + i, u = o + o, l = s + s, h = i * c, f = i * u, p = i * l, d = o * u, m = o * l, g = s * l, v = a * c, y = a * u, x = a * l, b = r.x, w = r.y, M = r.z; return n[0] = (1 - (d + g)) * b, n[1] = (f + x) * b, n[2] = (p - y) * b, n[3] = 0, n[4] = (f - x) * w, n[5] = (1 - (h + g)) * w, n[6] = (m + v) * w, n[7] = 0, n[8] = (p + y) * M, n[9] = (m - v) * M, n[10] = (1 - (h + d)) * M, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this } decompose(t, e, r) { const n = this.elements; let i = J.set(n[0], n[1], n[2]).length(); const o = J.set(n[4], n[5], n[6]).length(), s = J.set(n[8], n[9], n[10]).length(); this.determinant() < 0 && (i = -i), t.x = n[12], t.y = n[13], t.z = n[14], Q.copy(this); const a = 1 / i, c = 1 / o, u = 1 / s; return Q.elements[0] *= a, Q.elements[1] *= a, Q.elements[2] *= a, Q.elements[4] *= c, Q.elements[5] *= c, Q.elements[6] *= c, Q.elements[8] *= u, Q.elements[9] *= u, Q.elements[10] *= u, e.setFromRotationMatrix(Q), r.x = i, r.y = o, r.z = s, this } makePerspective(t, e, r, n, i, o) { void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); const s = this.elements, a = 2 * i / (e - t), c = 2 * i / (r - n), u = (e + t) / (e - t), l = (r + n) / (r - n), h = -(o + i) / (o - i), f = -2 * o * i / (o - i); return s[0] = a, s[4] = 0, s[8] = u, s[12] = 0, s[1] = 0, s[5] = c, s[9] = l, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = f, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this } makeOrthographic(t, e, r, n, i, o) { const s = this.elements, a = 1 / (e - t), c = 1 / (r - n), u = 1 / (o - i), l = (e + t) * a, h = (r + n) * c, f = (o + i) * u; return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -l, s[1] = 0, s[5] = 2 * c, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = -2 * u, s[14] = -f, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this } equals(t) { const e = this.elements, r = t.elements; for (let t = 0; t < 16; t++)if (e[t] !== r[t]) return !1; return !0 } fromArray(t, e) { void 0 === e && (e = 0); for (let r = 0; r < 16; r++)this.elements[r] = t[r + e]; return this } toArray(t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); const r = this.elements; return t[e] = r[0], t[e + 1] = r[1], t[e + 2] = r[2], t[e + 3] = r[3], t[e + 4] = r[4], t[e + 5] = r[5], t[e + 6] = r[6], t[e + 7] = r[7], t[e + 8] = r[8], t[e + 9] = r[9], t[e + 10] = r[10], t[e + 11] = r[11], t[e + 12] = r[12], t[e + 13] = r[13], t[e + 14] = r[14], t[e + 15] = r[15], t } } const J = new S, Q = new K, $ = new S(0, 0, 0), tt = new S(1, 1, 1), et = new S, rt = new S, nt = new S; class it { constructor(t = 0, e = 0, r = 0, n = 1) { Object.defineProperty(this, "isVector4", { value: !0 }), this.x = t, this.y = e, this.z = r, this.w = n } get width() { return this.z } set width(t) { this.z = t } get height() { return this.w } set height(t) { this.w = t } set(t, e, r, n) { return this.x = t, this.y = e, this.z = r, this.w = n, this } setScalar(t) { return this.x = t, this.y = t, this.z = t, this.w = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setZ(t) { return this.z = t, this } setW(t) { return this.w = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this } add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) } addScalar(t) { return this.x += t, this.y += t, this.z += t, this.w += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this } sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) } subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this } multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this } applyMatrix4(t) { const e = this.x, r = this.y, n = this.z, i = this.w, o = t.elements; return this.x = o[0] * e + o[4] * r + o[8] * n + o[12] * i, this.y = o[1] * e + o[5] * r + o[9] * n + o[13] * i, this.z = o[2] * e + o[6] * r + o[10] * n + o[14] * i, this.w = o[3] * e + o[7] * r + o[11] * n + o[15] * i, this } divideScalar(t) { return this.multiplyScalar(1 / t) } setAxisAngleFromQuaternion(t) { this.w = 2 * Math.acos(t.w); const e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this } setAxisAngleFromRotationMatrix(t) { let e, r, n, i; const o = t.elements, s = o[0], a = o[4], c = o[8], u = o[1], l = o[5], h = o[9], f = o[2], p = o[6], d = o[10]; if (Math.abs(a - u) < .01 && Math.abs(c - f) < .01 && Math.abs(h - p) < .01) { if (Math.abs(a + u) < .1 && Math.abs(c + f) < .1 && Math.abs(h + p) < .1 && Math.abs(s + l + d - 3) < .1) return this.set(1, 0, 0, 0), this; e = Math.PI; const t = (s + 1) / 2, o = (l + 1) / 2, m = (d + 1) / 2, g = (a + u) / 4, v = (c + f) / 4, y = (h + p) / 4; return t > o && t > m ? t < .01 ? (r = 0, n = .707106781, i = .707106781) : (r = Math.sqrt(t), n = g / r, i = v / r) : o > m ? o < .01 ? (r = .707106781, n = 0, i = .707106781) : (n = Math.sqrt(o), r = g / n, i = y / n) : m < .01 ? (r = .707106781, n = .707106781, i = 0) : (i = Math.sqrt(m), r = v / i, n = y / i), this.set(r, n, i, e), this } let m = Math.sqrt((p - h) * (p - h) + (c - f) * (c - f) + (u - a) * (u - a)); return Math.abs(m) < .001 && (m = 1), this.x = (p - h) / m, this.y = (c - f) / m, this.z = (u - a) / m, this.w = Math.acos((s + l + d - 1) / 2), this } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this } clampLength(t, e) { const r = this.length(); return this.divideScalar(r || 1).multiplyScalar(Math.max(t, Math.min(e, r))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this } lerpVectors(t, e, r) { return this.x = t.x + (e.x - t.x) * r, this.y = t.y + (e.y - t.y) * r, this.z = t.z + (e.z - t.z) * r, this.w = t.w + (e.w - t.w) * r, this } equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w } fromArray(t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this } toArray(t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t } fromBufferAttribute(t, e, r) { return void 0 !== r && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } } function ot() { let t = null, e = !1, r = null, n = null; function i(e, o) { r(e, o), n = t.requestAnimationFrame(i) } return { start: function () { !0 !== e && null !== r && (n = t.requestAnimationFrame(i), e = !0) }, stop: function () { t.cancelAnimationFrame(n), e = !1 }, setAnimationLoop: function (t) { r = t }, setContext: function (e) { t = e } } } function st(t, e) { const r = e.isWebGL2, n = new WeakMap; return { get: function (t) { return t.isInterleavedBufferAttribute && (t = t.data), n.get(t) }, remove: function (e) { e.isInterleavedBufferAttribute && (e = e.data); const r = n.get(e); r && (t.deleteBuffer(r.buffer), n.delete(e)) }, update: function (e, i) { if (e.isGLBufferAttribute) { var o = n.get(e); return void ((!o || o.version < e.version) && n.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version })) } e.isInterleavedBufferAttribute && (e = e.data); const s = n.get(e); void 0 === s ? n.set(e, function (e, r) { const n = e.array, i = e.usage, o = t.createBuffer(); t.bindBuffer(r, o), t.bufferData(r, n, i), e.onUploadCallback(); let s = 5126; return n instanceof Float32Array ? s = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? s = 5123 : n instanceof Int16Array ? s = 5122 : n instanceof Uint32Array ? s = 5125 : n instanceof Int32Array ? s = 5124 : n instanceof Int8Array ? s = 5120 : n instanceof Uint8Array && (s = 5121), { buffer: o, type: s, bytesPerElement: n.BYTES_PER_ELEMENT, version: e.version } }(e, i)) : s.version < e.version && (!function (e, n, i) { const o = n.array, s = n.updateRange; t.bindBuffer(i, e), -1 === s.count ? t.bufferSubData(i, 0, o) : (r ? t.bufferSubData(i, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(i, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1) }(s.buffer, e, i), s.version = e.version) } } } const at = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, ct = { h: 0, s: 0, l: 0 }, ut = { h: 0, s: 0, l: 0 }; function lt(t, e, r) { return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + 6 * (e - t) * r : r < .5 ? e : r < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - r) : t } function ht(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) } function ft(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 } class pt { constructor(t, e, r) { return Object.defineProperty(this, "isColor", { value: !0 }), void 0 === e && void 0 === r ? this.set(t) : this.setRGB(t, e, r) } set(t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this } setScalar(t) { return this.r = t, this.g = t, this.b = t, this } setHex(t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this } setRGB(t, e, r) { return this.r = t, this.g = e, this.b = r, this } setHSL(t, e, r) { if (t = p.euclideanModulo(t, 1), e = p.clamp(e, 0, 1), r = p.clamp(r, 0, 1), 0 === e) this.r = this.g = this.b = r; else { const n = r <= .5 ? r * (1 + e) : r + e - r * e, i = 2 * r - n; this.r = lt(i, n, t + 1 / 3), this.g = lt(i, n, t), this.b = lt(i, n, t - 1 / 3) } return this } setStyle(t) { function e(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } let r; if (r = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) { let t; const n = r[1], i = r[2]; switch (n) { case "rgb": case "rgba": if (t = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[5]), this; if (t = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[5]), this; break; case "hsl": case "hsla": if (t = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) { const r = parseFloat(t[1]) / 360, n = parseInt(t[2], 10) / 100, i = parseInt(t[3], 10) / 100; return e(t[5]), this.setHSL(r, n, i) } } } else if (r = /^\#([A-Fa-f0-9]+)$/.exec(t)) { const t = r[1], e = t.length; if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this; if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this } return t && t.length > 0 ? this.setColorName(t) : this } setColorName(t) { const e = at[t]; return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(t) { return this.r = t.r, this.g = t.g, this.b = t.b, this } copyGammaToLinear(t, e) { return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this } copyLinearToGamma(t, e) { void 0 === e && (e = 2); const r = e > 0 ? 1 / e : 1; return this.r = Math.pow(t.r, r), this.g = Math.pow(t.g, r), this.b = Math.pow(t.b, r), this } convertGammaToLinear(t) { return this.copyGammaToLinear(this, t), this } convertLinearToGamma(t) { return this.copyLinearToGamma(this, t), this } copySRGBToLinear(t) { return this.r = ht(t.r), this.g = ht(t.g), this.b = ht(t.b), this } copyLinearToSRGB(t) { return this.r = ft(t.r), this.g = ft(t.g), this.b = ft(t.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 } getHexString() { return ("000000" + this.getHex().toString(16)).slice(-6) } getHSL(t) { void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 }); const e = this.r, r = this.g, n = this.b, i = Math.max(e, r, n), o = Math.min(e, r, n); let s, a; const c = (o + i) / 2; if (o === i) s = 0, a = 0; else { const t = i - o; switch (a = c <= .5 ? t / (i + o) : t / (2 - i - o), i) { case e: s = (r - n) / t + (r < n ? 6 : 0); break; case r: s = (n - e) / t + 2; break; case n: s = (e - r) / t + 4 }s /= 6 } return t.h = s, t.s = a, t.l = c, t } getStyle() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" } offsetHSL(t, e, r) { return this.getHSL(ct), ct.h += t, ct.s += e, ct.l += r, this.setHSL(ct.h, ct.s, ct.l), this } add(t) { return this.r += t.r, this.g += t.g, this.b += t.b, this } addColors(t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this } addScalar(t) { return this.r += t, this.g += t, this.b += t, this } sub(t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this } multiply(t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this } multiplyScalar(t) { return this.r *= t, this.g *= t, this.b *= t, this } lerp(t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this } lerpHSL(t, e) { this.getHSL(ct), t.getHSL(ut); const r = p.lerp(ct.h, ut.h, e), n = p.lerp(ct.s, ut.s, e), i = p.lerp(ct.l, ut.l, e); return this.setHSL(r, n, i), this } equals(t) { return t.r === this.r && t.g === this.g && t.b === this.b } fromArray(t, e) { return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this } toArray(t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t } fromBufferAttribute(t, e) { return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this } toJSON() { return this.getHex() } } pt.NAMES = at, pt.prototype.r = 1, pt.prototype.g = 1, pt.prototype.b = 1; class dt { constructor(t, e, r, n, i, o) { this.a = t, this.b = e, this.c = r, this.normal = n && n.isVector3 ? n : new S, this.vertexNormals = Array.isArray(n) ? n : [], this.color = i && i.isColor ? i : new pt, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== o ? o : 0 } clone() { return (new this.constructor).copy(this) } copy(t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (let e = 0, r = t.vertexNormals.length; e < r; e++)this.vertexNormals[e] = t.vertexNormals[e].clone(); for (let e = 0, r = t.vertexColors.length; e < r; e++)this.vertexColors[e] = t.vertexColors[e].clone(); return this } } class mt { constructor(t = 0, e = 0, r = 0, n = mt.DefaultOrder) { Object.defineProperty(this, "isEuler", { value: !0 }), this._x = t, this._y = e, this._z = r, this._order = n } get x() { return this._x } set x(t) { this._x = t, this._onChangeCallback() } get y() { return this._y } set y(t) { this._y = t, this._onChangeCallback() } get z() { return this._z } set z(t) { this._z = t, this._onChangeCallback() } get order() { return this._order } set order(t) { this._order = t, this._onChangeCallback() } set(t, e, r, n) { return this._x = t, this._y = e, this._z = r, this._order = n || this._order, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this } setFromRotationMatrix(t, e, r) { const n = p.clamp, i = t.elements, o = i[0], s = i[4], a = i[8], c = i[1], u = i[5], l = i[9], h = i[2], f = i[6], d = i[10]; switch (e = e || this._order) { case "XYZ": this._y = Math.asin(n(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-l, d), this._z = Math.atan2(-s, o)) : (this._x = Math.atan2(f, u), this._z = 0); break; case "YXZ": this._x = Math.asin(-n(l, -1, 1)), Math.abs(l) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-h, o), this._z = 0); break; case "ZXY": this._x = Math.asin(n(f, -1, 1)), Math.abs(f) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, u)) : (this._y = 0, this._z = Math.atan2(c, o)); break; case "ZYX": this._y = Math.asin(-n(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(f, d), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-s, u)); break; case "YZX": this._z = Math.asin(n(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-l, u), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(a, d)); break; case "XZY": this._z = Math.asin(-n(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(f, u), this._y = Math.atan2(a, o)) : (this._x = Math.atan2(-l, d), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e) }return this._order = e, !1 !== r && this._onChangeCallback(), this } setFromQuaternion(t, e, r) { return gt.makeRotationFromQuaternion(t), this.setFromRotationMatrix(gt, e, r) } setFromVector3(t, e) { return this.set(t.x, t.y, t.z, e || this._order) } reorder(t) { return vt.setFromEuler(this), this.setFromQuaternion(vt, t) } equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order } fromArray(t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this } toArray(t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t } toVector3(t) { return t ? t.set(this._x, this._y, this._z) : new S(this._x, this._y, this._z) } _onChange(t) { return this._onChangeCallback = t, this } _onChangeCallback() { } } mt.DefaultOrder = "XYZ", mt.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; const gt = new K, vt = new M; class yt { constructor() { this.mask = 1 } set(t) { this.mask = 1 << t | 0 } enable(t) { this.mask |= 1 << t | 0 } enableAll() { this.mask = -1 } toggle(t) { this.mask ^= 1 << t | 0 } disable(t) { this.mask &= ~(1 << t | 0) } disableAll() { this.mask = 0 } test(t) { return 0 != (this.mask & t.mask) } } let xt = 0; const bt = new S, wt = new M, Mt = new K, St = new S, _t = new S, Tt = new S, Et = new M, At = new S(1, 0, 0), Rt = new S(0, 1, 0), Lt = new S(0, 0, 1), Ot = { type: "added" }, Pt = { type: "removed" }; function It() { Object.defineProperty(this, "id", { value: xt++ }), this.uuid = p.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = It.DefaultUp.clone(); const t = new S, e = new mt, r = new M, n = new S(1, 1, 1); e._onChange((function () { r.setFromEuler(e, !1) })), r._onChange((function () { e.setFromQuaternion(r, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: r }, scale: { configurable: !0, enumerable: !0, value: n }, modelViewMatrix: { value: new K }, normalMatrix: { value: new g } }), this.matrix = new K, this.matrixWorld = new K, this.matrixAutoUpdate = It.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new yt, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {} } It.DefaultUp = new S(0, 1, 0), It.DefaultMatrixAutoUpdate = !0, It.prototype = Object.assign(Object.create(d.prototype), { constructor: It, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix4: function (t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function (t) { return this.quaternion.premultiply(t), this }, setRotationFromAxisAngle: function (t, e) { this.quaternion.setFromAxisAngle(t, e) }, setRotationFromEuler: function (t) { this.quaternion.setFromEuler(t, !0) }, setRotationFromMatrix: function (t) { this.quaternion.setFromRotationMatrix(t) }, setRotationFromQuaternion: function (t) { this.quaternion.copy(t) }, rotateOnAxis: function (t, e) { return wt.setFromAxisAngle(t, e), this.quaternion.multiply(wt), this }, rotateOnWorldAxis: function (t, e) { return wt.setFromAxisAngle(t, e), this.quaternion.premultiply(wt), this }, rotateX: function (t) { return this.rotateOnAxis(At, t) }, rotateY: function (t) { return this.rotateOnAxis(Rt, t) }, rotateZ: function (t) { return this.rotateOnAxis(Lt, t) }, translateOnAxis: function (t, e) { return bt.copy(t).applyQuaternion(this.quaternion), this.position.add(bt.multiplyScalar(e)), this }, translateX: function (t) { return this.translateOnAxis(At, t) }, translateY: function (t) { return this.translateOnAxis(Rt, t) }, translateZ: function (t) { return this.translateOnAxis(Lt, t) }, localToWorld: function (t) { return t.applyMatrix4(this.matrixWorld) }, worldToLocal: function (t) { return t.applyMatrix4(Mt.getInverse(this.matrixWorld)) }, lookAt: function (t, e, r) { t.isVector3 ? St.copy(t) : St.set(t, e, r); const n = this.parent; this.updateWorldMatrix(!0, !1), _t.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Mt.lookAt(_t, St, this.up) : Mt.lookAt(St, _t, this.up), this.quaternion.setFromRotationMatrix(Mt), n && (Mt.extractRotation(n.matrixWorld), wt.setFromRotationMatrix(Mt), this.quaternion.premultiply(wt.inverse())) }, add: function (t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Ot)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) }, remove: function (t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.remove(arguments[t]); return this } const e = this.children.indexOf(t); return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Pt)), this }, attach: function (t) { return this.updateWorldMatrix(!0, !1), Mt.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Mt.multiply(t.parent.matrixWorld)), t.applyMatrix4(Mt), t.updateWorldMatrix(!1, !1), this.add(t), this }, getObjectById: function (t) { return this.getObjectByProperty("id", t) }, getObjectByName: function (t) { return this.getObjectByProperty("name", t) }, getObjectByProperty: function (t, e) { if (this[t] === e) return this; for (let r = 0, n = this.children.length; r < n; r++) { const n = this.children[r].getObjectByProperty(t, e); if (void 0 !== n) return n } }, getWorldPosition: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new S), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new M), this.updateMatrixWorld(!0), this.matrixWorld.decompose(_t, t, Tt), t }, getWorldScale: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new S), this.updateMatrixWorld(!0), this.matrixWorld.decompose(_t, Et, t), t }, getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new S), this.updateMatrixWorld(!0); const e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() }, raycast: function () { }, traverse: function (t) { t(this); const e = this.children; for (let r = 0, n = e.length; r < n; r++)e[r].traverse(t) }, traverseVisible: function (t) { if (!1 === this.visible) return; t(this); const e = this.children; for (let r = 0, n = e.length; r < n; r++)e[r].traverseVisible(t) }, traverseAncestors: function (t) { const e = this.parent; null !== e && (t(e), e.traverseAncestors(t)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); const e = this.children; for (let r = 0, n = e.length; r < n; r++)e[r].updateMatrixWorld(t) }, updateWorldMatrix: function (t, e) { const r = this.parent; if (!0 === t && null !== r && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) { const t = this.children; for (let e = 0, r = t.length; e < r; e++)t[e].updateWorldMatrix(!1, !0) } }, toJSON: function (t) { const e = void 0 === t || "string" == typeof t, r = {}; e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, r.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const n = {}; function i(e, r) { return void 0 === e[r.uuid] && (e[r.uuid] = r.toJSON(t)), r.uuid } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) { n.geometry = i(t.geometries, this.geometry); const e = this.geometry.parameters; if (void 0 !== e && void 0 !== e.shapes) { const r = e.shapes; if (Array.isArray(r)) for (let e = 0, n = r.length; e < n; e++) { const n = r[e]; i(t.shapes, n) } else i(t.shapes, r) } } if (void 0 !== this.material) if (Array.isArray(this.material)) { const e = []; for (let r = 0, n = this.material.length; r < n; r++)e.push(i(t.materials, this.material[r])); n.material = e } else n.material = i(t.materials, this.material); if (this.children.length > 0) { n.children = []; for (let e = 0; e < this.children.length; e++)n.children.push(this.children[e].toJSON(t).object) } if (e) { const e = o(t.geometries), n = o(t.materials), i = o(t.textures), s = o(t.images), a = o(t.shapes); e.length > 0 && (r.geometries = e), n.length > 0 && (r.materials = n), i.length > 0 && (r.textures = i), s.length > 0 && (r.images = s), a.length > 0 && (r.shapes = a) } return r.object = n, r; function o(t) { const e = []; for (const r in t) { const n = t[r]; delete n.metadata, e.push(n) } return e } }, clone: function (t) { return (new this.constructor).copy(this, t) }, copy: function (t, e) { if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let e = 0; e < t.children.length; e++) { const r = t.children[e]; this.add(r.clone()) } return this } }); let Ct = 0; const kt = new K, Nt = new It, zt = new S; function Ut() { Object.defineProperty(this, "id", { value: Ct += 2 }), this.uuid = p.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1 } Ut.prototype = Object.assign(Object.create(d.prototype), { constructor: Ut, isGeometry: !0, applyMatrix4: function (t) { const e = (new g).getNormalMatrix(t); for (let e = 0, r = this.vertices.length; e < r; e++) { this.vertices[e].applyMatrix4(t) } for (let t = 0, r = this.faces.length; t < r; t++) { const r = this.faces[t]; r.normal.applyMatrix3(e).normalize(); for (let t = 0, n = r.vertexNormals.length; t < n; t++)r.vertexNormals[t].applyMatrix3(e).normalize() } return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this }, rotateX: function (t) { return kt.makeRotationX(t), this.applyMatrix4(kt), this }, rotateY: function (t) { return kt.makeRotationY(t), this.applyMatrix4(kt), this }, rotateZ: function (t) { return kt.makeRotationZ(t), this.applyMatrix4(kt), this }, translate: function (t, e, r) { return kt.makeTranslation(t, e, r), this.applyMatrix4(kt), this }, scale: function (t, e, r) { return kt.makeScale(t, e, r), this.applyMatrix4(kt), this }, lookAt: function (t) { return Nt.lookAt(t), Nt.updateMatrix(), this.applyMatrix4(Nt.matrix), this }, fromBufferGeometry: function (t) { const e = this, r = null !== t.index ? t.index : void 0, n = t.attributes; if (void 0 === n.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this; const i = n.position, o = n.normal, s = n.color, a = n.uv, c = n.uv2; void 0 !== c && (this.faceVertexUvs[1] = []); for (let t = 0; t < i.count; t++)e.vertices.push((new S).fromBufferAttribute(i, t)), void 0 !== s && e.colors.push((new pt).fromBufferAttribute(s, t)); function u(t, r, n, i) { const u = void 0 === s ? [] : [e.colors[t].clone(), e.colors[r].clone(), e.colors[n].clone()], l = void 0 === o ? [] : [(new S).fromBufferAttribute(o, t), (new S).fromBufferAttribute(o, r), (new S).fromBufferAttribute(o, n)], h = new dt(t, r, n, l, u, i); e.faces.push(h), void 0 !== a && e.faceVertexUvs[0].push([(new m).fromBufferAttribute(a, t), (new m).fromBufferAttribute(a, r), (new m).fromBufferAttribute(a, n)]), void 0 !== c && e.faceVertexUvs[1].push([(new m).fromBufferAttribute(c, t), (new m).fromBufferAttribute(c, r), (new m).fromBufferAttribute(c, n)]) } const l = t.groups; if (l.length > 0) for (let t = 0; t < l.length; t++) { const e = l[t], n = e.start; for (let t = n, i = n + e.count; t < i; t += 3)void 0 !== r ? u(r.getX(t), r.getX(t + 1), r.getX(t + 2), e.materialIndex) : u(t, t + 1, t + 2, e.materialIndex) } else if (void 0 !== r) for (let t = 0; t < r.count; t += 3)u(r.getX(t), r.getX(t + 1), r.getX(t + 2)); else for (let t = 0; t < i.count; t += 3)u(t, t + 1, t + 2); return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this }, center: function () { return this.computeBoundingBox(), this.boundingBox.getCenter(zt).negate(), this.translate(zt.x, zt.y, zt.z), this }, normalize: function () { this.computeBoundingSphere(); const t = this.boundingSphere.center, e = this.boundingSphere.radius, r = 0 === e ? 1 : 1 / e, n = new K; return n.set(r, 0, 0, -r * t.x, 0, r, 0, -r * t.y, 0, 0, r, -r * t.z, 0, 0, 0, 1), this.applyMatrix4(n), this }, computeFaceNormals: function () { const t = new S, e = new S; for (let r = 0, n = this.faces.length; r < n; r++) { const n = this.faces[r], i = this.vertices[n.a], o = this.vertices[n.b], s = this.vertices[n.c]; t.subVectors(s, o), e.subVectors(i, o), t.cross(e), t.normalize(), n.normal.copy(t) } }, computeVertexNormals: function (t) { void 0 === t && (t = !0); const e = new Array(this.vertices.length); for (let t = 0, r = this.vertices.length; t < r; t++)e[t] = new S; if (t) { const t = new S, r = new S; for (let n = 0, i = this.faces.length; n < i; n++) { const i = this.faces[n], o = this.vertices[i.a], s = this.vertices[i.b], a = this.vertices[i.c]; t.subVectors(a, s), r.subVectors(o, s), t.cross(r), e[i.a].add(t), e[i.b].add(t), e[i.c].add(t) } } else { this.computeFaceNormals(); for (let t = 0, r = this.faces.length; t < r; t++) { const r = this.faces[t]; e[r.a].add(r.normal), e[r.b].add(r.normal), e[r.c].add(r.normal) } } for (let t = 0, r = this.vertices.length; t < r; t++)e[t].normalize(); for (let t = 0, r = this.faces.length; t < r; t++) { const r = this.faces[t], n = r.vertexNormals; 3 === n.length ? (n[0].copy(e[r.a]), n[1].copy(e[r.b]), n[2].copy(e[r.c])) : (n[0] = e[r.a].clone(), n[1] = e[r.b].clone(), n[2] = e[r.c].clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeFlatVertexNormals: function () { this.computeFaceNormals(); for (let t = 0, e = this.faces.length; t < e; t++) { const e = this.faces[t], r = e.vertexNormals; 3 === r.length ? (r[0].copy(e.normal), r[1].copy(e.normal), r[2].copy(e.normal)) : (r[0] = e.normal.clone(), r[1] = e.normal.clone(), r[2] = e.normal.clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeMorphNormals: function () { for (let t = 0, e = this.faces.length; t < e; t++) { const e = this.faces[t]; e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []); for (let t = 0, r = e.vertexNormals.length; t < r; t++)e.__originalVertexNormals[t] ? e.__originalVertexNormals[t].copy(e.vertexNormals[t]) : e.__originalVertexNormals[t] = e.vertexNormals[t].clone() } const t = new Ut; t.faces = this.faces; for (let e = 0, r = this.morphTargets.length; e < r; e++) { if (!this.morphNormals[e]) { this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = []; const t = this.morphNormals[e].faceNormals, r = this.morphNormals[e].vertexNormals; for (let e = 0, n = this.faces.length; e < n; e++) { const e = new S, n = { a: new S, b: new S, c: new S }; t.push(e), r.push(n) } } const r = this.morphNormals[e]; t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals(); for (let t = 0, e = this.faces.length; t < e; t++) { const e = this.faces[t], n = r.faceNormals[t], i = r.vertexNormals[t]; n.copy(e.normal), i.a.copy(e.vertexNormals[0]), i.b.copy(e.vertexNormals[1]), i.c.copy(e.vertexNormals[2]) } } for (let t = 0, e = this.faces.length; t < e; t++) { const e = this.faces[t]; e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals } }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new E), this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new G), this.boundingSphere.setFromPoints(this.vertices) }, merge: function (t, e, r) { if (!t || !t.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t); let n; const i = this.vertices.length, o = this.vertices, s = t.vertices, a = this.faces, c = t.faces, u = this.colors, l = t.colors; void 0 === r && (r = 0), void 0 !== e && (n = (new g).getNormalMatrix(e)); for (let t = 0, r = s.length; t < r; t++) { const r = s[t].clone(); void 0 !== e && r.applyMatrix4(e), o.push(r) } for (let t = 0, e = l.length; t < e; t++)u.push(l[t].clone()); for (let t = 0, e = c.length; t < e; t++) { const e = c[t]; let o, s; const u = e.vertexNormals, l = e.vertexColors, h = new dt(e.a + i, e.b + i, e.c + i); h.normal.copy(e.normal), void 0 !== n && h.normal.applyMatrix3(n).normalize(); for (let t = 0, e = u.length; t < e; t++)o = u[t].clone(), void 0 !== n && o.applyMatrix3(n).normalize(), h.vertexNormals.push(o); h.color.copy(e.color); for (let t = 0, e = l.length; t < e; t++)s = l[t], h.vertexColors.push(s.clone()); h.materialIndex = e.materialIndex + r, a.push(h) } for (let e = 0, r = t.faceVertexUvs.length; e < r; e++) { const r = t.faceVertexUvs[e]; void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []); for (let t = 0, n = r.length; t < n; t++) { const n = r[t], i = []; for (let t = 0, e = n.length; t < e; t++)i.push(n[t].clone()); this.faceVertexUvs[e].push(i) } } }, mergeMesh: function (t) { t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) }, mergeVertices: function () { const t = {}, e = [], r = [], n = Math.pow(10, 4); for (let i = 0, o = this.vertices.length; i < o; i++) { const o = this.vertices[i], s = Math.round(o.x * n) + "_" + Math.round(o.y * n) + "_" + Math.round(o.z * n); void 0 === t[s] ? (t[s] = i, e.push(this.vertices[i]), r[i] = e.length - 1) : r[i] = r[t[s]] } const i = []; for (let t = 0, e = this.faces.length; t < e; t++) { const e = this.faces[t]; e.a = r[e.a], e.b = r[e.b], e.c = r[e.c]; const n = [e.a, e.b, e.c]; for (let e = 0; e < 3; e++)if (n[e] === n[(e + 1) % 3]) { i.push(t); break } } for (let t = i.length - 1; t >= 0; t--) { const e = i[t]; this.faces.splice(e, 1); for (let t = 0, r = this.faceVertexUvs.length; t < r; t++)this.faceVertexUvs[t].splice(e, 1) } const o = this.vertices.length - e.length; return this.vertices = e, o }, setFromPoints: function (t) { this.vertices = []; for (let e = 0, r = t.length; e < r; e++) { const r = t[e]; this.vertices.push(new S(r.x, r.y, r.z || 0)) } return this }, sortFacesByMaterialIndex: function () { const t = this.faces, e = t.length; for (let r = 0; r < e; r++)t[r]._id = r; t.sort((function (t, e) { return t.materialIndex - e.materialIndex })); const r = this.faceVertexUvs[0], n = this.faceVertexUvs[1]; let i, o; r && r.length === e && (i = []), n && n.length === e && (o = []); for (let s = 0; s < e; s++) { const e = t[s]._id; i && i.push(r[e]), o && o.push(n[e]) } i && (this.faceVertexUvs[0] = i), o && (this.faceVertexUvs[1] = o) }, toJSON: function () { const t = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) { const e = this.parameters; for (const r in e) void 0 !== e[r] && (t[r] = e[r]); return t } const e = []; for (let t = 0; t < this.vertices.length; t++) { const r = this.vertices[t]; e.push(r.x, r.y, r.z) } const r = [], n = [], i = {}, o = [], s = {}, a = [], c = {}; for (let t = 0; t < this.faces.length; t++) { const e = this.faces[t], n = !0, i = !1, o = void 0 !== this.faceVertexUvs[0][t], s = e.normal.length() > 0, a = e.vertexNormals.length > 0, c = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b, p = e.vertexColors.length > 0; let d = 0; if (d = u(d, 0, 0), d = u(d, 1, n), d = u(d, 2, i), d = u(d, 3, o), d = u(d, 4, s), d = u(d, 5, a), d = u(d, 6, c), d = u(d, 7, p), r.push(d), r.push(e.a, e.b, e.c), r.push(e.materialIndex), o) { const e = this.faceVertexUvs[0][t]; r.push(f(e[0]), f(e[1]), f(e[2])) } if (s && r.push(l(e.normal)), a) { const t = e.vertexNormals; r.push(l(t[0]), l(t[1]), l(t[2])) } if (c && r.push(h(e.color)), p) { const t = e.vertexColors; r.push(h(t[0]), h(t[1]), h(t[2])) } } function u(t, e, r) { return r ? t | 1 << e : t & ~(1 << e) } function l(t) { const e = t.x.toString() + t.y.toString() + t.z.toString(); return void 0 !== i[e] || (i[e] = n.length / 3, n.push(t.x, t.y, t.z)), i[e] } function h(t) { const e = t.r.toString() + t.g.toString() + t.b.toString(); return void 0 !== s[e] || (s[e] = o.length, o.push(t.getHex())), s[e] } function f(t) { const e = t.x.toString() + t.y.toString(); return void 0 !== c[e] || (c[e] = a.length / 2, a.push(t.x, t.y)), c[e] } return t.data = {}, t.data.vertices = e, t.data.normals = n, o.length > 0 && (t.data.colors = o), a.length > 0 && (t.data.uvs = [a]), t.data.faces = r, t }, clone: function () { return (new Ut).copy(this) }, copy: function (t) { this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name; const e = t.vertices; for (let t = 0, r = e.length; t < r; t++)this.vertices.push(e[t].clone()); const r = t.colors; for (let t = 0, e = r.length; t < e; t++)this.colors.push(r[t].clone()); const n = t.faces; for (let t = 0, e = n.length; t < e; t++)this.faces.push(n[t].clone()); for (let e = 0, r = t.faceVertexUvs.length; e < r; e++) { const r = t.faceVertexUvs[e]; void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []); for (let t = 0, n = r.length; t < n; t++) { const n = r[t], i = []; for (let t = 0, e = n.length; t < e; t++) { const e = n[t]; i.push(e.clone()) } this.faceVertexUvs[e].push(i) } } const i = t.morphTargets; for (let t = 0, e = i.length; t < e; t++) { const e = {}; if (e.name = i[t].name, void 0 !== i[t].vertices) { e.vertices = []; for (let r = 0, n = i[t].vertices.length; r < n; r++)e.vertices.push(i[t].vertices[r].clone()) } if (void 0 !== i[t].normals) { e.normals = []; for (let r = 0, n = i[t].normals.length; r < n; r++)e.normals.push(i[t].normals[r].clone()) } this.morphTargets.push(e) } const o = t.morphNormals; for (let t = 0, e = o.length; t < e; t++) { const e = {}; if (void 0 !== o[t].vertexNormals) { e.vertexNormals = []; for (let r = 0, n = o[t].vertexNormals.length; r < n; r++) { const n = o[t].vertexNormals[r], i = {}; i.a = n.a.clone(), i.b = n.b.clone(), i.c = n.c.clone(), e.vertexNormals.push(i) } } if (void 0 !== o[t].faceNormals) { e.faceNormals = []; for (let r = 0, n = o[t].faceNormals.length; r < n; r++)e.faceNormals.push(o[t].faceNormals[r].clone()) } this.morphNormals.push(e) } const s = t.skinWeights; for (let t = 0, e = s.length; t < e; t++)this.skinWeights.push(s[t].clone()); const a = t.skinIndices; for (let t = 0, e = a.length; t < e; t++)this.skinIndices.push(a[t].clone()); const c = t.lineDistances; for (let t = 0, e = c.length; t < e; t++)this.lineDistances.push(c[t]); const u = t.boundingBox; null !== u && (this.boundingBox = u.clone()); const l = t.boundingSphere; return null !== l && (this.boundingSphere = l.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); const jt = new S, Bt = new m; function Ft(t, e, r) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === r, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function Dt(t, e, r) { Ft.call(this, new Int8Array(t), e, r) } function Gt(t, e, r) { Ft.call(this, new Uint8Array(t), e, r) } function Vt(t, e, r) { Ft.call(this, new Uint8ClampedArray(t), e, r) } function Ht(t, e, r) { Ft.call(this, new Int16Array(t), e, r) } function Wt(t, e, r) { Ft.call(this, new Uint16Array(t), e, r) } function qt(t, e, r) { Ft.call(this, new Int32Array(t), e, r) } function Xt(t, e, r) { Ft.call(this, new Uint32Array(t), e, r) } function Yt(t, e, r) { Ft.call(this, new Float32Array(t), e, r) } function Zt(t, e, r) { Ft.call(this, new Float64Array(t), e, r) } Object.defineProperty(Ft.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(Ft.prototype, { isBufferAttribute: !0, onUploadCallback: function () { }, setUsage: function (t) { return this.usage = t, this }, copy: function (t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this }, copyAt: function (t, e, r) { t *= this.itemSize, r *= e.itemSize; for (let n = 0, i = this.itemSize; n < i; n++)this.array[t + n] = e.array[r + n]; return this }, copyArray: function (t) { return this.array.set(t), this }, copyColorsArray: function (t) { const e = this.array; let r = 0; for (let n = 0, i = t.length; n < i; n++) { let i = t[n]; void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), i = new pt), e[r++] = i.r, e[r++] = i.g, e[r++] = i.b } return this }, copyVector2sArray: function (t) { const e = this.array; let r = 0; for (let n = 0, i = t.length; n < i; n++) { let i = t[n]; void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), i = new m), e[r++] = i.x, e[r++] = i.y } return this }, copyVector3sArray: function (t) { const e = this.array; let r = 0; for (let n = 0, i = t.length; n < i; n++) { let i = t[n]; void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), i = new S), e[r++] = i.x, e[r++] = i.y, e[r++] = i.z } return this }, copyVector4sArray: function (t) { const e = this.array; let r = 0; for (let n = 0, i = t.length; n < i; n++) { let i = t[n]; void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), i = new it), e[r++] = i.x, e[r++] = i.y, e[r++] = i.z, e[r++] = i.w } return this }, applyMatrix3: function (t) { if (2 === this.itemSize) for (let e = 0, r = this.count; e < r; e++)Bt.fromBufferAttribute(this, e), Bt.applyMatrix3(t), this.setXY(e, Bt.x, Bt.y); else if (3 === this.itemSize) for (let e = 0, r = this.count; e < r; e++)jt.fromBufferAttribute(this, e), jt.applyMatrix3(t), this.setXYZ(e, jt.x, jt.y, jt.z); return this }, applyMatrix4: function (t) { for (let e = 0, r = this.count; e < r; e++)jt.x = this.getX(e), jt.y = this.getY(e), jt.z = this.getZ(e), jt.applyMatrix4(t), this.setXYZ(e, jt.x, jt.y, jt.z); return this }, applyNormalMatrix: function (t) { for (let e = 0, r = this.count; e < r; e++)jt.x = this.getX(e), jt.y = this.getY(e), jt.z = this.getZ(e), jt.applyNormalMatrix(t), this.setXYZ(e, jt.x, jt.y, jt.z); return this }, transformDirection: function (t) { for (let e = 0, r = this.count; e < r; e++)jt.x = this.getX(e), jt.y = this.getY(e), jt.z = this.getZ(e), jt.transformDirection(t), this.setXYZ(e, jt.x, jt.y, jt.z); return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, getX: function (t) { return this.array[t * this.itemSize] }, setX: function (t, e) { return this.array[t * this.itemSize] = e, this }, getY: function (t) { return this.array[t * this.itemSize + 1] }, setY: function (t, e) { return this.array[t * this.itemSize + 1] = e, this }, getZ: function (t) { return this.array[t * this.itemSize + 2] }, setZ: function (t, e) { return this.array[t * this.itemSize + 2] = e, this }, getW: function (t) { return this.array[t * this.itemSize + 3] }, setW: function (t, e) { return this.array[t * this.itemSize + 3] = e, this }, setXY: function (t, e, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = r, this }, setXYZ: function (t, e, r, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = r, this.array[t + 2] = n, this }, setXYZW: function (t, e, r, n, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = r, this.array[t + 2] = n, this.array[t + 3] = i, this }, onUpload: function (t) { return this.onUploadCallback = t, this }, clone: function () { return new this.constructor(this.array, this.itemSize).copy(this) }, toJSON: function () { return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized } } }), Dt.prototype = Object.create(Ft.prototype), Dt.prototype.constructor = Dt, Gt.prototype = Object.create(Ft.prototype), Gt.prototype.constructor = Gt, Vt.prototype = Object.create(Ft.prototype), Vt.prototype.constructor = Vt, Ht.prototype = Object.create(Ft.prototype), Ht.prototype.constructor = Ht, Wt.prototype = Object.create(Ft.prototype), Wt.prototype.constructor = Wt, qt.prototype = Object.create(Ft.prototype), qt.prototype.constructor = qt, Xt.prototype = Object.create(Ft.prototype), Xt.prototype.constructor = Xt, Yt.prototype = Object.create(Ft.prototype), Yt.prototype.constructor = Yt, Zt.prototype = Object.create(Ft.prototype), Zt.prototype.constructor = Zt; class Kt { constructor() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 } computeGroups(t) { const e = []; let r, n, i = void 0; const o = t.faces; for (n = 0; n < o.length; n++) { const t = o[n]; t.materialIndex !== i && (i = t.materialIndex, void 0 !== r && (r.count = 3 * n - r.start, e.push(r)), r = { start: 3 * n, materialIndex: i }) } void 0 !== r && (r.count = 3 * n - r.start, e.push(r)), this.groups = e } fromGeometry(t) { const e = t.faces, r = t.vertices, n = t.faceVertexUvs, i = n[0] && n[0].length > 0, o = n[1] && n[1].length > 0, s = t.morphTargets, a = s.length; let c; if (a > 0) { c = []; for (let t = 0; t < a; t++)c[t] = { name: s[t].name, data: [] }; this.morphTargets.position = c } const u = t.morphNormals, l = u.length; let h; if (l > 0) { h = []; for (let t = 0; t < l; t++)h[t] = { name: u[t].name, data: [] }; this.morphTargets.normal = h } const f = t.skinIndices, p = t.skinWeights, d = f.length === r.length, g = p.length === r.length; r.length > 0 && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."); for (let t = 0; t < e.length; t++) { const v = e[t]; this.vertices.push(r[v.a], r[v.b], r[v.c]); const y = v.vertexNormals; if (3 === y.length) this.normals.push(y[0], y[1], y[2]); else { const t = v.normal; this.normals.push(t, t, t) } const x = v.vertexColors; if (3 === x.length) this.colors.push(x[0], x[1], x[2]); else { const t = v.color; this.colors.push(t, t, t) } if (!0 === i) { const e = n[0][t]; void 0 !== e ? this.uvs.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", t), this.uvs.push(new m, new m, new m)) } if (!0 === o) { const e = n[1][t]; void 0 !== e ? this.uvs2.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", t), this.uvs2.push(new m, new m, new m)) } for (let t = 0; t < a; t++) { const e = s[t].vertices; c[t].data.push(e[v.a], e[v.b], e[v.c]) } for (let e = 0; e < l; e++) { const r = u[e].vertexNormals[t]; h[e].data.push(r.a, r.b, r.c) } d && this.skinIndices.push(f[v.a], f[v.b], f[v.c]), g && this.skinWeights.push(p[v.a], p[v.b], p[v.c]) } return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this } } function Jt(t) { if (0 === t.length) return -1 / 0; let e = t[0]; for (let r = 1, n = t.length; r < n; ++r)t[r] > e && (e = t[r]); return e } let Qt = 1; const $t = new K, te = new It, ee = new S, re = new E, ne = new E, ie = new S; function oe() { Object.defineProperty(this, "id", { value: Qt += 2 }), this.uuid = p.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } oe.prototype = Object.assign(Object.create(d.prototype), { constructor: oe, isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (t) { Array.isArray(t) ? this.index = new (Jt(t) > 65535 ? Xt : Wt)(t, 1) : this.index = t }, getAttribute: function (t) { return this.attributes[t] }, setAttribute: function (t, e) { return this.attributes[t] = e, this }, deleteAttribute: function (t) { return delete this.attributes[t], this }, addGroup: function (t, e, r) { this.groups.push({ start: t, count: e, materialIndex: void 0 !== r ? r : 0 }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (t, e) { this.drawRange.start = t, this.drawRange.count = e }, applyMatrix4: function (t) { const e = this.attributes.position; void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0); const r = this.attributes.normal; if (void 0 !== r) { const e = (new g).getNormalMatrix(t); r.applyNormalMatrix(e), r.needsUpdate = !0 } const n = this.attributes.tangent; return void 0 !== n && (n.transformDirection(t), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: function (t) { return $t.makeRotationX(t), this.applyMatrix4($t), this }, rotateY: function (t) { return $t.makeRotationY(t), this.applyMatrix4($t), this }, rotateZ: function (t) { return $t.makeRotationZ(t), this.applyMatrix4($t), this }, translate: function (t, e, r) { return $t.makeTranslation(t, e, r), this.applyMatrix4($t), this }, scale: function (t, e, r) { return $t.makeScale(t, e, r), this.applyMatrix4($t), this }, lookAt: function (t) { return te.lookAt(t), te.updateMatrix(), this.applyMatrix4(te.matrix), this }, center: function () { return this.computeBoundingBox(), this.boundingBox.getCenter(ee).negate(), this.translate(ee.x, ee.y, ee.z), this }, setFromObject: function (t) { const e = t.geometry; if (t.isPoints || t.isLine) { const t = new Yt(3 * e.vertices.length, 3), r = new Yt(3 * e.colors.length, 3); if (this.setAttribute("position", t.copyVector3sArray(e.vertices)), this.setAttribute("color", r.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) { const t = new Yt(e.lineDistances.length, 1); this.setAttribute("lineDistance", t.copyArray(e.lineDistances)) } null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()) } else t.isMesh && e && e.isGeometry && this.fromGeometry(e); return this }, setFromPoints: function (t) { const e = []; for (let r = 0, n = t.length; r < n; r++) { const n = t[r]; e.push(n.x, n.y, n.z || 0) } return this.setAttribute("position", new Yt(e, 3)), this }, updateFromObject: function (t) { let e = t.geometry; if (t.isMesh) { let t = e.__directGeometry; if (!0 === e.elementsNeedUpdate && (t = void 0, e.elementsNeedUpdate = !1), void 0 === t) return this.fromGeometry(e); t.verticesNeedUpdate = e.verticesNeedUpdate, t.normalsNeedUpdate = e.normalsNeedUpdate, t.colorsNeedUpdate = e.colorsNeedUpdate, t.uvsNeedUpdate = e.uvsNeedUpdate, t.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = t } if (!0 === e.verticesNeedUpdate) { const t = this.attributes.position; void 0 !== t && (t.copyVector3sArray(e.vertices), t.needsUpdate = !0), e.verticesNeedUpdate = !1 } if (!0 === e.normalsNeedUpdate) { const t = this.attributes.normal; void 0 !== t && (t.copyVector3sArray(e.normals), t.needsUpdate = !0), e.normalsNeedUpdate = !1 } if (!0 === e.colorsNeedUpdate) { const t = this.attributes.color; void 0 !== t && (t.copyColorsArray(e.colors), t.needsUpdate = !0), e.colorsNeedUpdate = !1 } if (e.uvsNeedUpdate) { const t = this.attributes.uv; void 0 !== t && (t.copyVector2sArray(e.uvs), t.needsUpdate = !0), e.uvsNeedUpdate = !1 } if (e.lineDistancesNeedUpdate) { const t = this.attributes.lineDistance; void 0 !== t && (t.copyArray(e.lineDistances), t.needsUpdate = !0), e.lineDistancesNeedUpdate = !1 } return e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this }, fromGeometry: function (t) { return t.__directGeometry = (new Kt).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry) }, fromDirectGeometry: function (t) { const e = new Float32Array(3 * t.vertices.length); if (this.setAttribute("position", new Ft(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) { const e = new Float32Array(3 * t.normals.length); this.setAttribute("normal", new Ft(e, 3).copyVector3sArray(t.normals)) } if (t.colors.length > 0) { const e = new Float32Array(3 * t.colors.length); this.setAttribute("color", new Ft(e, 3).copyColorsArray(t.colors)) } if (t.uvs.length > 0) { const e = new Float32Array(2 * t.uvs.length); this.setAttribute("uv", new Ft(e, 2).copyVector2sArray(t.uvs)) } if (t.uvs2.length > 0) { const e = new Float32Array(2 * t.uvs2.length); this.setAttribute("uv2", new Ft(e, 2).copyVector2sArray(t.uvs2)) } this.groups = t.groups; for (const e in t.morphTargets) { const r = [], n = t.morphTargets[e]; for (let t = 0, e = n.length; t < e; t++) { const e = n[t], i = new Yt(3 * e.data.length, 3); i.name = e.name, r.push(i.copyVector3sArray(e.data)) } this.morphAttributes[e] = r } if (t.skinIndices.length > 0) { const e = new Yt(4 * t.skinIndices.length, 4); this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices)) } if (t.skinWeights.length > 0) { const e = new Yt(4 * t.skinWeights.length, 4); this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights)) } return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new E); const t = this.attributes.position, e = this.morphAttributes.position; if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new S(-1 / 0, -1 / 0, -1 / 0), new S(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== t) { if (this.boundingBox.setFromBufferAttribute(t), e) for (let t = 0, r = e.length; t < r; t++) { const r = e[t]; re.setFromBufferAttribute(r), this.morphTargetsRelative ? (ie.addVectors(this.boundingBox.min, re.min), this.boundingBox.expandByPoint(ie), ie.addVectors(this.boundingBox.max, re.max), this.boundingBox.expandByPoint(ie)) : (this.boundingBox.expandByPoint(re.min), this.boundingBox.expandByPoint(re.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new G); const t = this.attributes.position, e = this.morphAttributes.position; if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new S, 1 / 0); if (t) { const r = this.boundingSphere.center; if (re.setFromBufferAttribute(t), e) for (let t = 0, r = e.length; t < r; t++) { const r = e[t]; ne.setFromBufferAttribute(r), this.morphTargetsRelative ? (ie.addVectors(re.min, ne.min), re.expandByPoint(ie), ie.addVectors(re.max, ne.max), re.expandByPoint(ie)) : (re.expandByPoint(ne.min), re.expandByPoint(ne.max)) } re.getCenter(r); let n = 0; for (let e = 0, i = t.count; e < i; e++)ie.fromBufferAttribute(t, e), n = Math.max(n, r.distanceToSquared(ie)); if (e) for (let i = 0, o = e.length; i < o; i++) { const o = e[i], s = this.morphTargetsRelative; for (let e = 0, i = o.count; e < i; e++)ie.fromBufferAttribute(o, e), s && (ee.fromBufferAttribute(t, e), ie.add(ee)), n = Math.max(n, r.distanceToSquared(ie)) } this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } }, computeFaceNormals: function () { }, computeVertexNormals: function () { const t = this.index, e = this.getAttribute("position"); if (void 0 !== e) { let r = this.getAttribute("normal"); if (void 0 === r) r = new Ft(new Float32Array(3 * e.count), 3), this.setAttribute("normal", r); else for (let t = 0, e = r.count; t < e; t++)r.setXYZ(t, 0, 0, 0); const n = new S, i = new S, o = new S, s = new S, a = new S, c = new S, u = new S, l = new S; if (t) for (let h = 0, f = t.count; h < f; h += 3) { const f = t.getX(h + 0), p = t.getX(h + 1), d = t.getX(h + 2); n.fromBufferAttribute(e, f), i.fromBufferAttribute(e, p), o.fromBufferAttribute(e, d), u.subVectors(o, i), l.subVectors(n, i), u.cross(l), s.fromBufferAttribute(r, f), a.fromBufferAttribute(r, p), c.fromBufferAttribute(r, d), s.add(u), a.add(u), c.add(u), r.setXYZ(f, s.x, s.y, s.z), r.setXYZ(p, a.x, a.y, a.z), r.setXYZ(d, c.x, c.y, c.z) } else for (let t = 0, s = e.count; t < s; t += 3)n.fromBufferAttribute(e, t + 0), i.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), u.subVectors(o, i), l.subVectors(n, i), u.cross(l), r.setXYZ(t + 0, u.x, u.y, u.z), r.setXYZ(t + 1, u.x, u.y, u.z), r.setXYZ(t + 2, u.x, u.y, u.z); this.normalizeNormals(), r.needsUpdate = !0 } }, merge: function (t, e) { if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t); void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); const r = this.attributes; for (const n in r) { if (void 0 === t.attributes[n]) continue; const i = r[n].array, o = t.attributes[n], s = o.array, a = o.itemSize * e, c = Math.min(s.length, i.length - a); for (let t = 0, e = a; t < c; t++, e++)i[e] = s[t] } return this }, normalizeNormals: function () { const t = this.attributes.normal; for (let e = 0, r = t.count; e < r; e++)ie.fromBufferAttribute(t, e), ie.normalize(), t.setXYZ(e, ie.x, ie.y, ie.z) }, toNonIndexed: function () { function t(t, e) { const r = t.array, n = t.itemSize, i = t.normalized, o = new r.constructor(e.length * n); let s = 0, a = 0; for (let t = 0, i = e.length; t < i; t++) { s = e[t] * n; for (let t = 0; t < n; t++)o[a++] = r[s++] } return new Ft(o, n, i) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; const e = new oe, r = this.index.array, n = this.attributes; for (const i in n) { const o = t(n[i], r); e.setAttribute(i, o) } const i = this.morphAttributes; for (const n in i) { const o = [], s = i[n]; for (let e = 0, n = s.length; e < n; e++) { const n = t(s[e], r); o.push(n) } e.morphAttributes[n] = o } e.morphTargetsRelative = this.morphTargetsRelative; const o = this.groups; for (let t = 0, r = o.length; t < r; t++) { const r = o[t]; e.addGroup(r.start, r.count, r.materialIndex) } return e }, toJSON: function () { const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) { const e = this.parameters; for (const r in e) void 0 !== e[r] && (t[r] = e[r]); return t } t.data = { attributes: {} }; const e = this.index; null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) }); const r = this.attributes; for (const e in r) { const n = r[e], i = n.toJSON(t.data); "" !== n.name && (i.name = n.name), t.data.attributes[e] = i } const n = {}; let i = !1; for (const e in this.morphAttributes) { const r = this.morphAttributes[e], o = []; for (let e = 0, n = r.length; e < n; e++) { const n = r[e], i = n.toJSON(t.data); "" !== n.name && (i.name = n.name), o.push(i) } o.length > 0 && (n[e] = o, i = !0) } i && (t.data.morphAttributes = n, t.data.morphTargetsRelative = this.morphTargetsRelative); const o = this.groups; o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o))); const s = this.boundingSphere; return null !== s && (t.data.boundingSphere = { center: s.center.toArray(), radius: s.radius }), t }, clone: function () { return (new oe).copy(this) }, copy: function (t) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const e = {}; this.name = t.name; const r = t.index; null !== r && this.setIndex(r.clone(e)); const n = t.attributes; for (const t in n) { const r = n[t]; this.setAttribute(t, r.clone(e)) } const i = t.morphAttributes; for (const t in i) { const r = [], n = i[t]; for (let t = 0, i = n.length; t < i; t++)r.push(n[t].clone(e)); this.morphAttributes[t] = r } this.morphTargetsRelative = t.morphTargetsRelative; const o = t.groups; for (let t = 0, e = o.length; t < e; t++) { const e = o[t]; this.addGroup(e.start, e.count, e.materialIndex) } const s = t.boundingBox; null !== s && (this.boundingBox = s.clone()); const a = t.boundingSphere; return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); class se extends oe { constructor(t = 1, e = 1, r = 1, n = 1, i = 1, o = 1) { super(), this.type = "BoxBufferGeometry", this.parameters = { width: t, height: e, depth: r, widthSegments: n, heightSegments: i, depthSegments: o }; const s = this; n = Math.floor(n), i = Math.floor(i), o = Math.floor(o); const a = [], c = [], u = [], l = []; let h = 0, f = 0; function p(t, e, r, n, i, o, p, d, m, g, v) { const y = o / m, x = p / g, b = o / 2, w = p / 2, M = d / 2, _ = m + 1, T = g + 1; let E = 0, A = 0; const R = new S; for (let o = 0; o < T; o++) { const s = o * x - w; for (let a = 0; a < _; a++) { const h = a * y - b; R[t] = h * n, R[e] = s * i, R[r] = M, c.push(R.x, R.y, R.z), R[t] = 0, R[e] = 0, R[r] = d > 0 ? 1 : -1, u.push(R.x, R.y, R.z), l.push(a / m), l.push(1 - o / g), E += 1 } } for (let t = 0; t < g; t++)for (let e = 0; e < m; e++) { const r = h + e + _ * t, n = h + e + _ * (t + 1), i = h + (e + 1) + _ * (t + 1), o = h + (e + 1) + _ * t; a.push(r, n, o), a.push(n, i, o), A += 6 } s.addGroup(f, A, v), f += A, h += E } p("z", "y", "x", -1, -1, r, e, t, o, i, 0), p("z", "y", "x", 1, -1, r, e, -t, o, i, 1), p("x", "z", "y", 1, 1, t, r, e, n, o, 2), p("x", "z", "y", 1, -1, t, r, -e, n, o, 3), p("x", "y", "z", 1, -1, t, e, r, n, i, 4), p("x", "y", "z", -1, -1, t, e, -r, n, i, 5), this.setIndex(a), this.setAttribute("position", new Yt(c, 3)), this.setAttribute("normal", new Yt(u, 3)), this.setAttribute("uv", new Yt(l, 2)) } } class ae extends oe { constructor(t, e, r, n) { super(), this.type = "PlaneBufferGeometry", this.parameters = { width: t, height: e, widthSegments: r, heightSegments: n }; const i = (t = t || 1) / 2, o = (e = e || 1) / 2, s = Math.floor(r) || 1, a = Math.floor(n) || 1, c = s + 1, u = a + 1, l = t / s, h = e / a, f = [], p = [], d = [], m = []; for (let t = 0; t < u; t++) { const e = t * h - o; for (let r = 0; r < c; r++) { const n = r * l - i; p.push(n, -e, 0), d.push(0, 0, 1), m.push(r / s), m.push(1 - t / a) } } for (let t = 0; t < a; t++)for (let e = 0; e < s; e++) { const r = e + c * t, n = e + c * (t + 1), i = e + 1 + c * (t + 1), o = e + 1 + c * t; f.push(r, n, o), f.push(n, i, o) } this.setIndex(f), this.setAttribute("position", new Yt(p, 3)), this.setAttribute("normal", new Yt(d, 3)), this.setAttribute("uv", new Yt(m, 2)) } } let ce = 0; function ue() { Object.defineProperty(this, "id", { value: ce++ }), this.uuid = p.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 } function le(t) { const e = {}; for (const r in t) { e[r] = {}; for (const n in t[r]) { const i = t[r][n]; i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? e[r][n] = i.clone() : Array.isArray(i) ? e[r][n] = i.slice() : e[r][n] = i } } return e } function he(t) { const e = {}; for (let r = 0; r < t.length; r++) { const n = le(t[r]); for (const t in n) e[t] = n[t] } return e } ue.prototype = Object.assign(Object.create(d.prototype), { constructor: ue, isMaterial: !0, onBeforeCompile: function () { }, customProgramCacheKey: function () { return this.onBeforeCompile.toString() }, setValues: function (t) { if (void 0 !== t) for (const e in t) { const r = t[e]; if (void 0 === r) { console.warn("THREE.Material: '" + e + "' parameter is undefined."); continue } if ("shading" === e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === r; continue } const n = this[e]; void 0 !== n ? n && n.isColor ? n.set(r) : n && n.isVector3 && r && r.isVector3 ? n.copy(r) : this[e] = r : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") } }, toJSON: function (t) { const e = void 0 === t || "string" == typeof t; e && (t = { textures: {}, images: {} }); const r = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function n(t) { const e = []; for (const r in t) { const n = t[r]; delete n.metadata, e.push(n) } return e } if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), void 0 !== this.roughness && (r.roughness = this.roughness), void 0 !== this.metalness && (r.metalness = this.metalness), this.sheen && this.sheen.isColor && (r.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), void 0 !== this.shininess && (r.shininess = this.shininess), void 0 !== this.clearcoat && (r.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (r.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(t).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(t).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(t).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(t).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(t).uuid, r.reflectivity = this.reflectivity, r.refractionRatio = this.refractionRatio, void 0 !== this.combine && (r.combine = this.combine), void 0 !== this.envMapIntensity && (r.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (r.size = this.size), void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (r.blending = this.blending), !0 === this.flatShading && (r.flatShading = this.flatShading), 0 !== this.side && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), !0 === this.transparent && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (r.rotation = this.rotation), !0 === this.polygonOffset && (r.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (r.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (r.linewidth = this.linewidth), void 0 !== this.dashSize && (r.dashSize = this.dashSize), void 0 !== this.gapSize && (r.gapSize = this.gapSize), void 0 !== this.scale && (r.scale = this.scale), !0 === this.dithering && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (r.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (r.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (r.morphTargets = !0), !0 === this.morphNormals && (r.morphNormals = !0), !0 === this.skinning && (r.skinning = !0), !1 === this.visible && (r.visible = !1), !1 === this.toneMapped && (r.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), e) { const e = n(t.textures), i = n(t.images); e.length > 0 && (r.textures = e), i.length > 0 && (r.images = i) } return r }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite; const e = t.clippingPlanes; let r = null; if (null !== e) { const t = e.length; r = new Array(t); for (let n = 0; n !== t; ++n)r[n] = e[n].clone() } return this.clippingPlanes = r, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(ue.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }); const fe = { clone: le, merge: he }; function pe(t) { ue.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}", this.fragmentShader = "void main(){gl_FragColor=vec4(1.0,0.0,0.0,1.0);}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) } pe.prototype = Object.create(ue.prototype), pe.prototype.constructor = pe, pe.prototype.isShaderMaterial = !0, pe.prototype.copy = function (t) { return ue.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = le(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this }, pe.prototype.toJSON = function (t) { const e = ue.prototype.toJSON.call(this, t); e.glslVersion = this.glslVersion, e.uniforms = {}; for (const r in this.uniforms) { const n = this.uniforms[r].value; n && n.isTexture ? e.uniforms[r] = { type: "t", value: n.toJSON(t).uuid } : n && n.isColor ? e.uniforms[r] = { type: "c", value: n.getHex() } : n && n.isVector2 ? e.uniforms[r] = { type: "v2", value: n.toArray() } : n && n.isVector3 ? e.uniforms[r] = { type: "v3", value: n.toArray() } : n && n.isVector4 ? e.uniforms[r] = { type: "v4", value: n.toArray() } : n && n.isMatrix3 ? e.uniforms[r] = { type: "m3", value: n.toArray() } : n && n.isMatrix4 ? e.uniforms[r] = { type: "m4", value: n.toArray() } : e.uniforms[r] = { value: n } } Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader; const r = {}; for (const t in this.extensions) !0 === this.extensions[t] && (r[t] = !0); return Object.keys(r).length > 0 && (e.extensions = r), e }; const de = new S, me = new S, ge = new S, ve = new S, ye = new S, xe = new S, be = new S; class we { constructor(t, e) { this.origin = void 0 !== t ? t : new S, this.direction = void 0 !== e ? e : new S(0, 0, -1) } set(t, e) { return this.origin.copy(t), this.direction.copy(e), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this } at(t, e) { return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new S), e.copy(this.direction).multiplyScalar(t).add(this.origin) } lookAt(t) { return this.direction.copy(t).sub(this.origin).normalize(), this } recast(t) { return this.origin.copy(this.at(t, de)), this } closestPointToPoint(t, e) { void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new S), e.subVectors(t, this.origin); const r = e.dot(this.direction); return r < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(r).add(this.origin) } distanceToPoint(t) { return Math.sqrt(this.distanceSqToPoint(t)) } distanceSqToPoint(t) { const e = de.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (de.copy(this.direction).multiplyScalar(e).add(this.origin), de.distanceToSquared(t)) } distanceSqToSegment(t, e, r, n) { me.copy(t).add(e).multiplyScalar(.5), ge.copy(e).sub(t).normalize(), ve.copy(this.origin).sub(me); const i = .5 * t.distanceTo(e), o = -this.direction.dot(ge), s = ve.dot(this.direction), a = -ve.dot(ge), c = ve.lengthSq(), u = Math.abs(1 - o * o); let l, h, f, p; if (u > 0) if (l = o * a - s, h = o * s - a, p = i * u, l >= 0) if (h >= -p) if (h <= p) { const t = 1 / u; l *= t, h *= t, f = l * (l + o * h + 2 * s) + h * (o * l + h + 2 * a) + c } else h = i, l = Math.max(0, -(o * h + s)), f = -l * l + h * (h + 2 * a) + c; else h = -i, l = Math.max(0, -(o * h + s)), f = -l * l + h * (h + 2 * a) + c; else h <= -p ? (l = Math.max(0, -(-o * i + s)), h = l > 0 ? -i : Math.min(Math.max(-i, -a), i), f = -l * l + h * (h + 2 * a) + c) : h <= p ? (l = 0, h = Math.min(Math.max(-i, -a), i), f = h * (h + 2 * a) + c) : (l = Math.max(0, -(o * i + s)), h = l > 0 ? i : Math.min(Math.max(-i, -a), i), f = -l * l + h * (h + 2 * a) + c); else h = o > 0 ? -i : i, l = Math.max(0, -(o * h + s)), f = -l * l + h * (h + 2 * a) + c; return r && r.copy(this.direction).multiplyScalar(l).add(this.origin), n && n.copy(ge).multiplyScalar(h).add(me), f } intersectSphere(t, e) { de.subVectors(t.center, this.origin); const r = de.dot(this.direction), n = de.dot(de) - r * r, i = t.radius * t.radius; if (n > i) return null; const o = Math.sqrt(i - n), s = r - o, a = r + o; return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e) } intersectsSphere(t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius } distanceToPlane(t) { const e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; const r = -(this.origin.dot(t.normal) + t.constant) / e; return r >= 0 ? r : null } intersectPlane(t, e) { const r = this.distanceToPlane(t); return null === r ? null : this.at(r, e) } intersectsPlane(t) { const e = t.distanceToPoint(this.origin); if (0 === e) return !0; return t.normal.dot(this.direction) * e < 0 } intersectBox(t, e) { let r, n, i, o, s, a; const c = 1 / this.direction.x, u = 1 / this.direction.y, l = 1 / this.direction.z, h = this.origin; return c >= 0 ? (r = (t.min.x - h.x) * c, n = (t.max.x - h.x) * c) : (r = (t.max.x - h.x) * c, n = (t.min.x - h.x) * c), u >= 0 ? (i = (t.min.y - h.y) * u, o = (t.max.y - h.y) * u) : (i = (t.max.y - h.y) * u, o = (t.min.y - h.y) * u), r > o || i > n ? null : ((i > r || r != r) && (r = i), (o < n || n != n) && (n = o), l >= 0 ? (s = (t.min.z - h.z) * l, a = (t.max.z - h.z) * l) : (s = (t.max.z - h.z) * l, a = (t.min.z - h.z) * l), r > a || s > n ? null : ((s > r || r != r) && (r = s), (a < n || n != n) && (n = a), n < 0 ? null : this.at(r >= 0 ? r : n, e))) } intersectsBox(t) { return null !== this.intersectBox(t, de) } intersectTriangle(t, e, r, n, i) { ye.subVectors(e, t), xe.subVectors(r, t), be.crossVectors(ye, xe); let o, s = this.direction.dot(be); if (s > 0) { if (n) return null; o = 1 } else { if (!(s < 0)) return null; o = -1, s = -s } ve.subVectors(this.origin, t); const a = o * this.direction.dot(xe.crossVectors(ve, xe)); if (a < 0) return null; const c = o * this.direction.dot(ye.cross(ve)); if (c < 0) return null; if (a + c > s) return null; const u = -o * ve.dot(be); return u < 0 ? null : this.at(u / s, i) } applyMatrix4(t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this } equals(t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } } const Me = new S, Se = new S, _e = new S, Te = new S, Ee = new S, Ae = new S, Re = new S, Le = new S, Oe = new S, Pe = new S; class Ie { constructor(t, e, r) { this.a = void 0 !== t ? t : new S, this.b = void 0 !== e ? e : new S, this.c = void 0 !== r ? r : new S } static getNormal(t, e, r, n) { void 0 === n && (console.warn("THREE.Triangle: .getNormal() target is now required"), n = new S), n.subVectors(r, e), Me.subVectors(t, e), n.cross(Me); const i = n.lengthSq(); return i > 0 ? n.multiplyScalar(1 / Math.sqrt(i)) : n.set(0, 0, 0) } static getBarycoord(t, e, r, n, i) { Me.subVectors(n, e), Se.subVectors(r, e), _e.subVectors(t, e); const o = Me.dot(Me), s = Me.dot(Se), a = Me.dot(_e), c = Se.dot(Se), u = Se.dot(_e), l = o * c - s * s; if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new S), 0 === l) return i.set(-2, -1, -1); const h = 1 / l, f = (c * a - s * u) * h, p = (o * u - s * a) * h; return i.set(1 - f - p, p, f) } static containsPoint(t, e, r, n) { return this.getBarycoord(t, e, r, n, Te), Te.x >= 0 && Te.y >= 0 && Te.x + Te.y <= 1 } static getUV(t, e, r, n, i, o, s, a) { return this.getBarycoord(t, e, r, n, Te), a.set(0, 0), a.addScaledVector(i, Te.x), a.addScaledVector(o, Te.y), a.addScaledVector(s, Te.z), a } static isFrontFacing(t, e, r, n) { return Me.subVectors(r, e), Se.subVectors(t, e), Me.cross(Se).dot(n) < 0 } set(t, e, r) { return this.a.copy(t), this.b.copy(e), this.c.copy(r), this } setFromPointsAndIndices(t, e, r, n) { return this.a.copy(t[e]), this.b.copy(t[r]), this.c.copy(t[n]), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this } getArea() { return Me.subVectors(this.c, this.b), Se.subVectors(this.a, this.b), .5 * Me.cross(Se).length() } getMidpoint(t) { return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new S), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(t) { return Ie.getNormal(this.a, this.b, this.c, t) } getPlane(t) { return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new q), t.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(t, e) { return Ie.getBarycoord(t, this.a, this.b, this.c, e) } getUV(t, e, r, n, i) { return Ie.getUV(t, this.a, this.b, this.c, e, r, n, i) } containsPoint(t) { return Ie.containsPoint(t, this.a, this.b, this.c) } isFrontFacing(t) { return Ie.isFrontFacing(this.a, this.b, this.c, t) } intersectsBox(t) { return t.intersectsTriangle(this) } closestPointToPoint(t, e) { void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new S); const r = this.a, n = this.b, i = this.c; let o, s; Ee.subVectors(n, r), Ae.subVectors(i, r), Le.subVectors(t, r); const a = Ee.dot(Le), c = Ae.dot(Le); if (a <= 0 && c <= 0) return e.copy(r); Oe.subVectors(t, n); const u = Ee.dot(Oe), l = Ae.dot(Oe); if (u >= 0 && l <= u) return e.copy(n); const h = a * l - u * c; if (h <= 0 && a >= 0 && u <= 0) return o = a / (a - u), e.copy(r).addScaledVector(Ee, o); Pe.subVectors(t, i); const f = Ee.dot(Pe), p = Ae.dot(Pe); if (p >= 0 && f <= p) return e.copy(i); const d = f * c - a * p; if (d <= 0 && c >= 0 && p <= 0) return s = c / (c - p), e.copy(r).addScaledVector(Ae, s); const m = u * p - f * l; if (m <= 0 && l - u >= 0 && f - p >= 0) return Re.subVectors(i, n), s = (l - u) / (l - u + (f - p)), e.copy(n).addScaledVector(Re, s); const g = 1 / (m + d + h); return o = d * g, s = h * g, e.copy(r).addScaledVector(Ee, o).addScaledVector(Ae, s) } equals(t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } } function Ce(t) { ue.call(this), this.type = "MeshBasicMaterial", this.color = new pt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t) } Ce.prototype = Object.create(ue.prototype), Ce.prototype.constructor = Ce, Ce.prototype.isMeshBasicMaterial = !0, Ce.prototype.copy = function (t) { return ue.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this }; const ke = new K, Ne = new we, ze = new G, Ue = new S, je = new S, Be = new S, Fe = new S, De = new S, Ge = new S, Ve = new S, He = new S, We = new S, qe = new m, Xe = new m, Ye = new m, Ze = new S, Ke = new S; function Je(t, e) { It.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new oe, this.material = void 0 !== e ? e : new Ce, this.updateMorphTargets() } function Qe(t, e, r, n, i, o, s, a) { let c; if (c = 1 === e.side ? n.intersectTriangle(s, o, i, !0, a) : n.intersectTriangle(i, o, s, 2 !== e.side, a), null === c) return null; Ke.copy(a), Ke.applyMatrix4(t.matrixWorld); const u = r.ray.origin.distanceTo(Ke); return u < r.near || u > r.far ? null : { distance: u, point: Ke.clone(), object: t } } function $e(t, e, r, n, i, o, s, a, c, u, l, h) { Ue.fromBufferAttribute(i, u), je.fromBufferAttribute(i, l), Be.fromBufferAttribute(i, h); const f = t.morphTargetInfluences; if (e.morphTargets && o && f) { Ve.set(0, 0, 0), He.set(0, 0, 0), We.set(0, 0, 0); for (let t = 0, e = o.length; t < e; t++) { const e = f[t], r = o[t]; 0 !== e && (Fe.fromBufferAttribute(r, u), De.fromBufferAttribute(r, l), Ge.fromBufferAttribute(r, h), s ? (Ve.addScaledVector(Fe, e), He.addScaledVector(De, e), We.addScaledVector(Ge, e)) : (Ve.addScaledVector(Fe.sub(Ue), e), He.addScaledVector(De.sub(je), e), We.addScaledVector(Ge.sub(Be), e))) } Ue.add(Ve), je.add(He), Be.add(We) } t.isSkinnedMesh && (t.boneTransform(u, Ue), t.boneTransform(l, je), t.boneTransform(h, Be)); const p = Qe(t, e, r, n, Ue, je, Be, Ze); if (p) { a && (qe.fromBufferAttribute(a, u), Xe.fromBufferAttribute(a, l), Ye.fromBufferAttribute(a, h), p.uv = Ie.getUV(Ze, Ue, je, Be, qe, Xe, Ye, new m)), c && (qe.fromBufferAttribute(c, u), Xe.fromBufferAttribute(c, l), Ye.fromBufferAttribute(c, h), p.uv2 = Ie.getUV(Ze, Ue, je, Be, qe, Xe, Ye, new m)); const t = new dt(u, l, h); Ie.getNormal(Ue, je, Be, t.normal), p.face = t } return p } Je.prototype = Object.assign(Object.create(It.prototype), { constructor: Je, isMesh: !0, copy: function (t) { return It.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this }, updateMorphTargets: function () { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, r = Object.keys(e); if (r.length > 0) { const t = e[r[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, r = t.length; e < r; e++) { const r = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } }, raycast: function (t, e) { const r = this.geometry, n = this.material, i = this.matrixWorld; if (void 0 === n) return; if (null === r.boundingSphere && r.computeBoundingSphere(), ze.copy(r.boundingSphere), ze.applyMatrix4(i), !1 === t.ray.intersectsSphere(ze)) return; if (ke.getInverse(i), Ne.copy(t.ray).applyMatrix4(ke), null !== r.boundingBox && !1 === Ne.intersectsBox(r.boundingBox)) return; let o; if (r.isBufferGeometry) { const i = r.index, s = r.attributes.position, a = r.morphAttributes.position, c = r.morphTargetsRelative, u = r.attributes.uv, l = r.attributes.uv2, h = r.groups, f = r.drawRange; if (null !== i) if (Array.isArray(n)) for (let r = 0, p = h.length; r < p; r++) { const p = h[r], d = n[p.materialIndex]; for (let r = Math.max(p.start, f.start), n = Math.min(p.start + p.count, f.start + f.count); r < n; r += 3) { const n = i.getX(r), h = i.getX(r + 1), f = i.getX(r + 2); o = $e(this, d, t, Ne, s, a, c, u, l, n, h, f), o && (o.faceIndex = Math.floor(r / 3), o.face.materialIndex = p.materialIndex, e.push(o)) } } else { for (let r = Math.max(0, f.start), h = Math.min(i.count, f.start + f.count); r < h; r += 3) { const h = i.getX(r), f = i.getX(r + 1), p = i.getX(r + 2); o = $e(this, n, t, Ne, s, a, c, u, l, h, f, p), o && (o.faceIndex = Math.floor(r / 3), e.push(o)) } } else if (void 0 !== s) if (Array.isArray(n)) for (let r = 0, i = h.length; r < i; r++) { const i = h[r], p = n[i.materialIndex]; for (let r = Math.max(i.start, f.start), n = Math.min(i.start + i.count, f.start + f.count); r < n; r += 3) { o = $e(this, p, t, Ne, s, a, c, u, l, r, r + 1, r + 2), o && (o.faceIndex = Math.floor(r / 3), o.face.materialIndex = i.materialIndex, e.push(o)) } } else { for (let r = Math.max(0, f.start), i = Math.min(s.count, f.start + f.count); r < i; r += 3) { o = $e(this, n, t, Ne, s, a, c, u, l, r, r + 1, r + 2), o && (o.faceIndex = Math.floor(r / 3), e.push(o)) } } } else if (r.isGeometry) { const i = Array.isArray(n), s = r.vertices, a = r.faces; let c; const u = r.faceVertexUvs[0]; u.length > 0 && (c = u); for (let r = 0, u = a.length; r < u; r++) { const u = a[r], l = i ? n[u.materialIndex] : n; if (void 0 === l) continue; const h = s[u.a], f = s[u.b], p = s[u.c]; if (o = Qe(this, l, t, Ne, h, f, p, Ze), o) { if (c && c[r]) { const t = c[r]; qe.copy(t[0]), Xe.copy(t[1]), Ye.copy(t[2]), o.uv = Ie.getUV(Ze, h, f, p, qe, Xe, Ye, new m) } o.face = u, o.faceIndex = r, e.push(o) } } } } }); const tr = { alphamap_fragment: "", alphamap_pars_fragment: "", alphatest_fragment: "", aomap_fragment: "", aomap_pars_fragment: "", begin_vertex: "", beginnormal_vertex: "", bsdfs: "", bumpmap_pars_fragment: "", clipping_planes_fragment: "", clipping_planes_pars_fragment: "", clipping_planes_pars_vertex: "", clipping_planes_vertex: "", color_fragment: "", color_pars_fragment: "", color_pars_vertex: "", color_vertex: "", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a)clamp(a,0.0,1.0)\n#endif\n#define whiteComplement(a)(1.0-saturate(a))\nfloat pow2(const in float x){return x*x;}float pow3(const in float x){return x*x*x;}float pow4(const in float x){float x2=x*x;return x2*x2;}float average(const in vec3 color){return dot(color,vec3(0.3333));}highp float rand(const in vec2 uv){const highp float a=12.9898,b=78.233,c=43758.5453;highp float dt=dot(uv.xy,vec2(a,b)),sn=mod(dt,PI);return fract(sin(sn)*c);}\n#ifdef HIGH_PRECISION\nfloat precisionSafeLength(vec3 v){return length(v);}\n#else\nfloat max3(vec3 v){return max(max(v.x,v.y),v.z);}float precisionSafeLength(vec3 v){float maxComponent=max3(abs(v));return length(v/maxComponent)*maxComponent;}\n#endif\nstruct IncidentLight{vec3 color;vec3 direction;bool visible;};struct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct GeometricContext{vec3 position;vec3 normal;vec3 viewDir;\n#ifdef CLEARCOAT\nvec3 clearcoatNormal;\n#endif\n};vec3 transformDirection(in vec3 dir,in mat4 matrix){return normalize((matrix*vec4(dir,0.0)).xyz);}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}vec3 projectOnPlane(in vec3 point,in vec3 pointOnPlane,in vec3 planeNormal){float distance=dot(planeNormal,point-pointOnPlane);return-distance*planeNormal+point;}float sideOfPlane(in vec3 point,in vec3 pointOnPlane,in vec3 planeNormal){return sign(dot(point-pointOnPlane,planeNormal));}vec3 linePlaneIntersect(in vec3 pointOnLine,in vec3 lineDirection,in vec3 pointOnPlane,in vec3 planeNormal){return lineDirection*(dot(planeNormal,pointOnPlane-pointOnLine)/dot(planeNormal,lineDirection))+pointOnLine;}mat3 transposeMat3(const in mat3 m){mat3 tmp;tmp[0]=vec3(m[0].x,m[1].x,m[2].x);tmp[1]=vec3(m[0].y,m[1].y,m[2].y);tmp[2]=vec3(m[0].z,m[1].z,m[2].z);return tmp;}float linearToRelativeLuminance(const in vec3 color){vec3 weights=vec3(0.2126,0.7152,0.0722);return dot(weights,color.rgb);}bool isPerspectiveMatrix(mat4 m){return m[2][3]==-1.0;}vec2 equirectUv(in vec3 dir){float u=atan(dir.z,dir.x)*RECIPROCAL_PI2+0.5;float v=asin(clamp(dir.y,-1.0,1.0))*RECIPROCAL_PI+0.5;return vec2(u,v);}", cube_uv_reflection_fragment: "", defaultnormal_vertex: "", displacementmap_pars_vertex: "", displacementmap_vertex: "", emissivemap_fragment: "", emissivemap_pars_fragment: "", encodings_fragment: "gl_FragColor=linearToOutputTexel(gl_FragColor);", encodings_pars_fragment: "vec4 LinearToLinear(in vec4 value){return value;}vec4 GammaToLinear(in vec4 value,in float gammaFactor){return vec4(pow(value.rgb,vec3(gammaFactor)),value.a);}vec4 LinearToGamma(in vec4 value,in float gammaFactor){return vec4(pow(value.rgb,vec3(1.0/gammaFactor)),value.a);}vec4 sRGBToLinear(in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}vec4 LinearTosRGB(in vec4 value){return vec4(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055),value.rgb*12.92,vec3(lessThanEqual(value.rgb,vec3(0.0031308)))),value.a);}vec4 RGBEToLinear(in vec4 value){return vec4(value.rgb*exp2(value.a*255.0-128.0),1.0);}vec4 LinearToRGBE(in vec4 value){float maxComponent=max(max(value.r,value.g),value.b);float fExp=clamp(ceil(log2(maxComponent)),-128.0,127.0);return vec4(value.rgb/exp2(fExp),(fExp+128.0)/255.0);}vec4 RGBMToLinear(in vec4 value,in float maxRange){return vec4(value.rgb*value.a*maxRange,1.0);}vec4 LinearToRGBM(in vec4 value,in float maxRange){float maxRGB=max(value.r,max(value.g,value.b));float M=clamp(maxRGB/maxRange,0.0,1.0);M=ceil(M*255.0)/255.0;return vec4(value.rgb/(M*maxRange),M);}vec4 RGBDToLinear(in vec4 value,in float maxRange){return vec4(value.rgb*((maxRange/255.0)/value.a),1.0);}vec4 LinearToRGBD(in vec4 value,in float maxRange){float maxRGB=max(value.r,max(value.g,value.b));float D=max(maxRange/maxRGB,1.0);D=clamp(floor(D)/255.0,0.0,1.0);return vec4(value.rgb*(D*(255.0/maxRange)),D);}const mat3 cLogLuvM=mat3(0.2209,0.3390,0.4184,0.1138,0.6780,0.7319,0.0102,0.1130,0.2969);vec4 LinearToLogLuv(in vec4 value){vec3 Xp_Y_XYZp=cLogLuvM*value.rgb;Xp_Y_XYZp=max(Xp_Y_XYZp,vec3(1e-6,1e-6,1e-6));vec4 vResult;vResult.xy=Xp_Y_XYZp.xy/Xp_Y_XYZp.z;float Le=2.0*log2(Xp_Y_XYZp.y)+127.0;vResult.w=fract(Le);vResult.z=(Le-(floor(vResult.w*255.0))/255.0)/255.0;return vResult;}const mat3 cLogLuvInverseM=mat3(6.0014,-2.7008,-1.7996,-1.3320,3.1029,-5.7721,0.3008,-1.0882,5.6268);vec4 LogLuvToLinear(in vec4 value){float Le=value.z*255.0+value.w;vec3 Xp_Y_XYZp;Xp_Y_XYZp.y=exp2((Le-127.0)/2.0);Xp_Y_XYZp.z=Xp_Y_XYZp.y/value.y;Xp_Y_XYZp.x=value.x*Xp_Y_XYZp.z;vec3 vRGB=cLogLuvInverseM*Xp_Y_XYZp.rgb;return vec4(max(vRGB,0.0),1.0);}", envmap_fragment: "", envmap_common_pars_fragment: "", envmap_pars_fragment: "", envmap_pars_vertex: "", envmap_physical_pars_fragment: "", envmap_vertex: "", fog_vertex: "", fog_pars_vertex: "", fog_fragment: "", fog_pars_fragment: "", gradientmap_pars_fragment: "", lightmap_fragment: "", lightmap_pars_fragment: "", lights_lambert_vertex: "", lights_pars_begin: "", lights_toon_fragment: "", lights_toon_pars_fragment: "", lights_phong_fragment: "", lights_phong_pars_fragment: "", lights_physical_fragment: "", lights_physical_pars_fragment: "", lights_fragment_begin: "", lights_fragment_maps: "", lights_fragment_end: "", logdepthbuf_fragment: "", logdepthbuf_pars_fragment: "", logdepthbuf_pars_vertex: "", logdepthbuf_vertex: "", map_fragment: "", map_pars_fragment: "", map_particle_fragment: "", map_particle_pars_fragment: "", metalnessmap_fragment: "", metalnessmap_pars_fragment: "", morphnormal_vertex: "", morphtarget_pars_vertex: "", morphtarget_vertex: "", normal_fragment_begin: "", normal_fragment_maps: "", normalmap_pars_fragment: "", clearcoat_normal_fragment_begin: "", clearcoat_normal_fragment_maps: "", clearcoat_pars_fragment: "", packing: "", premultiplied_alpha_fragment: "", project_vertex: "", dithering_fragment: "", dithering_pars_fragment: "", roughnessmap_fragment: "", roughnessmap_pars_fragment: "", shadowmap_pars_fragment: "", shadowmap_pars_vertex: "", shadowmap_vertex: "", shadowmask_pars_fragment: "", skinbase_vertex: "", skinning_pars_vertex: "", skinning_vertex: "", skinnormal_vertex: "", specularmap_fragment: "", specularmap_pars_fragment: "", tonemapping_fragment: "", tonemapping_pars_fragment: "", transmissionmap_fragment: "", transmissionmap_pars_fragment: "", uv_pars_fragment: "", uv_pars_vertex: "", uv_vertex: "", uv2_pars_fragment: "", uv2_pars_vertex: "", uv2_vertex: "", worldpos_vertex: "", background_frag: "", background_vert: "", cube_frag: "", cube_vert: "", depth_frag: "", depth_vert: "", distanceRGBA_frag: "", distanceRGBA_vert: "", equirect_frag: "", equirect_vert: "", linedashed_frag: "", linedashed_vert: "", meshbasic_frag: "", meshbasic_vert: "", meshlambert_frag: "", meshlambert_vert: "", meshmatcap_frag: "", meshmatcap_vert: "", meshtoon_frag: "", meshtoon_vert: "", meshphong_frag: "", meshphong_vert: "", meshphysical_frag: "", meshphysical_vert: "", normal_frag: "", normal_vert: "", points_frag: "", points_vert: "", shadow_frag: "", shadow_vert: "", sprite_frag: "", sprite_vert: "" }, er = { common: { diffuse: { value: new pt(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new g }, uv2Transform: { value: new g }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new m(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new pt(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new pt(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new g } }, sprite: { diffuse: { value: new pt(15658734) }, opacity: { value: 1 }, center: { value: new m(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new g } } }, rr = { basic: { uniforms: he([er.common, er.specularmap, er.envmap, er.aomap, er.lightmap, er.fog]), vertexShader: tr.meshbasic_vert, fragmentShader: tr.meshbasic_frag }, lambert: { uniforms: he([er.common, er.specularmap, er.envmap, er.aomap, er.lightmap, er.emissivemap, er.fog, er.lights, { emissive: { value: new pt(0) } }]), vertexShader: tr.meshlambert_vert, fragmentShader: tr.meshlambert_frag }, phong: { uniforms: he([er.common, er.specularmap, er.envmap, er.aomap, er.lightmap, er.emissivemap, er.bumpmap, er.normalmap, er.displacementmap, er.fog, er.lights, { emissive: { value: new pt(0) }, specular: { value: new pt(1118481) }, shininess: { value: 30 } }]), vertexShader: tr.meshphong_vert, fragmentShader: tr.meshphong_frag }, standard: { uniforms: he([er.common, er.envmap, er.aomap, er.lightmap, er.emissivemap, er.bumpmap, er.normalmap, er.displacementmap, er.roughnessmap, er.metalnessmap, er.fog, er.lights, { emissive: { value: new pt(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: tr.meshphysical_vert, fragmentShader: tr.meshphysical_frag }, toon: { uniforms: he([er.common, er.aomap, er.lightmap, er.emissivemap, er.bumpmap, er.normalmap, er.displacementmap, er.gradientmap, er.fog, er.lights, { emissive: { value: new pt(0) } }]), vertexShader: tr.meshtoon_vert, fragmentShader: tr.meshtoon_frag }, matcap: { uniforms: he([er.common, er.bumpmap, er.normalmap, er.displacementmap, er.fog, { matcap: { value: null } }]), vertexShader: tr.meshmatcap_vert, fragmentShader: tr.meshmatcap_frag }, points: { uniforms: he([er.points, er.fog]), vertexShader: tr.points_vert, fragmentShader: tr.points_frag }, dashed: { uniforms: he([er.common, er.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: tr.linedashed_vert, fragmentShader: tr.linedashed_frag }, depth: { uniforms: he([er.common, er.displacementmap]), vertexShader: tr.depth_vert, fragmentShader: tr.depth_frag }, normal: { uniforms: he([er.common, er.bumpmap, er.normalmap, er.displacementmap, { opacity: { value: 1 } }]), vertexShader: tr.normal_vert, fragmentShader: tr.normal_frag }, sprite: { uniforms: he([er.sprite, er.fog]), vertexShader: tr.sprite_vert, fragmentShader: tr.sprite_frag }, background: { uniforms: { uvTransform: { value: new g }, t2D: { value: null } }, vertexShader: tr.background_vert, fragmentShader: tr.background_frag }, cube: { uniforms: he([er.envmap, { opacity: { value: 1 } }]), vertexShader: tr.cube_vert, fragmentShader: tr.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: tr.equirect_vert, fragmentShader: tr.equirect_frag }, distanceRGBA: { uniforms: he([er.common, er.displacementmap, { referencePosition: { value: new S }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: tr.distanceRGBA_vert, fragmentShader: tr.distanceRGBA_frag }, shadow: { uniforms: he([er.lights, er.fog, { color: { value: new pt(0) }, opacity: { value: 1 } }]), vertexShader: tr.shadow_vert, fragmentShader: tr.shadow_frag } }; function nr(t, e, r, n, i) { const o = new pt(0); let s, a, c = 0, u = null, l = 0, h = null; function f(t, e) { r.buffers.color.setClear(t.r, t.g, t.b, e, i) } return { getClearColor: function () { return o }, setClearColor: function (t, e) { o.set(t), c = void 0 !== e ? e : 1, f(o, c) }, getClearAlpha: function () { return c }, setClearAlpha: function (t) { c = t, f(o, c) }, render: function (r, i, p, d) { let m = !0 === i.isScene ? i.background : null; m && m.isTexture && (m = e.get(m)); const g = t.xr, v = g.getSession && g.getSession(); v && "additive" === v.environmentBlendMode && (m = null), null === m ? f(o, c) : m && m.isColor && (f(m, 1), d = !0), (t.autoClear || d) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), m && (m.isCubeTexture || m.isWebGLCubeRenderTarget || m.isWebGLCubeRenderTargetTexture || 306 === m.mapping) ? (void 0 === a && (a = new Je(new se(1, 1, 1), new pe({ name: "BackgroundCubeMaterial", uniforms: le(rr.cube.uniforms), vertexShader: rr.cube.vertexShader, fragmentShader: rr.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function (t, e, r) { this.matrixWorld.copyPosition(r.matrixWorld) }, Object.defineProperty(a.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), n.update(a)), m.isWebGLCubeRenderTarget && (m = m.texture), a.material.uniforms.envMap.value = m, a.material.uniforms.flipEnvMap.value = m.isCubeTexture ? -1 : 1, u === m && l === m.version && h === t.toneMapping || (a.material.needsUpdate = !0, u = m, l = m.version, h = t.toneMapping), r.unshift(a, a.geometry, a.material, 0, 0, null)) : m && m.isTexture && (void 0 === s && (s = new Je(new ae(2, 2), new pe({ name: "BackgroundMaterial", uniforms: le(rr.background.uniforms), vertexShader: rr.background.vertexShader, fragmentShader: rr.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 })), s.geometry.deleteAttribute("normal"), Object.defineProperty(s.material, "map", { get: function () { return this.uniforms.t2D.value } }), n.update(s)), s.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), s.material.uniforms.uvTransform.value.copy(m.matrix), u === m && l === m.version && h === t.toneMapping || (s.material.needsUpdate = !0, u = m, l = m.version, h = t.toneMapping), r.unshift(s, s.geometry, s.material, 0, 0, null)) } } } function ir(t, e, r, n) { const i = t.getParameter(34921), o = n.isWebGL2 ? null : e.get("OES_vertex_array_object"), s = n.isWebGL2 || null !== o, a = {}, c = f(null); let u = c; function l(e) { return n.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e) } function h(e) { return n.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e) } function f(t) { const e = [], r = [], n = []; for (let t = 0; t < i; t++)e[t] = 0, r[t] = 0, n[t] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: r, attributeDivisors: n, object: t, attributes: {}, index: null } } function p() { const t = u.newAttributes; for (let e = 0, r = t.length; e < r; e++)t[e] = 0 } function d(t) { m(t, 0) } function m(r, i) { const o = u.newAttributes, s = u.enabledAttributes, a = u.attributeDivisors; if (o[r] = 1, 0 === s[r] && (t.enableVertexAttribArray(r), s[r] = 1), a[r] !== i) { (n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](r, i), a[r] = i } } function g() { const e = u.newAttributes, r = u.enabledAttributes; for (let n = 0, i = r.length; n < i; n++)r[n] !== e[n] && (t.disableVertexAttribArray(n), r[n] = 0) } function v(e, r, i, o, s, a) { !0 !== n.isWebGL2 || 5124 !== i && 5125 !== i ? t.vertexAttribPointer(e, r, i, o, s, a) : t.vertexAttribIPointer(e, r, i, s, a) } function y() { x(), u !== c && (u = c, l(u.object)) } function x() { c.geometry = null, c.program = null, c.wireframe = !1 } return { setup: function (i, c, h, y, x) { let b = !1; if (s) { const e = function (e, r, i) { const s = !0 === i.wireframe; let c = a[e.id]; void 0 === c && (c = {}, a[e.id] = c); let u = c[r.id]; void 0 === u && (u = {}, c[r.id] = u); let l = u[s]; void 0 === l && (l = f(n.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), u[s] = l); return l }(y, h, c); u !== e && (u = e, l(u.object)), b = function (t, e) { const r = u.attributes, n = t.attributes; if (Object.keys(r).length !== Object.keys(n).length) return !0; for (const t in n) { const e = r[t], i = n[t]; if (void 0 === e) return !0; if (e.attribute !== i) return !0; if (e.data !== i.data) return !0 } return u.index !== e }(y, x), b && function (t, e) { const r = {}, n = t.attributes; for (const t in n) { const e = n[t], i = {}; i.attribute = e, e.data && (i.data = e.data), r[t] = i } u.attributes = r, u.index = e }(y, x) } else { const t = !0 === c.wireframe; u.geometry === y.id && u.program === h.id && u.wireframe === t || (u.geometry = y.id, u.program = h.id, u.wireframe = t, b = !0) } !0 === i.isInstancedMesh && (b = !0), null !== x && r.update(x, 34963), b && (!function (i, o, s, a) { if (!1 === n.isWebGL2 && (i.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return; p(); const c = a.attributes, u = s.getAttributes(), l = o.defaultAttributeValues; for (const e in u) { const n = u[e]; if (n >= 0) { const o = c[e]; if (void 0 !== o) { const e = o.normalized, i = o.itemSize, s = r.get(o); if (void 0 === s) continue; const c = s.buffer, u = s.type, l = s.bytesPerElement; if (o.isInterleavedBufferAttribute) { const r = o.data, s = r.stride, h = o.offset; r && r.isInstancedInterleavedBuffer ? (m(n, r.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = r.meshPerAttribute * r.count)) : d(n), t.bindBuffer(34962, c), v(n, i, u, e, s * l, h * l) } else o.isInstancedBufferAttribute ? (m(n, o.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)) : d(n), t.bindBuffer(34962, c), v(n, i, u, e, 0, 0) } else if ("instanceMatrix" === e) { const e = r.get(i.instanceMatrix); if (void 0 === e) continue; const o = e.buffer, s = e.type; m(n + 0, 1), m(n + 1, 1), m(n + 2, 1), m(n + 3, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(n + 0, 4, s, !1, 64, 0), t.vertexAttribPointer(n + 1, 4, s, !1, 64, 16), t.vertexAttribPointer(n + 2, 4, s, !1, 64, 32), t.vertexAttribPointer(n + 3, 4, s, !1, 64, 48) } else if ("instanceColor" === e) { const e = r.get(i.instanceColor); if (void 0 === e) continue; const o = e.buffer, s = e.type; m(n, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(n, 3, s, !1, 12, 0) } else if (void 0 !== l) { const r = l[e]; if (void 0 !== r) switch (r.length) { case 2: t.vertexAttrib2fv(n, r); break; case 3: t.vertexAttrib3fv(n, r); break; case 4: t.vertexAttrib4fv(n, r); break; default: t.vertexAttrib1fv(n, r) } } } } g() }(i, c, h, y), null !== x && t.bindBuffer(34963, r.get(x).buffer)) }, reset: y, resetDefaultState: x, dispose: function () { y(); for (const t in a) { const e = a[t]; for (const t in e) { const r = e[t]; for (const t in r) h(r[t].object), delete r[t]; delete e[t] } delete a[t] } }, releaseStatesOfGeometry: function (t) { if (void 0 === a[t.id]) return; const e = a[t.id]; for (const t in e) { const r = e[t]; for (const t in r) h(r[t].object), delete r[t]; delete e[t] } delete a[t.id] }, releaseStatesOfProgram: function (t) { for (const e in a) { const r = a[e]; if (void 0 === r[t.id]) continue; const n = r[t.id]; for (const t in n) h(n[t].object), delete n[t]; delete r[t.id] } }, initAttributes: p, enableAttribute: d, disableUnusedAttributes: g } } function or(t, e, r, n) { const i = n.isWebGL2; let o; this.setMode = function (t) { o = t }, this.render = function (e, n) { t.drawArrays(o, e, n), r.update(n, o, 1) }, this.renderInstances = function (n, s, a) { if (0 === a) return; let c, u; if (i) c = t, u = "drawArraysInstanced"; else if (c = e.get("ANGLE_instanced_arrays"), u = "drawArraysInstancedANGLE", null === c) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); c[u](o, n, s, a), r.update(s, o, a) } } function sr(t, e, r) { let n; function i(e) { if ("highp" === e) { if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; e = "mediump" } return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext; let s = void 0 !== r.precision ? r.precision : "highp"; const a = i(s); a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a); const c = !0 === r.logarithmicDepthBuffer, u = t.getParameter(34930), l = t.getParameter(35660), h = t.getParameter(3379), f = t.getParameter(34076), p = t.getParameter(34921), d = t.getParameter(36347), m = t.getParameter(36348), g = t.getParameter(36349), v = l > 0, y = o || !!e.get("OES_texture_float"); return { isWebGL2: o, getMaxAnisotropy: function () { if (void 0 !== n) return n; const r = e.get("EXT_texture_filter_anisotropic"); return n = null !== r ? t.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, n }, getMaxPrecision: i, precision: s, logarithmicDepthBuffer: c, maxTextures: u, maxVertexTextures: l, maxTextureSize: h, maxCubemapSize: f, maxAttributes: p, maxVertexUniforms: d, maxVaryings: m, maxFragmentUniforms: g, vertexTextures: v, floatFragmentTextures: y, floatVertexTextures: v && y, maxSamples: o ? t.getParameter(36183) : 0 } } function ar(t) { const e = this; let r = null, n = 0, i = !1, o = !1; const s = new q, a = new g, c = { value: null, needsUpdate: !1 }; function u() { c.value !== r && (c.value = r, c.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0 } function l(t, r, n, i) { const o = null !== t ? t.length : 0; let u = null; if (0 !== o) { if (u = c.value, !0 !== i || null === u) { const e = n + 4 * o, i = r.matrixWorldInverse; a.getNormalMatrix(i), (null === u || u.length < e) && (u = new Float32Array(e)); for (let e = 0, r = n; e !== o; ++e, r += 4)s.copy(t[e]).applyMatrix4(i, a), s.normal.toArray(u, r), u[r + 3] = s.constant } c.value = u, c.needsUpdate = !0 } return e.numPlanes = o, e.numIntersection = 0, u } this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, o) { const s = 0 !== t.length || e || 0 !== n || i; return i = e, r = l(t, o, 0), n = t.length, s }, this.beginShadows = function () { o = !0, l(null) }, this.endShadows = function () { o = !1, u() }, this.setState = function (e, s, a) { const h = e.clippingPlanes, f = e.clipIntersection, p = e.clipShadows, d = t.get(e); if (!i || null === h || 0 === h.length || o && !p) o ? l(null) : u(); else { const t = o ? 0 : n, e = 4 * t; let i = d.clippingState || null; c.value = i, i = l(h, s, e, a); for (let t = 0; t !== e; ++t)i[t] = r[t]; d.clippingState = i, this.numIntersection = f ? this.numPlanes : 0, this.numPlanes += t } } } function cr(t, e, r) { this.width = t, this.height = e, this.scissor = new it(0, 0, t, e), this.scissorTest = !1, this.viewport = new it(0, 0, t, e), r = r || {}, this.texture = new b(void 0, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== r.generateMipmaps && r.generateMipmaps, this.texture.minFilter = void 0 !== r.minFilter ? r.minFilter : 1006, this.depthBuffer = void 0 === r.depthBuffer || r.depthBuffer, this.stencilBuffer = void 0 !== r.stencilBuffer && r.stencilBuffer, this.depthTexture = void 0 !== r.depthTexture ? r.depthTexture : null } function ur() { It.call(this), this.type = "Camera", this.matrixWorldInverse = new K, this.projectionMatrix = new K, this.projectionMatrixInverse = new K } function lr(t, e, r, n) { ur.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } rr.physical = { uniforms: he([rr.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new m(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new pt(0) }, transmission: { value: 0 }, transmissionMap: { value: null } }]), vertexShader: tr.meshphysical_vert, fragmentShader: tr.meshphysical_frag }, cr.prototype = Object.assign(Object.create(d.prototype), { constructor: cr, isWebGLRenderTarget: !0, setSize: function (t, e) { this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), ur.prototype = Object.assign(Object.create(It.prototype), { constructor: ur, isCamera: !0, copy: function (t, e) { return It.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this }, getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new S), this.updateMatrixWorld(!0); const e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() }, updateMatrixWorld: function (t) { It.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld) }, updateWorldMatrix: function (t, e) { It.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function () { return (new this.constructor).copy(this) } }), lr.prototype = Object.assign(Object.create(ur.prototype), { constructor: lr, isPerspectiveCamera: !0, copy: function (t, e) { return ur.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this }, setFocalLength: function (t) { const e = .5 * this.getFilmHeight() / t; this.fov = 2 * p.RAD2DEG * Math.atan(e), this.updateProjectionMatrix() }, getFocalLength: function () { const t = Math.tan(.5 * p.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / t }, getEffectiveFOV: function () { return 2 * p.RAD2DEG * Math.atan(Math.tan(.5 * p.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (t, e, r, n, i, o) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = r, this.view.offsetY = n, this.view.width = i, this.view.height = o, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { const t = this.near; let e = t * Math.tan(.5 * p.DEG2RAD * this.fov) / this.zoom, r = 2 * e, n = this.aspect * r, i = -.5 * n; const o = this.view; if (null !== this.view && this.view.enabled) { const t = o.fullWidth, s = o.fullHeight; i += o.offsetX * n / t, e -= o.offsetY * r / s, n *= o.width / t, r *= o.height / s } const s = this.filmOffset; 0 !== s && (i += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + n, e, e - r, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (t) { const e = It.prototype.toJSON.call(this, t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e } }); function hr(t, e, r) { if (It.call(this), this.type = "CubeCamera", !0 !== r.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); this.renderTarget = r; const n = new lr(90, 1, t, e); n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new S(1, 0, 0)), this.add(n); const i = new lr(90, 1, t, e); i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new S(-1, 0, 0)), this.add(i); const o = new lr(90, 1, t, e); o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new S(0, 1, 0)), this.add(o); const s = new lr(90, 1, t, e); s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new S(0, -1, 0)), this.add(s); const a = new lr(90, 1, t, e); a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new S(0, 0, 1)), this.add(a); const c = new lr(90, 1, t, e); c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new S(0, 0, -1)), this.add(c), this.update = function (t, e) { null === this.parent && this.updateMatrixWorld(); const u = t.xr.enabled, l = t.getRenderTarget(); t.xr.enabled = !1; const h = r.texture.generateMipmaps; r.texture.generateMipmaps = !1, t.setRenderTarget(r, 0), t.render(e, n), t.setRenderTarget(r, 1), t.render(e, i), t.setRenderTarget(r, 2), t.render(e, o), t.setRenderTarget(r, 3), t.render(e, s), t.setRenderTarget(r, 4), t.render(e, a), r.texture.generateMipmaps = h, t.setRenderTarget(r, 5), t.render(e, c), t.setRenderTarget(l), t.xr.enabled = u }, this.clear = function (t, e, n, i) { const o = t.getRenderTarget(); for (let o = 0; o < 6; o++)t.setRenderTarget(r, o), t.clear(e, n, i); t.setRenderTarget(o) } } function fr(t, e, r) { Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = r), cr.call(this, t, t, e), this.texture.isWebGLCubeRenderTargetTexture = !0 } function pr(t) { let e = new WeakMap; function r(t, e) { return 303 === e ? t.mapping = 301 : 304 === e && (t.mapping = 302), t } return { get: function (n) { if (n && n.isTexture) { const i = n.mapping; if (303 === i || 304 === i) { if (e.has(n)) { return r(e.get(n).texture, n.mapping) } { const i = n.image; if (i && i.height > 0) { const o = t.getRenderList(), s = t.getRenderTarget(), a = t.getRenderState(), c = new fr(i.height / 2); return c.fromEquirectangularTexture(t, n), e.set(n, c), t.setRenderTarget(s), t.setRenderList(o), t.setRenderState(a), r(c.texture, n.mapping) } return null } } } return n }, dispose: function () { e = new WeakMap } } } function dr(t) { const e = {}; return { has: function (r) { if (void 0 !== e[r]) return null !== e[r]; let n; switch (r) { case "WEBGL_depth_texture": n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: n = t.getExtension(r) }return e[r] = n, null !== n }, get: function (t) { return this.has(t) || console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e[t] } } } function mr(t, e, r, n) { const i = new WeakMap, o = new WeakMap; function s(t) { const a = t.target, c = i.get(a); null !== c.index && e.remove(c.index); for (const t in c.attributes) e.remove(c.attributes[t]); a.removeEventListener("dispose", s), i.delete(a); const u = o.get(c); u && (e.remove(u), o.delete(c)), n.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, r.memory.geometries-- } function a(t) { const r = [], n = t.index, i = t.attributes.position; let s = 0; if (null !== n) { const t = n.array; s = n.version; for (let e = 0, n = t.length; e < n; e += 3) { const n = t[e + 0], i = t[e + 1], o = t[e + 2]; r.push(n, i, i, o, o, n) } } else { const t = i.array; s = i.version; for (let e = 0, n = t.length / 3 - 1; e < n; e += 3) { const t = e + 0, n = e + 1, i = e + 2; r.push(t, n, n, i, i, t) } } const a = new (Jt(r) > 65535 ? Xt : Wt)(r, 1); a.version = s; const c = o.get(t); c && e.remove(c), o.set(t, a) } return { get: function (t, e) { let n = i.get(e); return n || (e.addEventListener("dispose", s), e.isBufferGeometry ? n = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new oe).setFromObject(t)), n = e._bufferGeometry), i.set(e, n), r.memory.geometries++, n) }, update: function (t) { const r = t.attributes; for (const t in r) e.update(r[t], 34962); const n = t.morphAttributes; for (const t in n) { const r = n[t]; for (let t = 0, n = r.length; t < n; t++)e.update(r[t], 34962) } }, getWireframeAttribute: function (t) { const e = o.get(t); if (e) { const r = t.index; null !== r && e.version < r.version && a(t) } else a(t); return o.get(t) } } } function gr(t, e, r, n) { const i = n.isWebGL2; let o, s, a; this.setMode = function (t) { o = t }, this.setIndex = function (t) { s = t.type, a = t.bytesPerElement }, this.render = function (e, n) { t.drawElements(o, n, s, e * a), r.update(n, o, 1) }, this.renderInstances = function (n, c, u) { if (0 === u) return; let l, h; if (i) l = t, h = "drawElementsInstanced"; else if (l = e.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === l) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[h](o, c, s, n * a, u), r.update(c, o, u) } } function vr(t) { const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: e, programs: null, autoReset: !0, reset: function () { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 }, update: function (t, r, n) { switch (e.calls++, r) { case 4: e.triangles += n * (t / 3); break; case 1: e.lines += n * (t / 2); break; case 3: e.lines += n * (t - 1); break; case 2: e.lines += n * t; break; case 0: e.points += n * t; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", r) } } } } function yr(t, e) { return t[0] - e[0] } function xr(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) } function br(t) { const e = {}, r = new Float32Array(8), n = []; for (let t = 0; t < 8; t++)n[t] = [t, 0]; return { update: function (i, o, s, a) { const c = i.morphTargetInfluences, u = void 0 === c ? 0 : c.length; let l = e[o.id]; if (void 0 === l) { l = []; for (let t = 0; t < u; t++)l[t] = [t, 0]; e[o.id] = l } for (let t = 0; t < u; t++) { const e = l[t]; e[0] = t, e[1] = c[t] } l.sort(xr); for (let t = 0; t < 8; t++)t < u && l[t][1] ? (n[t][0] = l[t][0], n[t][1] = l[t][1]) : (n[t][0] = Number.MAX_SAFE_INTEGER, n[t][1] = 0); n.sort(yr); const h = s.morphTargets && o.morphAttributes.position, f = s.morphNormals && o.morphAttributes.normal; let p = 0; for (let t = 0; t < 8; t++) { const e = n[t], i = e[0], s = e[1]; i !== Number.MAX_SAFE_INTEGER && s ? (h && o.getAttribute("morphTarget" + t) !== h[i] && o.setAttribute("morphTarget" + t, h[i]), f && o.getAttribute("morphNormal" + t) !== f[i] && o.setAttribute("morphNormal" + t, f[i]), r[t] = s, p += s) : (h && void 0 !== o.getAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t), f && void 0 !== o.getAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t), r[t] = 0) } const d = o.morphTargetsRelative ? 1 : 1 - p; a.getUniforms().setValue(t, "morphTargetBaseInfluence", d), a.getUniforms().setValue(t, "morphTargetInfluences", r) } } } function wr(t, e, r, n) { let i = new WeakMap; return { update: function (t) { const o = n.render.frame, s = t.geometry, a = e.get(t, s); return i.get(a) !== o && (s.isGeometry && a.updateFromObject(t), e.update(a), i.set(a, o)), t.isInstancedMesh && (r.update(t.instanceMatrix, 34962), null !== t.instanceColor && r.update(t.instanceColor, 34962)), a }, dispose: function () { i = new WeakMap } } } function Mr(t, e, r, n, i, o, s, a, c, u) { t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, s = void 0 !== s ? s : 1022, b.call(this, t, e, r, n, i, o, s, a, c, u), this.flipY = !1 } function Sr(t, e, r, n) { b.call(this, null), this.image = { data: t || null, width: e || 1, height: r || 1, depth: n || 1 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } function _r(t, e, r, n) { b.call(this, null), this.image = { data: t || null, width: e || 1, height: r || 1, depth: n || 1 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } hr.prototype = Object.create(It.prototype), hr.prototype.constructor = hr, fr.prototype = Object.create(cr.prototype), fr.prototype.constructor = fr, fr.prototype.isWebGLCubeRenderTarget = !0, fr.prototype.fromEquirectangularTexture = function (t, e) { this.texture.type = e.type, this.texture.format = 1023, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter; const r = { uniforms: { tEquirect: { value: null } }, vertexShader: "varying vec3 vWorldDirection;vec3 transformDirection(in vec3 dir,in mat4 matrix){return normalize((matrix*vec4(dir,0.0)).xyz);}void main(){vWorldDirection=transformDirection(position,modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\n}", fragmentShader: "uniform sampler2D tEquirect;varying vec3 vWorldDirection;\n#include <common>\nvoid main(){vec3 direction=normalize(vWorldDirection);vec2 sampleUV=equirectUv(direction);gl_FragColor=texture2D(tEquirect,sampleUV);}" }, n = new se(5, 5, 5), i = new pe({ name: "CubemapFromEquirect", uniforms: le(r.uniforms), vertexShader: r.vertexShader, fragmentShader: r.fragmentShader, side: 1, blending: 0 }); i.uniforms.tEquirect.value = e; const o = new Je(n, i), s = e.minFilter; 1008 === e.minFilter && (e.minFilter = 1006); return new hr(1, 10, this).update(t, o), e.minFilter = s, o.geometry.dispose(), o.material.dispose(), this }, Mr.prototype = Object.create(b.prototype), Mr.prototype.constructor = Mr, Mr.prototype.isCubeTexture = !0, Object.defineProperty(Mr.prototype, "images", { get: function () { return this.image }, set: function (t) { this.image = t } }), Sr.prototype = Object.create(b.prototype), Sr.prototype.constructor = Sr, Sr.prototype.isDataTexture2DArray = !0, _r.prototype = Object.create(b.prototype), _r.prototype.constructor = _r, _r.prototype.isDataTexture3D = !0; const Tr = new b, Er = new Sr, Ar = new _r, Rr = new Mr, Lr = [], Or = [], Pr = new Float32Array(16), Ir = new Float32Array(9), Cr = new Float32Array(4); function kr(t, e, r) { const n = t[0]; if (n <= 0 || n > 0) return t; const i = e * r; let o = Lr[i]; if (void 0 === o && (o = new Float32Array(i), Lr[i] = o), 0 !== e) { n.toArray(o, 0); for (let n = 1, i = 0; n !== e; ++n)i += r, t[n].toArray(o, i) } return o } function Nr(t, e) { if (t.length !== e.length) return !1; for (let r = 0, n = t.length; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } function zr(t, e) { for (let r = 0, n = e.length; r < n; r++)t[r] = e[r] } function Ur(t, e) { let r = Or[e]; void 0 === r && (r = new Int32Array(e), Or[e] = r); for (let n = 0; n !== e; ++n)r[n] = t.allocateTextureUnit(); return r } function jr(t, e) { const r = this.cache; r[0] !== e && (t.uniform1f(this.addr, e), r[0] = e) } function Br(t, e) { const r = this.cache; if (void 0 !== e.x) r[0] === e.x && r[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), r[0] = e.x, r[1] = e.y); else { if (Nr(r, e)) return; t.uniform2fv(this.addr, e), zr(r, e) } } function Fr(t, e) { const r = this.cache; if (void 0 !== e.x) r[0] === e.x && r[1] === e.y && r[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), r[0] = e.x, r[1] = e.y, r[2] = e.z); else if (void 0 !== e.r) r[0] === e.r && r[1] === e.g && r[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), r[0] = e.r, r[1] = e.g, r[2] = e.b); else { if (Nr(r, e)) return; t.uniform3fv(this.addr, e), zr(r, e) } } function Dr(t, e) { const r = this.cache; if (void 0 !== e.x) r[0] === e.x && r[1] === e.y && r[2] === e.z && r[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), r[0] = e.x, r[1] = e.y, r[2] = e.z, r[3] = e.w); else { if (Nr(r, e)) return; t.uniform4fv(this.addr, e), zr(r, e) } } function Gr(t, e) { const r = this.cache, n = e.elements; if (void 0 === n) { if (Nr(r, e)) return; t.uniformMatrix2fv(this.addr, !1, e), zr(r, e) } else { if (Nr(r, n)) return; Cr.set(n), t.uniformMatrix2fv(this.addr, !1, Cr), zr(r, n) } } function Vr(t, e) { const r = this.cache, n = e.elements; if (void 0 === n) { if (Nr(r, e)) return; t.uniformMatrix3fv(this.addr, !1, e), zr(r, e) } else { if (Nr(r, n)) return; Ir.set(n), t.uniformMatrix3fv(this.addr, !1, Ir), zr(r, n) } } function Hr(t, e) { const r = this.cache, n = e.elements; if (void 0 === n) { if (Nr(r, e)) return; t.uniformMatrix4fv(this.addr, !1, e), zr(r, e) } else { if (Nr(r, n)) return; Pr.set(n), t.uniformMatrix4fv(this.addr, !1, Pr), zr(r, n) } } function Wr(t, e, r) { const n = this.cache, i = r.allocateTextureUnit(); n[0] !== i && (t.uniform1i(this.addr, i), n[0] = i), r.safeSetTexture2D(e || Tr, i) } function qr(t, e, r) { const n = this.cache, i = r.allocateTextureUnit(); n[0] !== i && (t.uniform1i(this.addr, i), n[0] = i), r.setTexture2DArray(e || Er, i) } function Xr(t, e, r) { const n = this.cache, i = r.allocateTextureUnit(); n[0] !== i && (t.uniform1i(this.addr, i), n[0] = i), r.setTexture3D(e || Ar, i) } function Yr(t, e, r) { const n = this.cache, i = r.allocateTextureUnit(); n[0] !== i && (t.uniform1i(this.addr, i), n[0] = i), r.safeSetTextureCube(e || Rr, i) } function Zr(t, e) { const r = this.cache; r[0] !== e && (t.uniform1i(this.addr, e), r[0] = e) } function Kr(t, e) { const r = this.cache; Nr(r, e) || (t.uniform2iv(this.addr, e), zr(r, e)) } function Jr(t, e) { const r = this.cache; Nr(r, e) || (t.uniform3iv(this.addr, e), zr(r, e)) } function Qr(t, e) { const r = this.cache; Nr(r, e) || (t.uniform4iv(this.addr, e), zr(r, e)) } function $r(t, e) { const r = this.cache; r[0] !== e && (t.uniform1ui(this.addr, e), r[0] = e) } function tn(t, e) { t.uniform1fv(this.addr, e) } function en(t, e) { t.uniform1iv(this.addr, e) } function rn(t, e) { t.uniform2iv(this.addr, e) } function nn(t, e) { t.uniform3iv(this.addr, e) } function on(t, e) { t.uniform4iv(this.addr, e) } function sn(t, e) { const r = kr(e, this.size, 2); t.uniform2fv(this.addr, r) } function an(t, e) { const r = kr(e, this.size, 3); t.uniform3fv(this.addr, r) } function cn(t, e) { const r = kr(e, this.size, 4); t.uniform4fv(this.addr, r) } function un(t, e) { const r = kr(e, this.size, 4); t.uniformMatrix2fv(this.addr, !1, r) } function ln(t, e) { const r = kr(e, this.size, 9); t.uniformMatrix3fv(this.addr, !1, r) } function hn(t, e) { const r = kr(e, this.size, 16); t.uniformMatrix4fv(this.addr, !1, r) } function fn(t, e, r) { const n = e.length, i = Ur(r, n); t.uniform1iv(this.addr, i); for (let t = 0; t !== n; ++t)r.safeSetTexture2D(e[t] || Tr, i[t]) } function pn(t, e, r) { const n = e.length, i = Ur(r, n); t.uniform1iv(this.addr, i); for (let t = 0; t !== n; ++t)r.safeSetTextureCube(e[t] || Rr, i[t]) } function dn(t, e, r) { this.id = t, this.addr = r, this.cache = [], this.setValue = function (t) { switch (t) { case 5126: return jr; case 35664: return Br; case 35665: return Fr; case 35666: return Dr; case 35674: return Gr; case 35675: return Vr; case 35676: return Hr; case 5124: case 35670: return Zr; case 35667: case 35671: return Kr; case 35668: case 35672: return Jr; case 35669: case 35673: return Qr; case 5125: return $r; case 35678: case 36198: case 36298: case 36306: case 35682: return Wr; case 35679: case 36299: case 36307: return Xr; case 35680: case 36300: case 36308: case 36293: return Yr; case 36289: case 36303: case 36311: case 36292: return qr } }(e.type) } function mn(t, e, r) { this.id = t, this.addr = r, this.cache = [], this.size = e.size, this.setValue = function (t) { switch (t) { case 5126: return tn; case 35664: return sn; case 35665: return an; case 35666: return cn; case 35674: return un; case 35675: return ln; case 35676: return hn; case 5124: case 35670: return en; case 35667: case 35671: return rn; case 35668: case 35672: return nn; case 35669: case 35673: return on; case 35678: case 36198: case 36298: case 36306: case 35682: return fn; case 35680: case 36300: case 36308: case 36293: return pn } }(e.type) } function gn(t) { this.id = t, this.seq = [], this.map = {} } mn.prototype.updateCache = function (t) { const e = this.cache; t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), zr(e, t) }, gn.prototype.setValue = function (t, e, r) { const n = this.seq; for (let i = 0, o = n.length; i !== o; ++i) { const o = n[i]; o.setValue(t, e[o.id], r) } }; const vn = /([\w\d_]+)(\])?(\[|\.)?/g; function yn(t, e) { t.seq.push(e), t.map[e.id] = e } function xn(t, e, r) { const n = t.name, i = n.length; for (vn.lastIndex = 0; ;) { const o = vn.exec(n), s = vn.lastIndex; let a = o[1]; const c = "]" === o[2], u = o[3]; if (c && (a |= 0), void 0 === u || "[" === u && s + 2 === i) { yn(r, void 0 === u ? new dn(a, t, e) : new mn(a, t, e)); break } { let t = r.map[a]; void 0 === t && (t = new gn(a), yn(r, t)), r = t } } } function bn(t, e) { this.seq = [], this.map = {}; const r = t.getProgramParameter(e, 35718); for (let n = 0; n < r; ++n) { const r = t.getActiveUniform(e, n); xn(r, t.getUniformLocation(e, r.name), this) } } function wn(t, e, r) { const n = t.createShader(e); return t.shaderSource(n, r), t.compileShader(n), n } bn.prototype.setValue = function (t, e, r, n) { const i = this.map[e]; void 0 !== i && i.setValue(t, r, n) }, bn.prototype.setOptional = function (t, e, r) { const n = e[r]; void 0 !== n && this.setValue(t, r, n) }, bn.upload = function (t, e, r, n) { for (let i = 0, o = e.length; i !== o; ++i) { const o = e[i], s = r[o.id]; !1 !== s.needsUpdate && o.setValue(t, s.value, n) } }, bn.seqWithValue = function (t, e) { const r = []; for (let n = 0, i = t.length; n !== i; ++n) { const i = t[n]; i.id in e && r.push(i) } return r }; let Mn = 0; function Sn(t) { switch (t) { case 3e3: return ["Linear", "( value )"]; case 3001: return ["sRGB", "( value )"]; case 3002: return ["RGBE", "( value )"]; case 3004: return ["RGBM", "( value, 7.0 )"]; case 3005: return ["RGBM", "( value, 16.0 )"]; case 3006: return ["RGBD", "( value, 256.0 )"]; case 3007: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case 3003: return ["LogLuv", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"] } } function _n(t, e, r) { const n = t.getShaderParameter(e, 35713), i = t.getShaderInfoLog(e).trim(); if (n && "" === i) return ""; return "THREE.WebGLShader: gl.getShaderInfoLog() " + r + "\n" + i + function (t) { const e = t.split("\n"); for (let t = 0; t < e.length; t++)e[t] = t + 1 + ": " + e[t]; return e.join("\n") }(t.getShaderSource(e)) } function Tn(t, e) { const r = Sn(e); return "vec4 " + t + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }" } function En(t, e) { const r = Sn(e); return "vec4 " + t + "( vec4 value ) { return LinearTo" + r[0] + r[1] + "; }" } function An(t, e) { let r; switch (e) { case 1: r = "Linear"; break; case 2: r = "Reinhard"; break; case 3: r = "OptimizedCineon"; break; case 4: r = "ACESFilmic"; break; case 5: r = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), r = "Linear" }return "vec3 " + t + "( vec3 color ) { return " + r + "ToneMapping( color ); }" } function Rn(t) { return "" !== t } function Ln(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function On(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const Pn = /^[ \t]*#include +<([\w\d./]+)>/gm; function In(t) { return t.replace(Pn, Cn) } function Cn(t, e) { const r = tr[e]; if (void 0 === r) throw new Error("Can not resolve #include <" + e + ">"); return In(r) } const kn = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, Nn = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function zn(t) { return t.replace(Nn, jn).replace(kn, Un) } function Un(t, e, r, n) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), jn(t, e, r, n) } function jn(t, e, r, n) { let i = ""; for (let t = parseInt(e); t < parseInt(r); t++)i += n.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t); return i } function Bn(t) { let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"; return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e } function Fn(t, e, r, n) { const i = t.getContext(), o = r.defines; let s = r.vertexShader, a = r.fragmentShader; const c = function (t) { let e = "SHADOWMAP_TYPE_BASIC"; return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e }(r), u = function (t) { let e = "ENVMAP_TYPE_CUBE"; if (t.envMap) switch (t.envMapMode) { case 301: case 302: e = "ENVMAP_TYPE_CUBE"; break; case 306: case 307: e = "ENVMAP_TYPE_CUBE_UV" }return e }(r), l = function (t) { let e = "ENVMAP_MODE_REFLECTION"; if (t.envMap) switch (t.envMapMode) { case 302: case 307: e = "ENVMAP_MODE_REFRACTION" }return e }(r), h = function (t) { let e = "ENVMAP_BLENDING_NONE"; if (t.envMap) switch (t.combine) { case 0: e = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: e = "ENVMAP_BLENDING_MIX"; break; case 2: e = "ENVMAP_BLENDING_ADD" }return e }(r), f = t.gammaFactor > 0 ? t.gammaFactor : 1, p = r.isWebGL2 ? "" : function (t) { return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Rn).join("\n") }(r), d = function (t) { const e = []; for (const r in t) { const n = t[r]; !1 !== n && e.push("#define " + r + " " + n) } return e.join("\n") }(o), m = i.createProgram(); let g, v, y = r.glslVersion ? "#version " + r.glslVersion + "\n" : ""; r.isRawShaderMaterial ? (g = [d].filter(Rn).join("\n"), g.length > 0 && (g += "\n"), v = [p, d].filter(Rn).join("\n"), v.length > 0 && (v += "\n")) : (g = [Bn(r), "#define SHADER_NAME " + r.shaderName, d, r.instancing ? "#define USE_INSTANCING" : "", r.instancingColor ? "#define USE_INSTANCING_COLOR" : "", r.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + f, "#define MAX_BONES " + r.maxBones, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + l : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.displacementMap && r.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors ? "#define USE_COLOR" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.skinning ? "#define USE_SKINNING" : "", r.useVertexTexture ? "#define BONE_TEXTURE" : "", r.morphTargets ? "#define USE_MORPHTARGETS" : "", r.morphNormals && !1 === r.flatShading ? "#define USE_MORPHNORMALS" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + c : "", r.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Rn).join("\n"), v = [p, Bn(r), "#define SHADER_NAME " + r.shaderName, d, r.alphaTest ? "#define ALPHATEST " + r.alphaTest + (r.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + f, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.matcap ? "#define USE_MATCAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + u : "", r.envMap ? "#define " + l : "", r.envMap ? "#define " + h : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.sheen ? "#define USE_SHEEN" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors || r.instancingColor ? "#define USE_COLOR" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.gradientMap ? "#define USE_GRADIENTMAP" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + c : "", r.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", r.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (r.extensionShaderTextureLOD || r.envMap) && r.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== r.toneMapping ? "#define TONE_MAPPING" : "", 0 !== r.toneMapping ? tr.tonemapping_pars_fragment : "", 0 !== r.toneMapping ? An("toneMapping", r.toneMapping) : "", r.dithering ? "#define DITHERING" : "", tr.encodings_pars_fragment, r.map ? Tn("mapTexelToLinear", r.mapEncoding) : "", r.matcap ? Tn("matcapTexelToLinear", r.matcapEncoding) : "", r.envMap ? Tn("envMapTexelToLinear", r.envMapEncoding) : "", r.emissiveMap ? Tn("emissiveMapTexelToLinear", r.emissiveMapEncoding) : "", r.lightMap ? Tn("lightMapTexelToLinear", r.lightMapEncoding) : "", En("linearToOutputTexel", r.outputEncoding), r.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(Rn).join("\n")), s = In(s), s = Ln(s, r), s = On(s, r), a = In(a), a = Ln(a, r), a = On(a, r), s = zn(s), a = zn(a), r.isWebGL2 && !0 !== r.isRawShaderMaterial && (y = "#version 300 es\n", g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", "300 es" === r.glslVersion ? "" : "out highp vec4 pc_fragColor;", "300 es" === r.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v); const x = y + v + a, b = wn(i, 35633, y + g + s), w = wn(i, 35632, x); if (i.attachShader(m, b), i.attachShader(m, w), void 0 !== r.index0AttributeName ? i.bindAttribLocation(m, 0, r.index0AttributeName) : !0 === r.morphTargets && i.bindAttribLocation(m, 0, "position"), i.linkProgram(m), t.debug.checkShaderErrors) { const t = i.getProgramInfoLog(m).trim(), e = i.getShaderInfoLog(b).trim(), r = i.getShaderInfoLog(w).trim(); let n = !0, o = !0; if (!1 === i.getProgramParameter(m, 35714)) { n = !1; const e = _n(i, b, "vertex"), r = _n(i, w, "fragment"); console.error("THREE.WebGLProgram: shader error: ", i.getError(), "gl.VALIDATE_STATUS", i.getProgramParameter(m, 35715), "gl.getProgramInfoLog", t, e, r) } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== r || (o = !1); o && (this.diagnostics = { runnable: n, programLog: t, vertexShader: { log: e, prefix: g }, fragmentShader: { log: r, prefix: v } }) } let M, S; return i.deleteShader(b), i.deleteShader(w), this.getUniforms = function () { return void 0 === M && (M = new bn(i, m)), M }, this.getAttributes = function () { return void 0 === S && (S = function (t, e) { const r = {}, n = t.getProgramParameter(e, 35721); for (let i = 0; i < n; i++) { const n = t.getActiveAttrib(e, i).name; r[n] = t.getAttribLocation(e, n) } return r }(i, m)), S }, this.destroy = function () { n.releaseStatesOfProgram(this), i.deleteProgram(m), this.program = void 0 }, this.name = r.shaderName, this.id = Mn++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = b, this.fragmentShader = w, this } function Dn(t, e, r, n, i, o) { const s = [], a = n.isWebGL2, c = n.logarithmicDepthBuffer, u = n.floatVertexTextures, l = n.maxVertexUniforms, h = n.vertexTextures; let f = n.precision; const p = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, d = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"]; function m(t) { let e; return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = 3e3, e } return { getParameters: function (i, s, d, g, v) { const y = g.fog, x = i.isMeshStandardMaterial ? g.environment : null, b = e.get(i.envMap || x), w = p[i.type], M = v.isSkinnedMesh ? function (t) { const e = t.skeleton.bones; if (u) return 1024; { const t = l, r = Math.floor((t - 20) / 4), n = Math.min(r, e.length); return n < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + n + "."), 0) : n } }(v) : 0; let S, _; if (null !== i.precision && (f = n.getMaxPrecision(i.precision), f !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", f, "instead.")), w) { const t = rr[w]; S = t.vertexShader, _ = t.fragmentShader } else S = i.vertexShader, _ = i.fragmentShader; const T = t.getRenderTarget(); return { isWebGL2: a, shaderID: w, shaderName: i.type, vertexShader: S, fragmentShader: _, defines: i.defines, isRawShaderMaterial: !0 === i.isRawShaderMaterial, glslVersion: i.glslVersion, precision: f, instancing: !0 === v.isInstancedMesh, instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor, supportsVertexTextures: h, outputEncoding: null !== T ? m(T.texture) : t.outputEncoding, map: !!i.map, mapEncoding: m(i.map), matcap: !!i.matcap, matcapEncoding: m(i.matcap), envMap: !!b, envMapMode: b && b.mapping, envMapEncoding: m(b), envMapCubeUV: !!b && (306 === b.mapping || 307 === b.mapping), lightMap: !!i.lightMap, lightMapEncoding: m(i.lightMap), aoMap: !!i.aoMap, emissiveMap: !!i.emissiveMap, emissiveMapEncoding: m(i.emissiveMap), bumpMap: !!i.bumpMap, normalMap: !!i.normalMap, objectSpaceNormalMap: 1 === i.normalMapType, tangentSpaceNormalMap: 0 === i.normalMapType, clearcoatMap: !!i.clearcoatMap, clearcoatRoughnessMap: !!i.clearcoatRoughnessMap, clearcoatNormalMap: !!i.clearcoatNormalMap, displacementMap: !!i.displacementMap, roughnessMap: !!i.roughnessMap, metalnessMap: !!i.metalnessMap, specularMap: !!i.specularMap, alphaMap: !!i.alphaMap, gradientMap: !!i.gradientMap, sheen: !!i.sheen, transmissionMap: !!i.transmissionMap, combine: i.combine, vertexTangents: i.normalMap && i.vertexTangents, vertexColors: i.vertexColors, vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap || i.transmissionMap), uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || i.transmissionMap || !i.displacementMap), fog: !!y, useFog: i.fog, fogExp2: y && y.isFogExp2, flatShading: i.flatShading, sizeAttenuation: i.sizeAttenuation, logarithmicDepthBuffer: c, skinning: i.skinning && M > 0, maxBones: M, useVertexTexture: u, morphTargets: i.morphTargets, morphNormals: i.morphNormals, maxMorphTargets: t.maxMorphTargets, maxMorphNormals: t.maxMorphNormals, numDirLights: s.directional.length, numPointLights: s.point.length, numSpotLights: s.spot.length, numRectAreaLights: s.rectArea.length, numHemiLights: s.hemi.length, numDirLightShadows: s.directionalShadowMap.length, numPointLightShadows: s.pointShadowMap.length, numSpotLightShadows: s.spotShadowMap.length, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: i.dithering, shadowMapEnabled: t.shadowMap.enabled && d.length > 0, shadowMapType: t.shadowMap.type, toneMapping: i.toneMapped ? t.toneMapping : 0, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: i.premultipliedAlpha, alphaTest: i.alphaTest, doubleSided: 2 === i.side, flipSided: 1 === i.side, depthPacking: void 0 !== i.depthPacking && i.depthPacking, index0AttributeName: i.index0AttributeName, extensionDerivatives: i.extensions && i.extensions.derivatives, extensionFragDepth: i.extensions && i.extensions.fragDepth, extensionDrawBuffers: i.extensions && i.extensions.drawBuffers, extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD, rendererExtensionFragDepth: a || r.has("EXT_frag_depth"), rendererExtensionDrawBuffers: a || r.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: a || r.has("EXT_shader_texture_lod"), customProgramCacheKey: i.customProgramCacheKey() } }, getProgramCacheKey: function (e) { const r = []; if (e.shaderID ? r.push(e.shaderID) : (r.push(e.fragmentShader), r.push(e.vertexShader)), void 0 !== e.defines) for (const t in e.defines) r.push(t), r.push(e.defines[t]); if (!1 === e.isRawShaderMaterial) { for (let t = 0; t < d.length; t++)r.push(e[d[t]]); r.push(t.outputEncoding), r.push(t.gammaFactor) } return r.push(e.customProgramCacheKey), r.join() }, getUniforms: function (t) { const e = p[t.type]; let r; if (e) { const t = rr[e]; r = fe.clone(t.uniforms) } else r = t.uniforms; return r }, acquireProgram: function (e, r) { let n; for (let t = 0, e = s.length; t < e; t++) { const e = s[t]; if (e.cacheKey === r) { n = e, ++n.usedTimes; break } } return void 0 === n && (n = new Fn(t, r, e, i), s.push(n)), n }, releaseProgram: function (t) { if (0 == --t.usedTimes) { const e = s.indexOf(t); s[e] = s[s.length - 1], s.pop(), t.destroy() } }, programs: s } } function Gn() { let t = new WeakMap; return { get: function (e) { let r = t.get(e); return void 0 === r && (r = {}, t.set(e, r)), r }, remove: function (e) { t.delete(e) }, update: function (e, r, n) { t.get(e)[r] = n }, dispose: function () { t = new WeakMap } } } function Vn(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function Hn(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function Wn(t) { const e = []; let r = 0; const n = [], i = [], o = { id: -1 }; function s(n, i, s, a, c, u) { let l = e[r]; const h = t.get(s); return void 0 === l ? (l = { id: n.id, object: n, geometry: i, material: s, program: h.program || o, groupOrder: a, renderOrder: n.renderOrder, z: c, group: u }, e[r] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = s, l.program = h.program || o, l.groupOrder = a, l.renderOrder = n.renderOrder, l.z = c, l.group = u), r++, l } return { opaque: n, transparent: i, init: function () { r = 0, n.length = 0, i.length = 0 }, push: function (t, e, r, o, a, c) { const u = s(t, e, r, o, a, c); (!0 === r.transparent ? i : n).push(u) }, unshift: function (t, e, r, o, a, c) { const u = s(t, e, r, o, a, c); (!0 === r.transparent ? i : n).unshift(u) }, finish: function () { for (let t = r, n = e.length; t < n; t++) { const r = e[t]; if (null === r.id) break; r.id = null, r.object = null, r.geometry = null, r.material = null, r.program = null, r.group = null } }, sort: function (t, e) { n.length > 1 && n.sort(t || Vn), i.length > 1 && i.sort(e || Hn) } } } function qn(t) { let e = new WeakMap; return { get: function (r, n) { const i = e.get(r); let o; return void 0 === i ? (o = new Wn(t), e.set(r, new WeakMap), e.get(r).set(n, o)) : (o = i.get(n), void 0 === o && (o = new Wn(t), i.set(n, o))), o }, dispose: function () { e = new WeakMap } } } function Xn() { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let r; switch (e.type) { case "DirectionalLight": r = { direction: new S, color: new pt }; break; case "SpotLight": r = { position: new S, direction: new S, color: new pt, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": r = { position: new S, color: new pt, distance: 0, decay: 0 }; break; case "HemisphereLight": r = { direction: new S, skyColor: new pt, groundColor: new pt }; break; case "RectAreaLight": r = { color: new pt, position: new S, halfWidth: new S, halfHeight: new S } }return t[e.id] = r, r } } } let Yn = 0; function Zn(t, e) { return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0) } function Kn() { const t = new Xn, e = function () { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let r; switch (e.type) { case "DirectionalLight": case "SpotLight": r = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new m }; break; case "PointLight": r = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new m, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return t[e.id] = r, r } } }(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let t = 0; t < 9; t++)r.probe.push(new S); const n = new S, i = new K, o = new K; return { setup: function (s, a, c) { let u = 0, l = 0, h = 0; for (let t = 0; t < 9; t++)r.probe[t].set(0, 0, 0); let f = 0, p = 0, d = 0, m = 0, g = 0, v = 0, y = 0, x = 0; const b = c.matrixWorldInverse; s.sort(Zn); for (let a = 0, c = s.length; a < c; a++) { const c = s[a], w = c.color, M = c.intensity, S = c.distance, _ = c.shadow && c.shadow.map ? c.shadow.map.texture : null; if (c.isAmbientLight) u += w.r * M, l += w.g * M, h += w.b * M; else if (c.isLightProbe) for (let t = 0; t < 9; t++)r.probe[t].addScaledVector(c.sh.coefficients[t], M); else if (c.isDirectionalLight) { const i = t.get(c); if (i.color.copy(c.color).multiplyScalar(c.intensity), i.direction.setFromMatrixPosition(c.matrixWorld), n.setFromMatrixPosition(c.target.matrixWorld), i.direction.sub(n), i.direction.transformDirection(b), c.castShadow) { const t = c.shadow, n = e.get(c); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[f] = n, r.directionalShadowMap[f] = _, r.directionalShadowMatrix[f] = c.shadow.matrix, v++ } r.directional[f] = i, f++ } else if (c.isSpotLight) { const i = t.get(c); if (i.position.setFromMatrixPosition(c.matrixWorld), i.position.applyMatrix4(b), i.color.copy(w).multiplyScalar(M), i.distance = S, i.direction.setFromMatrixPosition(c.matrixWorld), n.setFromMatrixPosition(c.target.matrixWorld), i.direction.sub(n), i.direction.transformDirection(b), i.coneCos = Math.cos(c.angle), i.penumbraCos = Math.cos(c.angle * (1 - c.penumbra)), i.decay = c.decay, c.castShadow) { const t = c.shadow, n = e.get(c); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.spotShadow[d] = n, r.spotShadowMap[d] = _, r.spotShadowMatrix[d] = c.shadow.matrix, x++ } r.spot[d] = i, d++ } else if (c.isRectAreaLight) { const e = t.get(c); e.color.copy(w).multiplyScalar(M), e.position.setFromMatrixPosition(c.matrixWorld), e.position.applyMatrix4(b), o.identity(), i.copy(c.matrixWorld), i.premultiply(b), o.extractRotation(i), e.halfWidth.set(.5 * c.width, 0, 0), e.halfHeight.set(0, .5 * c.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), r.rectArea[m] = e, m++ } else if (c.isPointLight) { const n = t.get(c); if (n.position.setFromMatrixPosition(c.matrixWorld), n.position.applyMatrix4(b), n.color.copy(c.color).multiplyScalar(c.intensity), n.distance = c.distance, n.decay = c.decay, c.castShadow) { const t = c.shadow, n = e.get(c); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[p] = n, r.pointShadowMap[p] = _, r.pointShadowMatrix[p] = c.shadow.matrix, y++ } r.point[p] = n, p++ } else if (c.isHemisphereLight) { const e = t.get(c); e.direction.setFromMatrixPosition(c.matrixWorld), e.direction.transformDirection(b), e.direction.normalize(), e.skyColor.copy(c.color).multiplyScalar(M), e.groundColor.copy(c.groundColor).multiplyScalar(M), r.hemi[g] = e, g++ } } m > 0 && (r.rectAreaLTC1 = er.LTC_1, r.rectAreaLTC2 = er.LTC_2), r.ambient[0] = u, r.ambient[1] = l, r.ambient[2] = h; const w = r.hash; w.directionalLength === f && w.pointLength === p && w.spotLength === d && w.rectAreaLength === m && w.hemiLength === g && w.numDirectionalShadows === v && w.numPointShadows === y && w.numSpotShadows === x || (r.directional.length = f, r.spot.length = d, r.rectArea.length = m, r.point.length = p, r.hemi.length = g, r.directionalShadow.length = v, r.directionalShadowMap.length = v, r.pointShadow.length = y, r.pointShadowMap.length = y, r.spotShadow.length = x, r.spotShadowMap.length = x, r.directionalShadowMatrix.length = v, r.pointShadowMatrix.length = y, r.spotShadowMatrix.length = x, w.directionalLength = f, w.pointLength = p, w.spotLength = d, w.rectAreaLength = m, w.hemiLength = g, w.numDirectionalShadows = v, w.numPointShadows = y, w.numSpotShadows = x, r.version = Yn++) }, state: r } } function Jn() { const t = new Kn, e = [], r = []; return { init: function () { e.length = 0, r.length = 0 }, state: { lightsArray: e, shadowsArray: r, lights: t }, setupLights: function (n) { t.setup(e, r, n) }, pushLight: function (t) { e.push(t) }, pushShadow: function (t) { r.push(t) } } } function Qn() { let t = new WeakMap; return { get: function (e, r) { let n; return !1 === t.has(e) ? (n = new Jn, t.set(e, new WeakMap), t.get(e).set(r, n)) : !1 === t.get(e).has(r) ? (n = new Jn, t.get(e).set(r, n)) : n = t.get(e).get(r), n }, dispose: function () { t = new WeakMap } } } function $n(t) { ue.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t) } function ti(t) { ue.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new S, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t) } $n.prototype = Object.create(ue.prototype), $n.prototype.constructor = $n, $n.prototype.isMeshDepthMaterial = !0, $n.prototype.copy = function (t) { return ue.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }, ti.prototype = Object.create(ue.prototype), ti.prototype.constructor = ti, ti.prototype.isMeshDistanceMaterial = !0, ti.prototype.copy = function (t) { return ue.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this }; function ei(t, e, r) { let n = new Z; const i = new m, o = new m, s = new it, a = [], c = [], u = {}, l = { 0: 1, 1: 0, 2: 2 }, h = new pe({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new m }, radius: { value: 4 } }, vertexShader: "void main(){gl_Position=vec4(position,1.0);}", fragmentShader: "uniform sampler2D shadow_pass;uniform vec2 resolution;uniform float radius;\n#include <packing>\nvoid main(){float mean=0.0;float squared_mean=0.0;float depth=unpackRGBAToDepth(texture2D(shadow_pass,(gl_FragCoord.xy)/resolution));for(float i=-1.0;i<1.0;i+=SAMPLE_RATE){\n#ifdef HORIZONAL_PASS\nvec2 distribution=unpackRGBATo2Half(texture2D(shadow_pass,(gl_FragCoord.xy+vec2(i,0.0)*radius)/resolution));mean+=distribution.x;squared_mean+=distribution.y*distribution.y+distribution.x*distribution.x;\n#else\nfloat depth=unpackRGBAToDepth(texture2D(shadow_pass,(gl_FragCoord.xy+vec2(0.0,i)*radius)/resolution));mean+=depth;squared_mean+=depth*depth;\n#endif\n}mean=mean*HALF_SAMPLE_RATE;squared_mean=squared_mean*HALF_SAMPLE_RATE;float std_dev=sqrt(squared_mean-mean*mean);gl_FragColor=pack2HalfToRGBA(vec2(mean,std_dev));}" }), f = h.clone(); f.defines.HORIZONAL_PASS = 1; const p = new oe; p.setAttribute("position", new Ft(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const d = new Je(p, h), g = this; function v(r, n) { const i = e.update(d); h.uniforms.shadow_pass.value = r.map.texture, h.uniforms.resolution.value = r.mapSize, h.uniforms.radius.value = r.radius, t.setRenderTarget(r.mapPass), t.clear(), t.renderBufferDirect(n, null, i, h, d, null), f.uniforms.shadow_pass.value = r.mapPass.texture, f.uniforms.resolution.value = r.mapSize, f.uniforms.radius.value = r.radius, t.setRenderTarget(r.map), t.clear(), t.renderBufferDirect(n, null, i, f, d, null) } function y(t, e, r) { const n = t << 0 | e << 1 | r << 2; let i = a[n]; return void 0 === i && (i = new $n({ depthPacking: 3201, morphTargets: t, skinning: e }), a[n] = i), i } function x(t, e, r) { const n = t << 0 | e << 1 | r << 2; let i = c[n]; return void 0 === i && (i = new ti({ morphTargets: t, skinning: e }), c[n] = i), i } function b(e, r, n, i, o, s, a) { let c = null, h = y, f = e.customDepthMaterial; if (!0 === i.isPointLight && (h = x, f = e.customDistanceMaterial), void 0 === f) { let t = !1; !0 === n.morphTargets && (t = r.morphAttributes && r.morphAttributes.position && r.morphAttributes.position.length > 0); let i = !1; !0 === e.isSkinnedMesh && (!0 === n.skinning ? i = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)); c = h(t, i, !0 === e.isInstancedMesh) } else c = f; if (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) { const t = c.uuid, e = n.uuid; let r = u[t]; void 0 === r && (r = {}, u[t] = r); let i = r[e]; void 0 === i && (i = c.clone(), r[e] = i), c = i } return c.visible = n.visible, c.wireframe = n.wireframe, c.side = 3 === a ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : l[n.side], c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, !0 === i.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(i.matrixWorld), c.nearDistance = o, c.farDistance = s), c } function w(r, i, o, s, a) { if (!1 === r.visible) return; if (r.layers.test(i.layers) && (r.isMesh || r.isLine || r.isPoints) && (r.castShadow || r.receiveShadow && 3 === a) && (!r.frustumCulled || n.intersectsObject(r))) { r.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, r.matrixWorld); const n = e.update(r), i = r.material; if (Array.isArray(i)) { const e = n.groups; for (let c = 0, u = e.length; c < u; c++) { const u = e[c], l = i[u.materialIndex]; if (l && l.visible) { const e = b(r, n, l, s, o.near, o.far, a); t.renderBufferDirect(o, null, n, e, r, u) } } } else if (i.visible) { const e = b(r, n, i, s, o.near, o.far, a); t.renderBufferDirect(o, null, n, e, r, null) } } const c = r.children; for (let t = 0, e = c.length; t < e; t++)w(c[t], i, o, s, a) } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, a, c) { if (!1 === g.enabled) return; if (!1 === g.autoUpdate && !1 === g.needsUpdate) return; if (0 === e.length) return; const u = t.getRenderTarget(), l = t.getActiveCubeFace(), h = t.getActiveMipmapLevel(), f = t.state; f.setBlending(0), f.buffers.color.setClear(1, 1, 1, 1), f.buffers.depth.setTest(!0), f.setScissorTest(!1); for (let u = 0, l = e.length; u < l; u++) { const l = e[u], h = l.shadow; if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue; if (void 0 === h) { console.warn("THREE.WebGLShadowMap:", l, "has no shadow."); continue } i.copy(h.mapSize); const p = h.getFrameExtents(); if (i.multiply(p), o.copy(h.mapSize), (i.x > r || i.y > r) && (i.x > r && (o.x = Math.floor(r / p.x), i.x = o.x * p.x, h.mapSize.x = o.x), i.y > r && (o.y = Math.floor(r / p.y), i.y = o.y * p.y, h.mapSize.y = o.y)), null === h.map && !h.isPointLightShadow && 3 === this.type) { const t = { minFilter: 1006, magFilter: 1006, format: 1023 }; h.map = new cr(i.x, i.y, t), h.map.texture.name = l.name + ".shadowMap", h.mapPass = new cr(i.x, i.y, t), h.camera.updateProjectionMatrix() } if (null === h.map) { const t = { minFilter: 1003, magFilter: 1003, format: 1023 }; h.map = new cr(i.x, i.y, t), h.map.texture.name = l.name + ".shadowMap", h.camera.updateProjectionMatrix() } t.setRenderTarget(h.map), t.clear(); const d = h.getViewportCount(); for (let t = 0; t < d; t++) { const e = h.getViewport(t); s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w), f.viewport(s), h.updateMatrices(l, t), n = h.getFrustum(), w(a, c, h.camera, l, this.type) } h.isPointLightShadow || 3 !== this.type || v(h, c), h.needsUpdate = !1 } g.needsUpdate = !1, t.setRenderTarget(u, l, h) } } function ri(t, e, r) { const n = r.isWebGL2; const i = new function () { let e = !1; const r = new it; let n = null; const i = new it(0, 0, 0, 0); return { setMask: function (r) { n === r || e || (t.colorMask(r, r, r, r), n = r) }, setLocked: function (t) { e = t }, setClear: function (e, n, o, s, a) { !0 === a && (e *= s, n *= s, o *= s), r.set(e, n, o, s), !1 === i.equals(r) && (t.clearColor(e, n, o, s), i.copy(r)) }, reset: function () { e = !1, n = null, i.set(-1, 0, 0, 0) } } }, o = new function () { let e = !1, r = null, n = null, i = null; return { setTest: function (t) { t ? C(2929) : k(2929) }, setMask: function (n) { r === n || e || (t.depthMask(n), r = n) }, setFunc: function (e) { if (n !== e) { if (e) switch (e) { case 0: t.depthFunc(512); break; case 1: t.depthFunc(519); break; case 2: t.depthFunc(513); break; case 3: t.depthFunc(515); break; case 4: t.depthFunc(514); break; case 5: t.depthFunc(518); break; case 6: t.depthFunc(516); break; case 7: t.depthFunc(517); break; default: t.depthFunc(515) } else t.depthFunc(515); n = e } }, setLocked: function (t) { e = t }, setClear: function (e) { i !== e && (t.clearDepth(e), i = e) }, reset: function () { e = !1, r = null, n = null, i = null } } }, s = new function () { let e = !1, r = null, n = null, i = null, o = null, s = null, a = null, c = null, u = null; return { setTest: function (t) { e || (t ? C(2960) : k(2960)) }, setMask: function (n) { r === n || e || (t.stencilMask(n), r = n) }, setFunc: function (e, r, s) { n === e && i === r && o === s || (t.stencilFunc(e, r, s), n = e, i = r, o = s) }, setOp: function (e, r, n) { s === e && a === r && c === n || (t.stencilOp(e, r, n), s = e, a = r, c = n) }, setLocked: function (t) { e = t }, setClear: function (e) { u !== e && (t.clearStencil(e), u = e) }, reset: function () { e = !1, r = null, n = null, i = null, o = null, s = null, a = null, c = null, u = null } } }; let a = {}, c = null, u = null, l = null, h = null, f = null, p = null, d = null, m = null, g = null, v = !1, y = null, x = null, b = null, w = null, M = null; const S = t.getParameter(35661); let _ = !1, T = 0; const E = t.getParameter(7938); -1 !== E.indexOf("WebGL") ? (T = parseFloat(/^WebGL\ ([0-9])/.exec(E)[1]), _ = T >= 1) : -1 !== E.indexOf("OpenGL ES") && (T = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(E)[1]), _ = T >= 2); let A = null, R = {}; const L = new it, O = new it; function P(e, r, n) { const i = new Uint8Array(4), o = t.createTexture(); t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728); for (let e = 0; e < n; e++)t.texImage2D(r + e, 0, 6408, 1, 1, 0, 6408, 5121, i); return o } const I = {}; function C(e) { !0 !== a[e] && (t.enable(e), a[e] = !0) } function k(e) { !1 !== a[e] && (t.disable(e), a[e] = !1) } I[3553] = P(3553, 3553, 1), I[34067] = P(34067, 34069, 6), i.setClear(0, 0, 0, 1), o.setClear(1), s.setClear(0), C(2929), o.setFunc(3), j(!1), B(1), C(2884), U(0); const N = { 100: 32774, 101: 32778, 102: 32779 }; if (n) N[103] = 32775, N[104] = 32776; else { const t = e.get("EXT_blend_minmax"); null !== t && (N[103] = t.MIN_EXT, N[104] = t.MAX_EXT) } const z = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 }; function U(e, r, n, i, o, s, a, c) { if (0 !== e) { if (u || (C(3042), u = !0), 5 === e) o = o || r, s = s || n, a = a || i, r === h && o === d || (t.blendEquationSeparate(N[r], N[o]), h = r, d = o), n === f && i === p && s === m && a === g || (t.blendFuncSeparate(z[n], z[i], z[s], z[a]), f = n, p = i, m = s, g = a), l = e, v = null; else if (e !== l || c !== v) { if (100 === h && 100 === d || (t.blendEquation(32774), h = 100, d = 100), c) switch (e) { case 1: t.blendFuncSeparate(1, 771, 1, 771); break; case 2: t.blendFunc(1, 1); break; case 3: t.blendFuncSeparate(0, 0, 769, 771); break; case 4: t.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) } else switch (e) { case 1: t.blendFuncSeparate(770, 771, 1, 771); break; case 2: t.blendFunc(770, 1); break; case 3: t.blendFunc(0, 769); break; case 4: t.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) }f = null, p = null, m = null, g = null, l = e, v = c } } else u && (k(3042), u = !1) } function j(e) { y !== e && (e ? t.frontFace(2304) : t.frontFace(2305), y = e) } function B(e) { 0 !== e ? (C(2884), e !== x && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : k(2884), x = e } function F(e, r, n) { e ? (C(32823), w === r && M === n || (t.polygonOffset(r, n), w = r, M = n)) : k(32823) } function D(e) { void 0 === e && (e = 33984 + S - 1), A !== e && (t.activeTexture(e), A = e) } return { buffers: { color: i, depth: o, stencil: s }, enable: C, disable: k, useProgram: function (e) { return c !== e && (t.useProgram(e), c = e, !0) }, setBlending: U, setMaterial: function (t, e) { 2 === t.side ? k(2884) : C(2884); let r = 1 === t.side; e && (r = !r), j(r), 1 === t.blending && !1 === t.transparent ? U(0) : U(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), i.setMask(t.colorWrite); const n = t.stencilWrite; s.setTest(n), n && (s.setMask(t.stencilWriteMask), s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), F(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits) }, setFlipSided: j, setCullFace: B, setLineWidth: function (e) { e !== b && (_ && t.lineWidth(e), b = e) }, setPolygonOffset: F, setScissorTest: function (t) { t ? C(3089) : k(3089) }, activeTexture: D, bindTexture: function (e, r) { null === A && D(); let n = R[A]; void 0 === n && (n = { type: void 0, texture: void 0 }, R[A] = n), n.type === e && n.texture === r || (t.bindTexture(e, r || I[e]), n.type = e, n.texture = r) }, unbindTexture: function () { const e = R[A]; void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0) }, compressedTexImage2D: function () { try { t.compressedTexImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage2D: function () { try { t.texImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage3D: function () { try { t.texImage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, scissor: function (e) { !1 === L.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), L.copy(e)) }, viewport: function (e) { !1 === O.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), O.copy(e)) }, reset: function () { a = {}, A = null, R = {}, c = null, l = null, y = null, x = null, i.reset(), o.reset(), s.reset() } } } function ni(t, e, r, n, i, o, s) { const a = i.isWebGL2, c = i.maxTextures, u = i.maxCubemapSize, l = i.maxTextureSize, h = i.maxSamples, f = new WeakMap; let d, m = !1; try { m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (t) { } function g(t, e) { return m ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function v(t, e, r, n) { let i = 1; if ((t.width > n || t.height > n) && (i = n / Math.max(t.width, t.height)), i < 1 || !0 === e) { if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) { const n = e ? p.floorPowerOfTwo : Math.floor, o = n(i * t.width), s = n(i * t.height); void 0 === d && (d = g(o, s)); const a = r ? g(o, s) : d; a.width = o, a.height = s; return a.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), a } return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t } return t } function y(t) { return p.isPowerOfTwo(t.width) && p.isPowerOfTwo(t.height) } function x(t, e) { return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter } function b(e, r, i, o) { t.generateMipmap(e); n.get(r).__maxMipLevel = Math.log(Math.max(i, o)) * Math.LOG2E } function w(r, n, i) { if (!1 === a) return n; if (null !== r) { if (void 0 !== t[r]) return t[r]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + r + "'") } let o = n; return 6403 === n && (5126 === i && (o = 33326), 5131 === i && (o = 33325), 5121 === i && (o = 33321)), 6407 === n && (5126 === i && (o = 34837), 5131 === i && (o = 34843), 5121 === i && (o = 32849)), 6408 === n && (5126 === i && (o = 34836), 5131 === i && (o = 34842), 5121 === i && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o } function M(t) { return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729 } function S(e) { const r = e.target; r.removeEventListener("dispose", S), function (e) { const r = n.get(e); if (void 0 === r.__webglInit) return; t.deleteTexture(r.__webglTexture), n.remove(e) }(r), r.isVideoTexture && f.delete(r), s.memory.textures-- } function _(e) { const r = e.target; r.removeEventListener("dispose", _), function (e) { const r = n.get(e), i = n.get(e.texture); if (!e) return; void 0 !== i.__webglTexture && t.deleteTexture(i.__webglTexture); e.depthTexture && e.depthTexture.dispose(); if (e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++)t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]); else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer); n.remove(e.texture), n.remove(e) }(r), s.memory.textures-- } let T = 0; function E(t, e) { const i = n.get(t); if (t.isVideoTexture && function (t) { const e = s.render.frame; f.get(t) !== e && (f.set(t, e), t.update()) }(t), t.version > 0 && i.__version !== t.version) { const r = t.image; if (void 0 === r) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== r.complete) return void C(i, t, e); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } r.activeTexture(33984 + e), r.bindTexture(3553, i.__webglTexture) } function A(e, i) { if (6 !== e.image.length) return; const s = n.get(e); if (e.version > 0 && s.__version !== e.version) { I(s, e), r.activeTexture(33984 + i), r.bindTexture(34067, s.__webglTexture), t.pixelStorei(37440, e.flipY); const n = e && (e.isCompressedTexture || e.image[0].isCompressedTexture), c = e.image[0] && e.image[0].isDataTexture, l = []; for (let t = 0; t < 6; t++)l[t] = n || c ? c ? e.image[t].image : e.image[t] : v(e.image[t], !1, !0, u); const h = l[0], f = y(h) || a, p = o.convert(e.format), d = o.convert(e.type), m = w(e.internalFormat, p, d); let g; if (P(34067, e, f), n) { for (let t = 0; t < 6; t++) { g = l[t].mipmaps; for (let n = 0; n < g.length; n++) { const i = g[n]; 1023 !== e.format && 1022 !== e.format ? null !== p ? r.compressedTexImage2D(34069 + t, n, m, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : r.texImage2D(34069 + t, n, m, i.width, i.height, 0, p, d, i.data) } } s.__maxMipLevel = g.length - 1 } else { g = e.mipmaps; for (let t = 0; t < 6; t++)if (c) { r.texImage2D(34069 + t, 0, m, l[t].width, l[t].height, 0, p, d, l[t].data); for (let e = 0; e < g.length; e++) { const n = g[e].image[t].image; r.texImage2D(34069 + t, e + 1, m, n.width, n.height, 0, p, d, n.data) } } else { r.texImage2D(34069 + t, 0, m, p, d, l[t]); for (let e = 0; e < g.length; e++) { const n = g[e]; r.texImage2D(34069 + t, e + 1, m, p, d, n.image[t]) } } s.__maxMipLevel = g.length } x(e, f) && b(34067, e, h.width, h.height), s.__version = e.version, e.onUpdate && e.onUpdate(e) } else r.activeTexture(33984 + i), r.bindTexture(34067, s.__webglTexture) } function R(t, e) { r.activeTexture(33984 + e), r.bindTexture(34067, n.get(t).__webglTexture) } const L = { 1e3: 10497, 1001: 33071, 1002: 33648 }, O = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 }; function P(r, o, s) { s ? (t.texParameteri(r, 10242, L[o.wrapS]), t.texParameteri(r, 10243, L[o.wrapT]), 32879 !== r && 35866 !== r || t.texParameteri(r, 32882, L[o.wrapR]), t.texParameteri(r, 10240, O[o.magFilter]), t.texParameteri(r, 10241, O[o.minFilter])) : (t.texParameteri(r, 10242, 33071), t.texParameteri(r, 10243, 33071), 32879 !== r && 35866 !== r || t.texParameteri(r, 32882, 33071), 1001 === o.wrapS && 1001 === o.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(r, 10240, M(o.magFilter)), t.texParameteri(r, 10241, M(o.minFilter)), 1003 !== o.minFilter && 1006 !== o.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")); const c = e.get("EXT_texture_filter_anisotropic"); if (c) { if (1015 === o.type && null === e.get("OES_texture_float_linear")) return; if (1016 === o.type && null === (a || e.get("OES_texture_half_float_linear"))) return; (o.anisotropy > 1 || n.get(o).__currentAnisotropy) && (t.texParameterf(r, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, i.getMaxAnisotropy())), n.get(o).__currentAnisotropy = o.anisotropy) } } function I(e, r) { void 0 === e.__webglInit && (e.__webglInit = !0, r.addEventListener("dispose", S), e.__webglTexture = t.createTexture(), s.memory.textures++) } function C(e, n, i) { let s = 3553; n.isDataTexture2DArray && (s = 35866), n.isDataTexture3D && (s = 32879), I(e, n), r.activeTexture(33984 + i), r.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment); const c = function (t) { return !a && (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter) }(n) && !1 === y(n.image), u = v(n.image, c, !1, l), h = y(u) || a, f = o.convert(n.format); let p, d = o.convert(n.type), m = w(n.internalFormat, f, d); P(s, n, h); const g = n.mipmaps; if (n.isDepthTexture) m = 6402, a ? m = 1015 === n.type ? 36012 : 1014 === n.type ? 33190 : 1020 === n.type ? 35056 : 33189 : 1015 === n.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === n.format && 6402 === m && 1012 !== n.type && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = 1012, d = o.convert(n.type)), 1027 === n.format && 6402 === m && (m = 34041, 1020 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = 1020, d = o.convert(n.type))), r.texImage2D(3553, 0, m, u.width, u.height, 0, f, d, null); else if (n.isDataTexture) if (g.length > 0 && h) { for (let t = 0, e = g.length; t < e; t++)p = g[t], r.texImage2D(3553, t, m, p.width, p.height, 0, f, d, p.data); n.generateMipmaps = !1, e.__maxMipLevel = g.length - 1 } else r.texImage2D(3553, 0, m, u.width, u.height, 0, f, d, u.data), e.__maxMipLevel = 0; else if (n.isCompressedTexture) { for (let t = 0, e = g.length; t < e; t++)p = g[t], 1023 !== n.format && 1022 !== n.format ? null !== f ? r.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : r.texImage2D(3553, t, m, p.width, p.height, 0, f, d, p.data); e.__maxMipLevel = g.length - 1 } else if (n.isDataTexture2DArray) r.texImage3D(35866, 0, m, u.width, u.height, u.depth, 0, f, d, u.data), e.__maxMipLevel = 0; else if (n.isDataTexture3D) r.texImage3D(32879, 0, m, u.width, u.height, u.depth, 0, f, d, u.data), e.__maxMipLevel = 0; else if (g.length > 0 && h) { for (let t = 0, e = g.length; t < e; t++)p = g[t], r.texImage2D(3553, t, m, f, d, p); n.generateMipmaps = !1, e.__maxMipLevel = g.length - 1 } else r.texImage2D(3553, 0, m, f, d, u), e.__maxMipLevel = 0; x(n, h) && b(s, n, u.width, u.height), e.__version = n.version, n.onUpdate && n.onUpdate(n) } function k(e, i, s, a) { const c = o.convert(i.texture.format), u = o.convert(i.texture.type), l = w(i.texture.internalFormat, c, u); r.texImage2D(a, 0, l, i.width, i.height, 0, c, u, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, s, a, n.get(i.texture).__webglTexture, 0), t.bindFramebuffer(36160, null) } function N(e, r, n) { if (t.bindRenderbuffer(36161, e), r.depthBuffer && !r.stencilBuffer) { let i = 33189; if (n) { const e = r.depthTexture; e && e.isDepthTexture && (1015 === e.type ? i = 36012 : 1014 === e.type && (i = 33190)); const n = U(r); t.renderbufferStorageMultisample(36161, n, i, r.width, r.height) } else t.renderbufferStorage(36161, i, r.width, r.height); t.framebufferRenderbuffer(36160, 36096, 36161, e) } else if (r.depthBuffer && r.stencilBuffer) { if (n) { const e = U(r); t.renderbufferStorageMultisample(36161, e, 35056, r.width, r.height) } else t.renderbufferStorage(36161, 34041, r.width, r.height); t.framebufferRenderbuffer(36160, 33306, 36161, e) } else { const e = o.convert(r.texture.format), i = o.convert(r.texture.type), s = w(r.texture.internalFormat, e, i); if (n) { const e = U(r); t.renderbufferStorageMultisample(36161, e, s, r.width, r.height) } else t.renderbufferStorage(36161, s, r.width, r.height) } t.bindRenderbuffer(36161, null) } function z(e) { const r = n.get(e), i = !0 === e.isWebGLCubeRenderTarget; if (e.depthTexture) { if (i) throw new Error("target.depthTexture not supported in Cube render targets"); !function (e, r) { if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (t.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), E(r.depthTexture, 0); const i = n.get(r.depthTexture).__webglTexture; if (1026 === r.depthTexture.format) t.framebufferTexture2D(36160, 36096, 3553, i, 0); else { if (1027 !== r.depthTexture.format) throw new Error("Unknown depthTexture format"); t.framebufferTexture2D(36160, 33306, 3553, i, 0) } }(r.__webglFramebuffer, e) } else if (i) { r.__webglDepthbuffer = []; for (let n = 0; n < 6; n++)t.bindFramebuffer(36160, r.__webglFramebuffer[n]), r.__webglDepthbuffer[n] = t.createRenderbuffer(), N(r.__webglDepthbuffer[n], e, !1) } else t.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), N(r.__webglDepthbuffer, e, !1); t.bindFramebuffer(36160, null) } function U(t) { return a && t.isWebGLMultisampleRenderTarget ? Math.min(h, t.samples) : 0 } let j = !1, B = !1; this.allocateTextureUnit = function () { const t = T; return t >= c && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + c), T += 1, t }, this.resetTextureUnits = function () { T = 0 }, this.setTexture2D = E, this.setTexture2DArray = function (t, e) { const i = n.get(t); t.version > 0 && i.__version !== t.version ? C(i, t, e) : (r.activeTexture(33984 + e), r.bindTexture(35866, i.__webglTexture)) }, this.setTexture3D = function (t, e) { const i = n.get(t); t.version > 0 && i.__version !== t.version ? C(i, t, e) : (r.activeTexture(33984 + e), r.bindTexture(32879, i.__webglTexture)) }, this.setTextureCube = A, this.setTextureCubeDynamic = R, this.setupRenderTarget = function (e) { const i = n.get(e), c = n.get(e.texture); e.addEventListener("dispose", _), c.__webglTexture = t.createTexture(), s.memory.textures++; const u = !0 === e.isWebGLCubeRenderTarget, l = !0 === e.isWebGLMultisampleRenderTarget, h = y(e) || a; if (!a || 1022 !== e.texture.format || 1015 !== e.texture.type && 1016 !== e.texture.type || (e.texture.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) { i.__webglFramebuffer = []; for (let e = 0; e < 6; e++)i.__webglFramebuffer[e] = t.createFramebuffer() } else if (i.__webglFramebuffer = t.createFramebuffer(), l) if (a) { i.__webglMultisampledFramebuffer = t.createFramebuffer(), i.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, i.__webglColorRenderbuffer); const r = o.convert(e.texture.format), n = o.convert(e.texture.type), s = w(e.texture.internalFormat, r, n), a = U(e); t.renderbufferStorageMultisample(36161, a, s, e.width, e.height), t.bindFramebuffer(36160, i.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, i.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (i.__webglDepthRenderbuffer = t.createRenderbuffer(), N(i.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (u) { r.bindTexture(34067, c.__webglTexture), P(34067, e.texture, h); for (let t = 0; t < 6; t++)k(i.__webglFramebuffer[t], e, 36064, 34069 + t); x(e.texture, h) && b(34067, e.texture, e.width, e.height), r.bindTexture(34067, null) } else r.bindTexture(3553, c.__webglTexture), P(3553, e.texture, h), k(i.__webglFramebuffer, e, 36064, 3553), x(e.texture, h) && b(3553, e.texture, e.width, e.height), r.bindTexture(3553, null); e.depthBuffer && z(e) }, this.updateRenderTargetMipmap = function (t) { const e = t.texture; if (x(e, y(t) || a)) { const i = t.isWebGLCubeRenderTarget ? 34067 : 3553, o = n.get(e).__webglTexture; r.bindTexture(i, o), b(i, e, t.width, t.height), r.bindTexture(i, null) } }, this.updateMultisampleRenderTarget = function (e) { if (e.isWebGLMultisampleRenderTarget) if (a) { const r = n.get(e); t.bindFramebuffer(36008, r.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, r.__webglFramebuffer); const i = e.width, o = e.height; let s = 16384; e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024), t.blitFramebuffer(0, 0, i, o, 0, 0, i, o, s, 9728), t.bindFramebuffer(36160, r.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (t, e) { t && t.isWebGLRenderTarget && (!1 === j && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), j = !0), t = t.texture), E(t, e) }, this.safeSetTextureCube = function (t, e) { t && t.isWebGLCubeRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? A(t, e) : R(t, e) } } function ii(t, e, r) { const n = r.isWebGL2; return { convert: function (t) { let r; if (1009 === t) return 5121; if (1017 === t) return 32819; if (1018 === t) return 32820; if (1019 === t) return 33635; if (1010 === t) return 5120; if (1011 === t) return 5122; if (1012 === t) return 5123; if (1013 === t) return 5124; if (1014 === t) return 5125; if (1015 === t) return 5126; if (1016 === t) return n ? 5131 : (r = e.get("OES_texture_half_float"), null !== r ? r.HALF_FLOAT_OES : null); if (1021 === t) return 6406; if (1022 === t) return 6407; if (1023 === t) return 6408; if (1024 === t) return 6409; if (1025 === t) return 6410; if (1026 === t) return 6402; if (1027 === t) return 34041; if (1028 === t) return 6403; if (1029 === t) return 36244; if (1030 === t) return 33319; if (1031 === t) return 33320; if (1032 === t) return 36248; if (1033 === t) return 36249; if (33776 === t || 33777 === t || 33778 === t || 33779 === t) { if (r = e.get("WEBGL_compressed_texture_s3tc"), null === r) return null; if (33776 === t) return r.COMPRESSED_RGB_S3TC_DXT1_EXT; if (33777 === t) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (33778 === t) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (33779 === t) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (35840 === t || 35841 === t || 35842 === t || 35843 === t) { if (r = e.get("WEBGL_compressed_texture_pvrtc"), null === r) return null; if (35840 === t) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === t) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === t) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === t) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === t) return r = e.get("WEBGL_compressed_texture_etc1"), null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null; if ((37492 === t || 37496 === t) && (r = e.get("WEBGL_compressed_texture_etc"), null !== r)) { if (37492 === t) return r.COMPRESSED_RGB8_ETC2; if (37496 === t) return r.COMPRESSED_RGBA8_ETC2_EAC } return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (r = e.get("WEBGL_compressed_texture_astc"), null !== r ? t : null) : 36492 === t ? (r = e.get("EXT_texture_compression_bptc"), null !== r ? t : null) : 1020 === t ? n ? 34042 : (r = e.get("WEBGL_depth_texture"), null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null) : void 0 } } } function oi(t) { lr.call(this), this.cameras = t || [] } function si() { It.call(this), this.type = "Group" } function ai() { this._targetRay = null, this._grip = null, this._hand = null } function ci(t, e) { const r = this; let n = null, i = 1, o = null, s = "local-floor", a = null; const c = [], u = new Map, l = new lr; l.layers.enable(1), l.viewport = new it; const h = new lr; h.layers.enable(2), h.viewport = new it; const f = [l, h], p = new oi; p.layers.enable(1), p.layers.enable(2); let d = null, m = null; function g(t) { const e = u.get(t.inputSource); e && e.dispatchEvent({ type: t.type }) } function v() { u.forEach((function (t, e) { t.disconnect(e) })), u.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), T.stop(), r.isPresenting = !1, r.dispatchEvent({ type: "sessionend" }) } function y(t) { o = t, T.setContext(n), T.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" }) } function x(t) { const e = n.inputSources; for (let t = 0; t < c.length; t++)u.set(e[t], c[t]); for (let e = 0; e < t.removed.length; e++) { const r = t.removed[e], n = u.get(r); n && (n.dispatchEvent({ type: "disconnected", data: r }), u.delete(r)) } for (let e = 0; e < t.added.length; e++) { const r = t.added[e], n = u.get(r); n && n.dispatchEvent({ type: "connected", data: r }) } } this.enabled = !1, this.isPresenting = !1, this.getController = function (t) { let e = c[t]; return void 0 === e && (e = new ai, c[t] = e), e.getTargetRaySpace() }, this.getControllerGrip = function (t) { let e = c[t]; return void 0 === e && (e = new ai, c[t] = e), e.getGripSpace() }, this.getHand = function (t) { let e = c[t]; return void 0 === e && (e = new ai, c[t] = e), e.getHandSpace() }, this.setFramebufferScaleFactor = function (t) { i = t, !0 === r.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (t) { s = t, !0 === r.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return o }, this.getSession = function () { return n }, this.setSession = function (t) { if (n = t, null !== n) { n.addEventListener("select", g), n.addEventListener("selectstart", g), n.addEventListener("selectend", g), n.addEventListener("squeeze", g), n.addEventListener("squeezestart", g), n.addEventListener("squeezeend", g), n.addEventListener("end", v); const t = e.getContextAttributes(); !0 !== t.xrCompatible && e.makeXRCompatible(); const r = { antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: i }, o = new XRWebGLLayer(n, e, r); n.updateRenderState({ baseLayer: o }), n.requestReferenceSpace(s).then(y), n.addEventListener("inputsourceschange", x) } }; const b = new S, w = new S; function M(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld) } this.getCamera = function (t) { p.near = h.near = l.near = t.near, p.far = h.far = l.far = t.far, d === p.near && m === p.far || (n.updateRenderState({ depthNear: p.near, depthFar: p.far }), d = p.near, m = p.far); const e = t.parent, r = p.cameras; M(p, e); for (let t = 0; t < r.length; t++)M(r[t], e); t.matrixWorld.copy(p.matrixWorld); const i = t.children; for (let t = 0, e = i.length; t < e; t++)i[t].updateMatrixWorld(!0); return 2 === r.length ? function (t, e, r) { b.setFromMatrixPosition(e.matrixWorld), w.setFromMatrixPosition(r.matrixWorld); const n = b.distanceTo(w), i = e.projectionMatrix.elements, o = r.projectionMatrix.elements, s = i[14] / (i[10] - 1), a = i[14] / (i[10] + 1), c = (i[9] + 1) / i[5], u = (i[9] - 1) / i[5], l = (i[8] - 1) / i[0], h = (o[8] + 1) / o[0], f = s * l, p = s * h, d = n / (-l + h), m = d * -l; e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(d), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld); const g = s + d, v = a + d, y = f - m, x = p + (n - m), M = c * a / v * g, S = u * a / v * g; t.projectionMatrix.makePerspective(y, x, M, S, g, v) }(p, l, h) : p.projectionMatrix.copy(l.projectionMatrix), p }; let _ = null; const T = new ot; T.setAnimationLoop((function (e, r) { if (a = r.getViewerPose(o), null !== a) { const e = a.views, r = n.renderState.baseLayer; t.setFramebuffer(r.framebuffer); let i = !1; e.length !== p.cameras.length && (p.cameras.length = 0, i = !0); for (let t = 0; t < e.length; t++) { const n = e[t], o = r.getViewport(n), s = f[t]; s.matrix.fromArray(n.transform.matrix), s.projectionMatrix.fromArray(n.projectionMatrix), s.viewport.set(o.x, o.y, o.width, o.height), 0 === t && p.matrix.copy(s.matrix), !0 === i && p.cameras.push(s) } } const i = n.inputSources; for (let t = 0; t < c.length; t++) { const e = c[t], n = i[t]; e.update(n, r, o) } _ && _(e, r) })), this.setAnimationLoop = function (t) { _ = t }, this.dispose = function () { } } function ui(t) { function e(e, r) { e.opacity.value = r.opacity, r.color && e.diffuse.value.copy(r.color), r.emissive && e.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (e.map.value = r.map), r.alphaMap && (e.alphaMap.value = r.alphaMap), r.specularMap && (e.specularMap.value = r.specularMap); const n = t.get(r).envMap; if (n) { e.envMap.value = n, e.flipEnvMap.value = n.isCubeTexture ? -1 : 1, e.reflectivity.value = r.reflectivity, e.refractionRatio.value = r.refractionRatio; const i = t.get(n).__maxMipLevel; void 0 !== i && (e.maxMipLevel.value = i) } let i, o; r.lightMap && (e.lightMap.value = r.lightMap, e.lightMapIntensity.value = r.lightMapIntensity), r.aoMap && (e.aoMap.value = r.aoMap, e.aoMapIntensity.value = r.aoMapIntensity), r.map ? i = r.map : r.specularMap ? i = r.specularMap : r.displacementMap ? i = r.displacementMap : r.normalMap ? i = r.normalMap : r.bumpMap ? i = r.bumpMap : r.roughnessMap ? i = r.roughnessMap : r.metalnessMap ? i = r.metalnessMap : r.alphaMap ? i = r.alphaMap : r.emissiveMap ? i = r.emissiveMap : r.clearcoatMap ? i = r.clearcoatMap : r.clearcoatNormalMap ? i = r.clearcoatNormalMap : r.clearcoatRoughnessMap && (i = r.clearcoatRoughnessMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix)), r.aoMap ? o = r.aoMap : r.lightMap && (o = r.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), e.uv2Transform.value.copy(o.matrix)) } function r(e, r) { e.roughness.value = r.roughness, e.metalness.value = r.metalness, r.roughnessMap && (e.roughnessMap.value = r.roughnessMap), r.metalnessMap && (e.metalnessMap.value = r.metalnessMap), r.emissiveMap && (e.emissiveMap.value = r.emissiveMap), r.bumpMap && (e.bumpMap.value = r.bumpMap, e.bumpScale.value = r.bumpScale, 1 === r.side && (e.bumpScale.value *= -1)), r.normalMap && (e.normalMap.value = r.normalMap, e.normalScale.value.copy(r.normalScale), 1 === r.side && e.normalScale.value.negate()), r.displacementMap && (e.displacementMap.value = r.displacementMap, e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias); t.get(r).envMap && (e.envMapIntensity.value = r.envMapIntensity) } return { refreshFogUniforms: function (t, e) { t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density) }, refreshMaterialUniforms: function (t, n, i, o) { n.isMeshBasicMaterial ? e(t, n) : n.isMeshLambertMaterial ? (e(t, n), function (t, e) { e.emissiveMap && (t.emissiveMap.value = e.emissiveMap) }(t, n)) : n.isMeshToonMaterial ? (e(t, n), function (t, e) { e.gradientMap && (t.gradientMap.value = e.gradientMap); e.emissiveMap && (t.emissiveMap.value = e.emissiveMap); e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, n)) : n.isMeshPhongMaterial ? (e(t, n), function (t, e) { t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap); e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, n)) : n.isMeshStandardMaterial ? (e(t, n), n.isMeshPhysicalMaterial ? function (t, e) { r(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen); e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap); e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap); e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate()); t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap) }(t, n) : r(t, n)) : n.isMeshMatcapMaterial ? (e(t, n), function (t, e) { e.matcap && (t.matcap.value = e.matcap); e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, n)) : n.isMeshDepthMaterial ? (e(t, n), function (t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, n)) : n.isMeshDistanceMaterial ? (e(t, n), function (t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias); t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance }(t, n)) : n.isMeshNormalMaterial ? (e(t, n), function (t, e) { e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, n)) : n.isLineBasicMaterial ? (function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity }(t, n), n.isLineDashedMaterial && function (t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(t, n)) : n.isPointsMaterial ? function (t, e, r, n) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * r, t.scale.value = .5 * n, e.map && (t.map.value = e.map); e.alphaMap && (t.alphaMap.value = e.alphaMap); let i; e.map ? i = e.map : e.alphaMap && (i = e.alphaMap); void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix)) }(t, n, i, o) : n.isSpriteMaterial ? function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map); e.alphaMap && (t.alphaMap.value = e.alphaMap); let r; e.map ? r = e.map : e.alphaMap && (r = e.alphaMap); void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)) }(t, n) : n.isShadowMaterial ? (t.color.value.copy(n.color), t.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = !1) } } } function li(t) { const e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), r = void 0 !== t.context ? t.context : null, n = void 0 !== t.alpha && t.alpha, i = void 0 === t.depth || t.depth, o = void 0 === t.stencil || t.stencil, s = void 0 !== t.antialias && t.antialias, a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, u = void 0 !== t.powerPreference ? t.powerPreference : "default", l = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat; let h = null, f = null; this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; const d = this; let g = !1, v = null, y = 0, x = 0, b = null, M = null, _ = -1, T = null, E = null; const A = new it, R = new it; let L = null, O = e.width, P = e.height, I = 1, C = null, k = null; const N = new it(0, 0, O, P), z = new it(0, 0, O, P); let U = !1; const j = new Z; let B = !1, F = !1; const D = new K, G = new S, V = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function H() { return null === b ? I : 1 } let W, q, X, Y, J, Q, $, tt, et, rt, nt, at, ct, ut, lt, ht, ft, pt, dt, mt, gt, vt = r; function yt(t, r) { for (let n = 0; n < t.length; n++) { const i = t[n], o = e.getContext(i, r); if (null !== o) return o } return null } try { const t = { alpha: n, depth: i, stencil: o, antialias: s, premultipliedAlpha: a, preserveDrawingBuffer: c, powerPreference: u, failIfMajorPerformanceCaveat: l }; if (e.addEventListener("webglcontextlost", Mt, !1), e.addEventListener("webglcontextrestored", St, !1), null === vt) { const e = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === d.isWebGL1Renderer && e.shift(), vt = yt(e, t), null === vt) throw yt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === vt.getShaderPrecisionFormat && (vt.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (t) { throw console.error("THREE.WebGLRenderer: " + t.message), t } function xt() { W = new dr(vt), q = new sr(vt, W, t), !1 === q.isWebGL2 && (W.get("WEBGL_depth_texture"), W.get("OES_texture_float"), W.get("OES_texture_half_float"), W.get("OES_texture_half_float_linear"), W.get("OES_standard_derivatives"), W.get("OES_element_index_uint"), W.get("OES_vertex_array_object"), W.get("ANGLE_instanced_arrays")), W.get("OES_texture_float_linear"), mt = new ii(vt, W, q), X = new ri(vt, W, q), X.scissor(R.copy(z).multiplyScalar(I).floor()), X.viewport(A.copy(N).multiplyScalar(I).floor()), Y = new vr(vt), J = new Gn, Q = new ni(vt, W, X, J, q, mt, Y), $ = new pr(d), tt = new st(vt, q), gt = new ir(vt, W, tt, q), et = new mr(vt, tt, Y, gt), rt = new wr(vt, et, tt, Y), ft = new br(vt), lt = new ar(J), nt = new Dn(d, $, W, q, gt, lt), at = new ui(J), ct = new qn(J), ut = new Qn, ht = new nr(d, $, X, rt, a), pt = new or(vt, W, Y, q), dt = new gr(vt, W, Y, q), Y.programs = nt.programs, d.capabilities = q, d.extensions = W, d.properties = J, d.renderLists = ct, d.state = X, d.info = Y } xt(); const bt = new ci(d, vt); this.xr = bt; const wt = new ei(d, rt, q.maxTextureSize); function Mt(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0 } function St() { console.log("THREE.WebGLRenderer: Context Restored."), g = !1, xt() } function _t(t) { const e = t.target; e.removeEventListener("dispose", _t), function (t) { Tt(t), J.remove(t) }(e) } function Tt(t) { const e = J.get(t).program; void 0 !== e && nt.releaseProgram(e) } this.shadowMap = wt, this.getContext = function () { return vt }, this.getContextAttributes = function () { return vt.getContextAttributes() }, this.forceContextLoss = function () { const t = W.get("WEBGL_lose_context"); t && t.loseContext() }, this.forceContextRestore = function () { const t = W.get("WEBGL_lose_context"); t && t.restoreContext() }, this.getPixelRatio = function () { return I }, this.setPixelRatio = function (t) { void 0 !== t && (I = t, this.setSize(O, P, !1)) }, this.getSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new m), t.set(O, P) }, this.setSize = function (t, r, n) { bt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (O = t, P = r, e.width = Math.floor(t * I), e.height = Math.floor(r * I), !1 !== n && (e.style.width = t + "px", e.style.height = r + "px"), this.setViewport(0, 0, t, r)) }, this.getDrawingBufferSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new m), t.set(O * I, P * I).floor() }, this.setDrawingBufferSize = function (t, r, n) { O = t, P = r, I = n, e.width = Math.floor(t * n), e.height = Math.floor(r * n), this.setViewport(0, 0, t, r) }, this.getCurrentViewport = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new it), t.copy(A) }, this.getViewport = function (t) { return t.copy(N) }, this.setViewport = function (t, e, r, n) { t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, r, n), X.viewport(A.copy(N).multiplyScalar(I).floor()) }, this.getScissor = function (t) { return t.copy(z) }, this.setScissor = function (t, e, r, n) { t.isVector4 ? z.set(t.x, t.y, t.z, t.w) : z.set(t, e, r, n), X.scissor(R.copy(z).multiplyScalar(I).floor()) }, this.getScissorTest = function () { return U }, this.setScissorTest = function (t) { X.setScissorTest(U = t) }, this.setOpaqueSort = function (t) { C = t }, this.setTransparentSort = function (t) { k = t }, this.getClearColor = function () { return ht.getClearColor() }, this.setClearColor = function () { ht.setClearColor.apply(ht, arguments) }, this.getClearAlpha = function () { return ht.getClearAlpha() }, this.setClearAlpha = function () { ht.setClearAlpha.apply(ht, arguments) }, this.clear = function (t, e, r) { let n = 0; (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === r || r) && (n |= 1024), vt.clear(n) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { e.removeEventListener("webglcontextlost", Mt, !1), e.removeEventListener("webglcontextrestored", St, !1), ct.dispose(), ut.dispose(), J.dispose(), $.dispose(), rt.dispose(), gt.dispose(), bt.dispose(), At.stop() }, this.renderBufferImmediate = function (t, e) { gt.initAttributes(); const r = J.get(t); t.hasPositions && !r.position && (r.position = vt.createBuffer()), t.hasNormals && !r.normal && (r.normal = vt.createBuffer()), t.hasUvs && !r.uv && (r.uv = vt.createBuffer()), t.hasColors && !r.color && (r.color = vt.createBuffer()); const n = e.getAttributes(); t.hasPositions && (vt.bindBuffer(34962, r.position), vt.bufferData(34962, t.positionArray, 35048), gt.enableAttribute(n.position), vt.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), t.hasNormals && (vt.bindBuffer(34962, r.normal), vt.bufferData(34962, t.normalArray, 35048), gt.enableAttribute(n.normal), vt.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (vt.bindBuffer(34962, r.uv), vt.bufferData(34962, t.uvArray, 35048), gt.enableAttribute(n.uv), vt.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), t.hasColors && (vt.bindBuffer(34962, r.color), vt.bufferData(34962, t.colorArray, 35048), gt.enableAttribute(n.color), vt.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), gt.disableUnusedAttributes(), vt.drawArrays(4, 0, t.count), t.count = 0 }, this.renderBufferDirect = function (t, e, r, n, i, o) { null === e && (e = V); const s = i.isMesh && i.matrixWorld.determinant() < 0, a = It(t, e, n, i); X.setMaterial(n, s); let c = r.index; const u = r.attributes.position; if (null === c) { if (void 0 === u || 0 === u.count) return } else if (0 === c.count) return; let l, h = 1; !0 === n.wireframe && (c = et.getWireframeAttribute(r), h = 2), (n.morphTargets || n.morphNormals) && ft.update(i, r, n, a), gt.setup(i, n, a, r, c); let f = pt; null !== c && (l = tt.get(c), f = dt, f.setIndex(l)); const p = null !== c ? c.count : u.count, d = r.drawRange.start * h, m = r.drawRange.count * h, g = null !== o ? o.start * h : 0, v = null !== o ? o.count * h : 1 / 0, y = Math.max(d, g), x = Math.min(p, d + m, g + v) - 1, b = Math.max(0, x - y + 1); if (0 !== b) { if (i.isMesh) !0 === n.wireframe ? (X.setLineWidth(n.wireframeLinewidth * H()), f.setMode(1)) : f.setMode(4); else if (i.isLine) { let t = n.linewidth; void 0 === t && (t = 1), X.setLineWidth(t * H()), i.isLineSegments ? f.setMode(1) : i.isLineLoop ? f.setMode(2) : f.setMode(3) } else i.isPoints ? f.setMode(0) : i.isSprite && f.setMode(4); if (i.isInstancedMesh) f.renderInstances(y, b, i.count); else if (r.isInstancedBufferGeometry) { const t = Math.min(r.instanceCount, r._maxInstanceCount); f.renderInstances(y, b, t) } else f.render(y, b) } }, this.compile = function (t, e) { f = ut.get(t, e), f.init(), t.traverse((function (t) { t.isLight && (f.pushLight(t), t.castShadow && f.pushShadow(t)) })), f.setupLights(e); const r = new WeakMap; t.traverse((function (e) { const n = e.material; if (n) if (Array.isArray(n)) for (let i = 0; i < n.length; i++) { const o = n[i]; !1 === r.has(o) && (Pt(o, t, e), r.set(o)) } else !1 === r.has(n) && (Pt(n, t, e), r.set(n)) })) }; let Et = null; const At = new ot; function Rt(t, e, r, n) { if (!1 === t.visible) return; if (t.layers.test(e.layers)) if (t.isGroup) r = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(e); else if (t.isLight) f.pushLight(t), t.castShadow && f.pushShadow(t); else if (t.isSprite) { if (!t.frustumCulled || j.intersectsSprite(t)) { n && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(D); const e = rt.update(t), i = t.material; i.visible && h.push(t, e, i, r, G.z, null) } } else if (t.isImmediateRenderObject) n && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(D), h.push(t, null, t.material, r, G.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== Y.render.frame && (t.skeleton.update(), t.skeleton.frame = Y.render.frame), !t.frustumCulled || j.intersectsObject(t))) { n && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(D); const e = rt.update(t), i = t.material; if (Array.isArray(i)) { const n = e.groups; for (let o = 0, s = n.length; o < s; o++) { const s = n[o], a = i[s.materialIndex]; a && a.visible && h.push(t, e, a, r, G.z, s) } } else i.visible && h.push(t, e, i, r, G.z, null) } const i = t.children; for (let t = 0, o = i.length; t < o; t++)Rt(i[t], e, r, n) } function Lt(t, e, r) { const n = !0 === e.isScene ? e.overrideMaterial : null; for (let i = 0, o = t.length; i < o; i++) { const o = t[i], s = o.object, a = o.geometry, c = null === n ? o.material : n, u = o.group; if (r.isArrayCamera) { E = r; const t = r.cameras; for (let r = 0, n = t.length; r < n; r++) { const n = t[r]; s.layers.test(n.layers) && (X.viewport(A.copy(n.viewport)), f.setupLights(n), Ot(s, e, n, a, c, u)) } } else E = null, Ot(s, e, r, a, c, u) } } function Ot(t, e, r, n, i, o) { if (t.onBeforeRender(d, e, r, n, i, o), f = ut.get(e, E || r), t.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) { const n = It(r, e, i, t); X.setMaterial(i), gt.reset(), function (t, e) { t.render((function (t) { d.renderBufferImmediate(t, e) })) }(t, n) } else d.renderBufferDirect(r, e, n, i, t, o); t.onAfterRender(d, e, r, n, i, o), f = ut.get(e, E || r) } function Pt(t, e, r) { !0 !== e.isScene && (e = V); const n = J.get(t), i = f.state.lights, o = f.state.shadowsArray, s = i.state.version, a = nt.getParameters(t, i.state, o, e, r), c = nt.getProgramCacheKey(a); let u = n.program, l = !0; if (void 0 === u) t.addEventListener("dispose", _t); else if (u.cacheKey !== c) Tt(t); else if (n.lightsStateVersion !== s) l = !1; else { if (void 0 !== a.shaderID) { const r = t.isMeshStandardMaterial ? e.environment : null; return void (n.envMap = $.get(t.envMap || r)) } l = !1 } l && (a.uniforms = nt.getUniforms(t), t.onBeforeCompile(a, d), u = nt.acquireProgram(a, c), n.program = u, n.uniforms = a.uniforms, n.outputEncoding = a.outputEncoding); const h = n.uniforms; (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = lt.numPlanes, n.numIntersection = lt.numIntersection, h.clippingPlanes = lt.uniform), n.environment = t.isMeshStandardMaterial ? e.environment : null, n.fog = e.fog, n.envMap = $.get(t.envMap || n.environment), n.needsLights = function (t) { return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights }(t), n.lightsStateVersion = s, n.needsLights && (h.ambientLightColor.value = i.state.ambient, h.lightProbe.value = i.state.probe, h.directionalLights.value = i.state.directional, h.directionalLightShadows.value = i.state.directionalShadow, h.spotLights.value = i.state.spot, h.spotLightShadows.value = i.state.spotShadow, h.rectAreaLights.value = i.state.rectArea, h.ltc_1.value = i.state.rectAreaLTC1, h.ltc_2.value = i.state.rectAreaLTC2, h.pointLights.value = i.state.point, h.pointLightShadows.value = i.state.pointShadow, h.hemisphereLights.value = i.state.hemi, h.directionalShadowMap.value = i.state.directionalShadowMap, h.directionalShadowMatrix.value = i.state.directionalShadowMatrix, h.spotShadowMap.value = i.state.spotShadowMap, h.spotShadowMatrix.value = i.state.spotShadowMatrix, h.pointShadowMap.value = i.state.pointShadowMap, h.pointShadowMatrix.value = i.state.pointShadowMatrix); const p = n.program.getUniforms(), m = bn.seqWithValue(p.seq, h); n.uniformsList = m } function It(t, e, r, n) { !0 !== e.isScene && (e = V), Q.resetTextureUnits(); const i = e.fog, o = r.isMeshStandardMaterial ? e.environment : null, s = null === b ? d.outputEncoding : b.texture.encoding, a = $.get(r.envMap || o), c = J.get(r), u = f.state.lights; if (!0 === B && (!0 === F || t !== T)) { const e = t === T && r.id === _; lt.setState(r, t, e) } r.version === c.__version ? r.fog && c.fog !== i || c.environment !== o || c.needsLights && c.lightsStateVersion !== u.state.version ? Pt(r, e, n) : void 0 === c.numClippingPlanes || c.numClippingPlanes === lt.numPlanes && c.numIntersection === lt.numIntersection ? (c.outputEncoding !== s || c.envMap !== a) && Pt(r, e, n) : Pt(r, e, n) : (Pt(r, e, n), c.__version = r.version); let l = !1, h = !1, m = !1; const g = c.program, v = g.getUniforms(), y = c.uniforms; if (X.useProgram(g.program) && (l = !0, h = !0, m = !0), r.id !== _ && (_ = r.id, h = !0), l || T !== t) { if (v.setValue(vt, "projectionMatrix", t.projectionMatrix), q.logarithmicDepthBuffer && v.setValue(vt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), T !== t && (T = t, h = !0, m = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshStandardMaterial || r.envMap) { const e = v.map.cameraPosition; void 0 !== e && e.setValue(vt, G.setFromMatrixPosition(t.matrixWorld)) } (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && v.setValue(vt, "isOrthographic", !0 === t.isOrthographicCamera), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.isShadowMaterial || r.skinning) && v.setValue(vt, "viewMatrix", t.matrixWorldInverse) } if (r.skinning) { v.setOptional(vt, n, "bindMatrix"), v.setOptional(vt, n, "bindMatrixInverse"); const t = n.skeleton; if (t) { const e = t.bones; if (q.floatVertexTextures) { if (void 0 === t.boneTexture) { let r = Math.sqrt(4 * e.length); r = p.ceilPowerOfTwo(r), r = Math.max(r, 4); const n = new Float32Array(r * r * 4); n.set(t.boneMatrices); const i = new w(n, r, r, 1023, 1015); t.boneMatrices = n, t.boneTexture = i, t.boneTextureSize = r } v.setValue(vt, "boneTexture", t.boneTexture, Q), v.setValue(vt, "boneTextureSize", t.boneTextureSize) } else v.setOptional(vt, t, "boneMatrices") } } var x, M; return (h || c.receiveShadow !== n.receiveShadow) && (c.receiveShadow = n.receiveShadow, v.setValue(vt, "receiveShadow", n.receiveShadow)), h && (v.setValue(vt, "toneMappingExposure", d.toneMappingExposure), c.needsLights && (M = m, (x = y).ambientLightColor.needsUpdate = M, x.lightProbe.needsUpdate = M, x.directionalLights.needsUpdate = M, x.directionalLightShadows.needsUpdate = M, x.pointLights.needsUpdate = M, x.pointLightShadows.needsUpdate = M, x.spotLights.needsUpdate = M, x.spotLightShadows.needsUpdate = M, x.rectAreaLights.needsUpdate = M, x.hemisphereLights.needsUpdate = M), i && r.fog && at.refreshFogUniforms(y, i), at.refreshMaterialUniforms(y, r, I, P), bn.upload(vt, c.uniformsList, y, Q)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (bn.upload(vt, c.uniformsList, y, Q), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && v.setValue(vt, "center", n.center), v.setValue(vt, "modelViewMatrix", n.modelViewMatrix), v.setValue(vt, "normalMatrix", n.normalMatrix), v.setValue(vt, "modelMatrix", n.matrixWorld), g } At.setAnimationLoop((function (t) { bt.isPresenting || Et && Et(t) })), "undefined" != typeof window && At.setContext(window), this.setAnimationLoop = function (t) { Et = t, bt.setAnimationLoop(t), null === t ? At.stop() : At.start() }, this.render = function (t, e) { let r, n; if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), r = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), n = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === g) return; gt.resetDefaultState(), _ = -1, T = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === bt.enabled && !0 === bt.isPresenting && (e = bt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(d, t, e, r || b), f = ut.get(t, e), f.init(), D.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), j.setFromProjectionMatrix(D), F = this.localClippingEnabled, B = lt.init(this.clippingPlanes, F, e), h = ct.get(t, e), h.init(), Rt(t, e, 0, d.sortObjects), h.finish(), !0 === d.sortObjects && h.sort(C, k), !0 === B && lt.beginShadows(); const i = f.state.shadowsArray; wt.render(i, t, e), f.setupLights(e), !0 === B && lt.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== r && this.setRenderTarget(r), ht.render(h, t, e, n); const o = h.opaque, s = h.transparent; o.length > 0 && Lt(o, t, e), s.length > 0 && Lt(s, t, e), !0 === t.isScene && t.onAfterRender(d, t, e), null !== b && (Q.updateRenderTargetMipmap(b), Q.updateMultisampleRenderTarget(b)), X.buffers.depth.setTest(!0), X.buffers.depth.setMask(!0), X.buffers.color.setMask(!0), X.setPolygonOffset(!1), h = null, f = null }, this.setFramebuffer = function (t) { v !== t && null === b && vt.bindFramebuffer(36160, t), v = t }, this.getActiveCubeFace = function () { return y }, this.getActiveMipmapLevel = function () { return x }, this.getRenderList = function () { return h }, this.setRenderList = function (t) { h = t }, this.getRenderState = function () { return f }, this.setRenderState = function (t) { f = t }, this.getRenderTarget = function () { return b }, this.setRenderTarget = function (t, e = 0, r = 0) { b = t, y = e, x = r, t && void 0 === J.get(t).__webglFramebuffer && Q.setupRenderTarget(t); let n = v, i = !1; if (t) { const r = J.get(t).__webglFramebuffer; t.isWebGLCubeRenderTarget ? (n = r[e], i = !0) : n = t.isWebGLMultisampleRenderTarget ? J.get(t).__webglMultisampledFramebuffer : r, A.copy(t.viewport), R.copy(t.scissor), L = t.scissorTest } else A.copy(N).multiplyScalar(I).floor(), R.copy(z).multiplyScalar(I).floor(), L = U; if (M !== n && (vt.bindFramebuffer(36160, n), M = n), X.viewport(A), X.scissor(R), X.setScissorTest(L), i) { const n = J.get(t.texture); vt.framebufferTexture2D(36160, 36064, 34069 + e, n.__webglTexture, r) } }, this.readRenderTargetPixels = function (t, e, r, n, i, o, s) { if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let a = J.get(t).__webglFramebuffer; if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) { let s = !1; a !== M && (vt.bindFramebuffer(36160, a), s = !0); try { const a = t.texture, c = a.format, u = a.type; if (1023 !== c && mt.convert(c) !== vt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); if (!(1009 === u || mt.convert(u) === vt.getParameter(35738) || 1015 === u && (q.isWebGL2 || W.get("OES_texture_float") || W.get("WEBGL_color_buffer_float")) || 1016 === u && (q.isWebGL2 ? W.get("EXT_color_buffer_float") : W.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === vt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - n && r >= 0 && r <= t.height - i && vt.readPixels(e, r, n, i, mt.convert(c), mt.convert(u), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { s && vt.bindFramebuffer(36160, M) } } }, this.copyFramebufferToTexture = function (t, e, r) { void 0 === r && (r = 0); const n = Math.pow(2, -r), i = Math.floor(e.image.width * n), o = Math.floor(e.image.height * n), s = mt.convert(e.format); Q.setTexture2D(e, 0), vt.copyTexImage2D(3553, r, s, t.x, t.y, i, o, 0), X.unbindTexture() }, this.copyTextureToTexture = function (t, e, r, n) { void 0 === n && (n = 0); const i = e.image.width, o = e.image.height, s = mt.convert(r.format), a = mt.convert(r.type); Q.setTexture2D(r, 0), vt.pixelStorei(37440, r.flipY), vt.pixelStorei(37441, r.premultiplyAlpha), vt.pixelStorei(3317, r.unpackAlignment), e.isDataTexture ? vt.texSubImage2D(3553, n, t.x, t.y, i, o, s, a, e.image.data) : e.isCompressedTexture ? vt.compressedTexSubImage2D(3553, n, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : vt.texSubImage2D(3553, n, t.x, t.y, s, a, e.image), 0 === n && r.generateMipmaps && vt.generateMipmap(3553), X.unbindTexture() }, this.initTexture = function (t) { Q.setTexture2D(t, 0), X.unbindTexture() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } function hi(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } oi.prototype = Object.assign(Object.create(lr.prototype), { constructor: oi, isArrayCamera: !0 }), si.prototype = Object.assign(Object.create(It.prototype), { constructor: si, isGroup: !0 }), Object.assign(ai.prototype, { constructor: ai, getHandSpace: function () { if (null === this._hand && (this._hand = new si, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = { pinching: !1 }, window.XRHand)) for (let t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) { const t = new si; t.matrixAutoUpdate = !1, t.visible = !1, this._hand.joints.push(t), this._hand.add(t) } return this._hand }, getTargetRaySpace: function () { return null === this._targetRay && (this._targetRay = new si, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay }, getGripSpace: function () { return null === this._grip && (this._grip = new si, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip }, dispatchEvent: function (t) { return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this }, disconnect: function (t) { return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this }, update: function (t, e, r) { let n = null, i = null, o = null; const s = this._targetRay, a = this._grip, c = this._hand; if (t) if (c && t.hand) { o = !0; for (let n = 0; n <= window.XRHand.LITTLE_PHALANX_TIP; n++)if (t.hand[n]) { const i = e.getJointPose(t.hand[n], r), o = c.joints[n]; null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.jointRadius = i.radius), o.visible = null !== i; const s = c.joints[window.XRHand.INDEX_PHALANX_TIP], a = c.joints[window.XRHand.THUMB_PHALANX_TIP], u = s.position.distanceTo(a.position), l = .02, h = .005; c.inputState.pinching && u > l + h ? (c.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !c.inputState.pinching && u <= l - h && (c.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this })) } } else null !== s && (n = e.getPose(t.targetRaySpace, r), null !== n && (s.matrix.fromArray(n.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale))), null !== a && t.gripSpace && (i = e.getPose(t.gripSpace, r), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale))); return null !== s && (s.visible = null !== n), null !== a && (a.visible = null !== i), null !== c && (c.visible = null !== o), this } }), Object.assign(ci.prototype, d.prototype), window.WIDTH = window.innerWidth, window.HEIGHT = window.innerHeight, window.Time = { delta: 0, elapsed: 0 }; var fi = r(150).default; var pi = function () { function t(e) { if (function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), e = void 0 !== e ? e : {}, this._options = e, this.clock = new n, this.paused = !1, this.cameras = [], this.scene = null, this._drawCalls = 0, this._onUpdateCallback = e.onUpdate, this._onRenderCallback = e.onRender, this._onResizeCallback = e.onResize, this.renderer = new li({ alpha: !1, antialias: !1, canvas: e.canvas || document.querySelector("canvas"), preserveDrawingBuffer: void 0 !== e.preserveDrawingBuffer ? e.preserveDrawingBuffer : void 0 }), this.config = { profiling: void 0 !== e.profiling && e.profiling, logDrawCalls: void 0 !== e.logDrawCalls && e.logDrawCalls }, e && e.maxPixelRatio) var r = window.devicePixelRatio > e.maxPixelRatio ? e.maxPixelRatio : window.devicePixelRatio; else r = window.devicePixelRatio; this.renderer.setPixelRatio(r), this.setSize(e.width || window.innerWidth, e.height || window.innerHeight), void 0 !== e.autoClear && (this.renderer.autoClear = e.autoClear), void 0 !== e.clearColor && this.renderer.setClearColor(e.clearColor), window.addEventListener("resize", this.onWindowResize.bind(this), !1), this.renderer.domElement.addEventListener("mousemove", (function (t) { window.mouseX = t.pageX / WIDTH * 2 - 1, window.mouseY = 1 - t.pageY / HEIGHT * 2 })), function (t) { var e, r; void 0 !== document.hidden ? (e = "hidden", r = "visibilitychange") : void 0 !== document.mozHidden ? (e = "mozHidden", r = "mozvisibilitychange") : void 0 !== document.msHidden ? (e = "msHidden", r = "msvisibilitychange") : void 0 !== document.webkitHidden && (e = "webkitHidden", r = "webkitvisibilitychange"); void 0 !== document.addEventListener && document.addEventListener(r, (function () { document[e] ? t.onLeaveTab() : setTimeout(t.onFocusTab.bind(t), 50) }), !1) }(this) } var e, r, i; return e = t, (r = [{ key: "render", value: function () { this._onRenderCallback && this._onRenderCallback() } }, { key: "renderScene", value: function (t, e) { this.renderer.render(t, e), this.config.logDrawCalls && (this._drawCalls += this.renderer.info.render.calls) } }, { key: "update", value: function () { this.cameras.forEach((function (t) { t.updateMatrixWorld(!0), t.matrixWorldInverse.getInverse(t.matrixWorld) }), this), this._onUpdateCallback && this._onUpdateCallback() } }, { key: "doUpdate", value: function () { if (Time.delta = this.clock.getDelta(), Time.elapsed = this.clock.getElapsedTime(), !this.paused) { requestAnimationFrame(this.doUpdate.bind(this)), this.config.logDrawCalls && (this._drawCalls = 0), this.config.profiling && console.time("update"), this.update(), this.config.profiling && console.timeEnd("update"), this.render(), this.config.logDrawCalls && this.logDrawCalls(this._drawCalls); var t = void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(); fi.update(t) } } }, { key: "start", value: function () { this.started || (this.doUpdate(), this.started = !0) } }, { key: "pause", value: function () { this.paused || (this.clock.stop(), this.paused = !0) } }, { key: "resume", value: function () { this.paused && (this.clock.start(), this.paused = !1, this.started && this.doUpdate()) } }, { key: "onLeaveTab", value: function () { this.paused || (this.pause(), this.shouldResume = !0) } }, { key: "onFocusTab", value: function () { this.shouldResume && (this.resume(), this.shouldResume = !1) } }, { key: "setAspectRatio", value: function (t) { this.cameras.forEach((function (e) { e.aspect = t, e.updateProjectionMatrix() }), this) } }, { key: "refreshAspectRatio", value: function () { var t = this.renderer.getSize(); this.setAspectRatio(t.width / t.height) } }, { key: "setSize", value: function (t, e) { this.setAspectRatio(t / e), this.renderer.setSize(t, e) } }, { key: "logDrawCalls", value: function (t) { console.log("Draw calls:", t) } }, { key: "onWindowResize", value: function () { var t = window.WIDTH = window.innerWidth, e = window.HEIGHT = window.innerHeight; this.setSize(t, e), this._onResizeCallback && this._onResizeCallback(t, e) } }]) && hi(e.prototype, r), i && hi(e, i), t }(); function di(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } var mi = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.enabled = e.enabled, this.frames = 0, this.fps = 0, this.lastTime = 0, this.enabled && (this.counterEl = document.createElement("div"), document.querySelectorAll("body")[0].appendChild(this.counterEl), this.counterEl.setAttribute("style", "position:absolute;top:80px;left:50px;color:#fff;display:block !important;z-index:999999;background:#000")) } var e, r, n; return e = t, (r = [{ key: "update", value: function () { if (this.enabled) { var t = 1e3 * Time.elapsed; this.frames++, t > this.lastTime + 1e3 && (this.fps = Math.round(1e3 * this.frames / (t - this.lastTime)), this.counterEl.textContent = this.fps + " FPS", this.lastTime = t, this.frames = 0) } } }]) && di(e.prototype, r), n && di(e, n), t }(); class gi { constructor(t = 1, e = 0, r = 0) { return this.radius = t, this.phi = e, this.theta = r, this } set(t, e, r) { return this.radius = t, this.phi = e, this.theta = r, this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(t) { return this.setFromCartesianCoords(t.x, t.y, t.z) } setFromCartesianCoords(t, e, r) { return this.radius = Math.sqrt(t * t + e * e + r * r), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, r), this.phi = Math.acos(p.clamp(e / this.radius, -1, 1))), this } } var vi = function (t, e) { var r, n, h, f, p; void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t, this.domElement = e, this.enabled = !0, this.target = new S, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !1, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }, this.mouseButtons = { LEFT: i, MIDDLE: o, RIGHT: s }, this.touches = { ONE: a, TWO: u }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function () { return _.phi }, this.getAzimuthalAngle = function () { return _.theta }, this.saveState = function () { d.target0.copy(d.target), d.position0.copy(d.object.position), d.zoom0 = d.object.zoom }, this.reset = function () { d.target.copy(d.target0), d.object.position.copy(d.position0), d.object.zoom = d.zoom0, d.object.updateProjectionMatrix(), d.dispatchEvent(g), d.update(), b = x.NONE }, this.update = (r = new S, n = (new M).setFromUnitVectors(t.up, new S(0, 1, 0)), h = n.clone().inverse(), f = new S, p = new M, function () { var t = d.object.position; return r.copy(t).sub(d.target), r.applyQuaternion(n), _.setFromVector3(r), d.autoRotate && b === x.NONE && B(2 * Math.PI / 60 / 60 * d.autoRotateSpeed), d.enableDamping ? (_.theta += T.theta * d.dampingFactor, _.phi += T.phi * d.dampingFactor) : (_.theta += T.theta, _.phi += T.phi), _.theta = Math.max(d.minAzimuthAngle, Math.min(d.maxAzimuthAngle, _.theta)), _.phi = Math.max(d.minPolarAngle, Math.min(d.maxPolarAngle, _.phi)), _.makeSafe(), _.radius *= E, _.radius = Math.max(d.minDistance, Math.min(d.maxDistance, _.radius)), !0 === d.enableDamping ? d.target.addScaledVector(A, d.dampingFactor) : d.target.add(A), r.setFromSpherical(_), r.applyQuaternion(h), t.copy(d.target).add(r), d.object.lookAt(d.target), !0 === d.enableDamping ? (T.theta *= 1 - d.dampingFactor, T.phi *= 1 - d.dampingFactor, A.multiplyScalar(1 - d.dampingFactor)) : (T.set(0, 0, 0), A.set(0, 0, 0)), E = 1, !!(R || f.distanceToSquared(d.object.position) > w || 8 * (1 - p.dot(d.object.quaternion)) > w) && (d.dispatchEvent(g), f.copy(d.object.position), p.copy(d.object.quaternion), R = !1, !0) }), this.dispose = function () { d.domElement.removeEventListener("contextmenu", ut, !1), d.domElement.removeEventListener("mousedown", et, !1), d.domElement.removeEventListener("wheel", it, !1), d.domElement.removeEventListener("touchstart", st, !1), d.domElement.removeEventListener("touchend", ct, !1), d.domElement.removeEventListener("touchmove", at, !1), document.removeEventListener("mousemove", rt, !1), document.removeEventListener("mouseup", nt, !1), d.domElement.removeEventListener("keydown", ot, !1) }; var d = this, g = { type: "change" }, v = { type: "start" }, y = { type: "end" }, x = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }, b = x.NONE, w = 1e-6, _ = new gi, T = new gi, E = 1, A = new S, R = !1, L = new m, O = new m, P = new m, I = new m, C = new m, k = new m, N = new m, z = new m, U = new m; function j() { return Math.pow(.95, d.zoomSpeed) } function B(t) { T.theta -= t } function F(t) { T.phi -= t } var D, G = (D = new S, function (t, e) { D.setFromMatrixColumn(e, 0), D.multiplyScalar(-t), A.add(D) }), V = function () { var t = new S; return function (e, r) { !0 === d.screenSpacePanning ? t.setFromMatrixColumn(r, 1) : (t.setFromMatrixColumn(r, 0), t.crossVectors(d.object.up, t)), t.multiplyScalar(e), A.add(t) } }(), H = function () { var t = new S; return function (e, r) { var n = d.domElement; if (d.object.isPerspectiveCamera) { var i = d.object.position; t.copy(i).sub(d.target); var o = t.length(); o *= Math.tan(d.object.fov / 2 * Math.PI / 180), G(2 * e * o / n.clientHeight, d.object.matrix), V(2 * r * o / n.clientHeight, d.object.matrix) } else d.object.isOrthographicCamera ? (G(e * (d.object.right - d.object.left) / d.object.zoom / n.clientWidth, d.object.matrix), V(r * (d.object.top - d.object.bottom) / d.object.zoom / n.clientHeight, d.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), d.enablePan = !1) } }(); function W(t) { d.object.isPerspectiveCamera ? E /= t : d.object.isOrthographicCamera ? (d.object.zoom = Math.max(d.minZoom, Math.min(d.maxZoom, d.object.zoom * t)), d.object.updateProjectionMatrix(), R = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), d.enableZoom = !1) } function q(t) { d.object.isPerspectiveCamera ? E *= t : d.object.isOrthographicCamera ? (d.object.zoom = Math.max(d.minZoom, Math.min(d.maxZoom, d.object.zoom / t)), d.object.updateProjectionMatrix(), R = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), d.enableZoom = !1) } function X(t) { L.set(t.clientX, t.clientY) } function Y(t) { I.set(t.clientX, t.clientY) } function Z(t) { if (1 == t.touches.length) L.set(t.touches[0].pageX, t.touches[0].pageY); else { var e = .5 * (t.touches[0].pageX + t.touches[1].pageX), r = .5 * (t.touches[0].pageY + t.touches[1].pageY); L.set(e, r) } } function K(t) { if (1 == t.touches.length) I.set(t.touches[0].pageX, t.touches[0].pageY); else { var e = .5 * (t.touches[0].pageX + t.touches[1].pageX), r = .5 * (t.touches[0].pageY + t.touches[1].pageY); I.set(e, r) } } function J(t) { var e = t.touches[0].pageX - t.touches[1].pageX, r = t.touches[0].pageY - t.touches[1].pageY, n = Math.sqrt(e * e + r * r); N.set(0, n) } function Q(t) { if (1 == t.touches.length) O.set(t.touches[0].pageX, t.touches[0].pageY); else { var e = .5 * (t.touches[0].pageX + t.touches[1].pageX), r = .5 * (t.touches[0].pageY + t.touches[1].pageY); O.set(e, r) } P.subVectors(O, L).multiplyScalar(d.rotateSpeed); var n = d.domElement; B(2 * Math.PI * P.x / n.clientHeight), F(2 * Math.PI * P.y / n.clientHeight), L.copy(O) } function $(t) { if (1 == t.touches.length) C.set(t.touches[0].pageX, t.touches[0].pageY); else { var e = .5 * (t.touches[0].pageX + t.touches[1].pageX), r = .5 * (t.touches[0].pageY + t.touches[1].pageY); C.set(e, r) } k.subVectors(C, I).multiplyScalar(d.panSpeed), H(k.x, k.y), I.copy(C) } function tt(t) { var e = t.touches[0].pageX - t.touches[1].pageX, r = t.touches[0].pageY - t.touches[1].pageY, n = Math.sqrt(e * e + r * r); z.set(0, n), U.set(0, Math.pow(z.y / N.y, d.zoomSpeed)), W(U.y), N.copy(z) } function et(t) { if (!1 !== d.enabled) { var e; switch (t.preventDefault(), d.domElement.focus ? d.domElement.focus() : window.focus(), t.button) { case 0: e = d.mouseButtons.LEFT; break; case 1: e = d.mouseButtons.MIDDLE; break; case 2: e = d.mouseButtons.RIGHT; break; default: e = -1 }switch (e) { case o: if (!1 === d.enableZoom) return; !function (t) { N.set(t.clientX, t.clientY) }(t), b = x.DOLLY; break; case i: if (t.ctrlKey || t.metaKey || t.shiftKey) { if (!1 === d.enablePan) return; Y(t), b = x.PAN } else { if (!1 === d.enableRotate) return; X(t), b = x.ROTATE } break; case s: if (t.ctrlKey || t.metaKey || t.shiftKey) { if (!1 === d.enableRotate) return; X(t), b = x.ROTATE } else { if (!1 === d.enablePan) return; Y(t), b = x.PAN } break; default: b = x.NONE }b !== x.NONE && (document.addEventListener("mousemove", rt, !1), document.addEventListener("mouseup", nt, !1), d.dispatchEvent(v)) } } function rt(t) { if (!1 !== d.enabled) switch (t.preventDefault(), b) { case x.ROTATE: if (!1 === d.enableRotate) return; !function (t) { O.set(t.clientX, t.clientY), P.subVectors(O, L).multiplyScalar(d.rotateSpeed); var e = d.domElement; B(2 * Math.PI * P.x / e.clientHeight), F(2 * Math.PI * P.y / e.clientHeight), L.copy(O), d.update() }(t); break; case x.DOLLY: if (!1 === d.enableZoom) return; !function (t) { z.set(t.clientX, t.clientY), U.subVectors(z, N), U.y > 0 ? W(j()) : U.y < 0 && q(j()), N.copy(z), d.update() }(t); break; case x.PAN: if (!1 === d.enablePan) return; !function (t) { C.set(t.clientX, t.clientY), k.subVectors(C, I).multiplyScalar(d.panSpeed), H(k.x, k.y), I.copy(C), d.update() }(t) } } function nt(t) { !1 !== d.enabled && (document.removeEventListener("mousemove", rt, !1), document.removeEventListener("mouseup", nt, !1), d.dispatchEvent(y), b = x.NONE) } function it(t) { !1 === d.enabled || !1 === d.enableZoom || b !== x.NONE && b !== x.ROTATE || (t.preventDefault(), t.stopPropagation(), d.dispatchEvent(v), function (t) { t.deltaY < 0 ? q(j()) : t.deltaY > 0 && W(j()), d.update() }(t), d.dispatchEvent(y)) } function ot(t) { !1 !== d.enabled && !1 !== d.enableKeys && !1 !== d.enablePan && function (t) { var e = !1; switch (t.keyCode) { case d.keys.UP: H(0, d.keyPanSpeed), e = !0; break; case d.keys.BOTTOM: H(0, -d.keyPanSpeed), e = !0; break; case d.keys.LEFT: H(d.keyPanSpeed, 0), e = !0; break; case d.keys.RIGHT: H(-d.keyPanSpeed, 0), e = !0 }e && (t.preventDefault(), d.update()) }(t) } function st(t) { if (!1 !== d.enabled) { switch (t.preventDefault(), t.touches.length) { case 1: switch (d.touches.ONE) { case a: if (!1 === d.enableRotate) return; Z(t), b = x.TOUCH_ROTATE; break; case c: if (!1 === d.enablePan) return; K(t), b = x.TOUCH_PAN; break; default: b = x.NONE }break; case 2: switch (d.touches.TWO) { case u: if (!1 === d.enableZoom && !1 === d.enablePan) return; !function (t) { d.enableZoom && J(t), d.enablePan && K(t) }(t), b = x.TOUCH_DOLLY_PAN; break; case l: if (!1 === d.enableZoom && !1 === d.enableRotate) return; !function (t) { d.enableZoom && J(t), d.enableRotate && Z(t) }(t), b = x.TOUCH_DOLLY_ROTATE; break; default: b = x.NONE }break; default: b = x.NONE }b !== x.NONE && d.dispatchEvent(v) } } function at(t) { if (!1 !== d.enabled) switch (t.preventDefault(), t.stopPropagation(), b) { case x.TOUCH_ROTATE: if (!1 === d.enableRotate) return; Q(t), d.update(); break; case x.TOUCH_PAN: if (!1 === d.enablePan) return; $(t), d.update(); break; case x.TOUCH_DOLLY_PAN: if (!1 === d.enableZoom && !1 === d.enablePan) return; !function (t) { d.enableZoom && tt(t), d.enablePan && $(t) }(t), d.update(); break; case x.TOUCH_DOLLY_ROTATE: if (!1 === d.enableZoom && !1 === d.enableRotate) return; !function (t) { d.enableZoom && tt(t), d.enableRotate && Q(t) }(t), d.update(); break; default: b = x.NONE } } function ct(t) { !1 !== d.enabled && (d.dispatchEvent(y), b = x.NONE) } function ut(t) { !1 !== d.enabled && t.preventDefault() } d.domElement.addEventListener("contextmenu", ut, !1), d.domElement.addEventListener("mousedown", et, !1), d.domElement.addEventListener("wheel", it, !1), d.domElement.addEventListener("touchstart", st, !1), d.domElement.addEventListener("touchend", ct, !1), d.domElement.addEventListener("touchmove", at, !1), d.domElement.addEventListener("keydown", ot, !1), -1 === d.domElement.tabIndex && (d.domElement.tabIndex = 0), this.update() }; (vi.prototype = Object.create(d.prototype)).constructor = vi; var yi = function (t, e) { vi.call(this, t, e), this.mouseButtons.LEFT = s, this.mouseButtons.RIGHT = i, this.touches.ONE = c, this.touches.TWO = l }; (yi.prototype = Object.create(d.prototype)).constructor = yi; class xi extends It { constructor() { super(), Object.defineProperty(this, "isScene", { value: !0 }), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(t, e) { return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this } toJSON(t) { const e = super.toJSON(t); return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e } } function bi(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } var wi = r(150).default, Mi = r(360)("1"), Si = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t) } var e, r, n; return e = t, n = [{ key: "randomVector3", value: function (t) { return t.set(2 * Math.random() - 1, 2 * Math.random() - 1, 2 * Math.random() - 1).normalize() } }, { key: "random", value: function (t) { return t ? Math.random() : Mi() } }, { key: "remapAndClamp", value: function (t, e, r, n, i) { return p.clamp(p.mapLinear(t, e, r, n, i), Math.min(n, i), Math.max(n, i)) } }, { key: "getQueryStringParameter", value: function (t) { t = t.replace(/[\[\]]/g, "\\$&"); var e = window.location.href, r = new RegExp("[?&]" + t + "(=([^&#]*)|&|#|$)").exec(e); return r ? r[2] ? decodeURIComponent(r[2].replace(/\+/g, " ")) : "" : null } }, { key: "tweenPropertyAsPromise", value: function (t, e, r, n, i) { return new Promise((function (o, s) { var a = {}; a[e] = t[e]; var c = {}; c[e] = r, new wi.Tween(a).to(c, n || 1e3).easing(i || wi.Easing.Linear.None).onUpdate((function () { t[e] = a[e] })).onComplete(o).start() })) } }], (r = null) && bi(e.prototype, r), n && bi(e, n), t }(); const _i = { enabled: !1, files: {}, add: function (t, e) { !1 !== this.enabled && (this.files[t] = e) }, get: function (t) { if (!1 !== this.enabled) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }; const Ti = new function (t, e, r) { const n = this; let i = !1, o = 0, s = 0, a = void 0; const c = []; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = r, this.itemStart = function (t) { s++, !1 === i && void 0 !== n.onStart && n.onStart(t, o, s), i = !0 }, this.itemEnd = function (t) { o++, void 0 !== n.onProgress && n.onProgress(t, o, s), o === s && (i = !1, void 0 !== n.onLoad && n.onLoad()) }, this.itemError = function (t) { void 0 !== n.onError && n.onError(t) }, this.resolveURL = function (t) { return a ? a(t) : t }, this.setURLModifier = function (t) { return a = t, this }, this.addHandler = function (t, e) { return c.push(t, e), this }, this.removeHandler = function (t) { const e = c.indexOf(t); return -1 !== e && c.splice(e, 2), this }, this.getHandler = function (t) { for (let e = 0, r = c.length; e < r; e += 2) { const r = c[e], n = c[e + 1]; if (r.global && (r.lastIndex = 0), r.test(t)) return n } return null } }; function Ei(t) { this.manager = void 0 !== t ? t : Ti, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = "", this.requestHeader = {} } function Ai(t) { Ei.call(this, t) } function Ri(t) { Ei.call(this, t) } Object.assign(Ei.prototype, { load: function () { }, loadAsync: function (t, e) { const r = this; return new Promise((function (n, i) { r.load(t, n, e, i) })) }, parse: function () { }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this }, setResourcePath: function (t) { return this.resourcePath = t, this }, setRequestHeader: function (t) { return this.requestHeader = t, this } }), Ai.prototype = Object.assign(Object.create(Ei.prototype), { constructor: Ai, load: function (t, e, r, n) { void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const i = this, o = _i.get(t); if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function () { e && e(o), i.manager.itemEnd(t) }), 0), o; const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function a() { s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), _i.add(t, this), e && e(this), i.manager.itemEnd(t) } function c(e) { s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), n && n(e), i.manager.itemError(t), i.manager.itemEnd(t) } return s.addEventListener("load", a, !1), s.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), i.manager.itemStart(t), s.src = t, s } }), Ri.prototype = Object.assign(Object.create(Ei.prototype), { constructor: Ri, load: function (t, e, r, n) { const i = new b, o = new Ai(this.manager); return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function (r) { i.image = r; const n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/); i.format = n ? 1022 : 1023, i.needsUpdate = !0, void 0 !== e && e(i) }), r, n), i } }); var Li = r(151), Oi = r.n(Li), Pi = r(152), Ii = r.n(Pi); function Ci(t) { return (Ci = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function ki(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } function Ni(t, e) { return (Ni = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function zi(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var r, n = ji(t); if (e) { var i = ji(this).constructor; r = Reflect.construct(n, arguments, i) } else r = n.apply(this, arguments); return Ui(this, r) } } function Ui(t, e) { return !e || "object" !== Ci(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function ji(t) { return (ji = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Bi = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Ni(t, e) }(o, t); var e, r, n, i = zi(o); function o(t) { var e; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, o); var r = { vertexShader: Oi.a, fragmentShader: Ii.a, uniforms: { psColor: { type: "c", value: new pt(15658734) }, globalOpacity: { type: "f", value: 0 }, scale: { type: "f", value: 1 }, map: { type: "t", value: null }, offset: { type: "v3", value: new S }, direction: { type: "v3", value: new S }, bboxMin: { type: "v3", value: new S(-1) }, bboxMax: { type: "v3", value: new S(1) }, color1: { type: "c", value: new pt(t.color1) }, color2: { type: "c", value: new pt(t.color2) }, thickness: { type: "f", value: .025 }, rayLength: { type: "f", value: 1 }, time: { type: "f", value: 0 }, aspectRatio: { value: 1 }, noise: { value: null }, shakeSpeed: { value: 0 }, shakeStrength: { value: 0 }, stretchFactor: { value: 0 }, rotation: { value: new K } } }; return (e = i.call(this, r)).fog = !1, e.uniforms.bboxMin.value.copy(t.bbox.min), e.uniforms.bboxMax.value.copy(t.bbox.max), e.uniforms.map.value = t.map, e.uniforms.noise.value = t.noise, e.depthWrite = !1, e.transparent = !0, e.side = 2, e.blending = 2, e.thicknessRange = t.thicknessRange, e.lengthRange = t.rayLengthRange, e.speedRange = t.speedRange, e.refreshUniforms(), e } return e = o, (r = [{ key: "update", value: function (t, e, r, n, i) { this.uniforms.offset.value.copy(t), this.uniforms.direction.value = e, this.uniforms.thickness.value = p.mapLinear(r, 0, 1, this.thicknessRange[0], this.thicknessRange[1]), this.uniforms.rayLength.value = p.mapLinear(r, 0, 1, this.lengthRange[0], this.lengthRange[1]), this.uniforms.stretchFactor.value = p.mapLinear(r, 0, 1.5, 0, 1), this.uniforms.shakeSpeed.value = .001 * r, this.uniforms.shakeStrength.value = .0035 * r; var o = p.mapLinear(r, 0, 1, this.speedRange[0], this.speedRange[1]); this.uniforms.time.value += Time.delta * o, this.uniforms.rotation.value.copy(n), this.uniforms.globalOpacity.value = i } }, { key: "refreshUniforms", value: function () { this.uniforms.psColor.value = this.color, this.uniforms.scale.value = window.innerHeight / 2 } }]) && ki(e.prototype, r), n && ki(e, n), o }(pe); function Fi(t) { return (Fi = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function Di(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function Gi(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } function Vi(t, e, r) { return e && Gi(t.prototype, e), r && Gi(t, r), t } function Hi(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Wi(t, e) } function Wi(t, e) { return (Wi = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function qi(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var r, n = Yi(t); if (e) { var i = Yi(this).constructor; r = Reflect.construct(n, arguments, i) } else r = n.apply(this, arguments); return Xi(this, r) } } function Xi(t, e) { return !e || "object" !== Fi(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function Yi(t) { return (Yi = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Zi = function (t) { Hi(r, t); var e = qi(r); function r(t) { var n; Di(this, r), n = e.call(this); for (var i = t.count, o = t.containerRadius[1], s = (t.containerRadius[0], t.containerLength), a = [], c = [], u = [], l = new oe, h = [], f = [], d = 0; d < i; d++) { var m = [p.mapLinear(Si.random(), 0, 1, -o, o), p.mapLinear(Si.random(), 0, 1, -o, o), p.mapLinear(Si.random(), 0, 1, -s / 2, s / 2)], g = m[0], v = m[1], y = m[2]; h.push(g, v, y), h.push(g, v, y), h.push(g, v, y), h.push(g, v, y), a.push(0, 1, 2, 3), f.push(0, 1), f.push(1, 1), f.push(0, 0), f.push(1, 0); var x = 4 * d; u.push(x, x + 1, x + 2), u.push(x + 1, x + 3, x + 2); var b = Si.random(); c.push(b, b, b, b) } l.setAttribute("position", new Ft(new Float32Array(h), 3)), l.setAttribute("uv", new Ft(new Float32Array(f), 2)), l.setAttribute("corner", new Ft(new Float32Array(a), 1)), l.setAttribute("colorMix", new Ft(new Float32Array(c), 1)), l.setIndex(u), l.needsUpdate = !0; var w = new Ri, M = w.load("/assets/textures/noise.jpg"); M.wrapS = M.wrapT = 1e3; var _ = n.material = new Bi({ map: w.load("/assets/textures/particle-sprite.png"), noise: M, transparent: !0, blending: 2, depthWrite: !1, bbox: new E(new S(-o, -o, -s / 2), new S(o, o, s / 2)), corners: a, quadOpacity: [], color1: t.colors[0], color2: t.colors[1], thicknessRange: t.thickness, rayLengthRange: t.rayLength, speedRange: t.speed }); return n.mesh = new Je(l, _), n.mesh.frustumCulled = !1, n.frustumCulled = !1, n.mesh.position.z -= s / 2, n.add(n.mesh), n } return Vi(r, [{ key: "update", value: function (t, e, r, n, i) { this.material.update(t, e, r, n, i) } }]), r }(It), Ki = function (t) { Hi(r, t); var e = qi(r); function r(t) { var n; return Di(this, r), (n = e.call(this)).distantStars = new Zi({ count: t || 1500, containerRadius: [5, 20], containerLength: 40, colors: [3172607, 15945620], thickness: [.035, .04], rayLength: [.1, 4], speed: [.5, 40] }), n.add(n.distantStars), n.frustumCulled = !1, n } return Vi(r, [{ key: "setRenderOrder", value: function (t) { this.traverse((function (e) { e.renderOrder = t })) } }, { key: "update", value: function (t, e, r, n, i) { this.distantStars.update(e, r, t, n, i) } }]), r }(It); const Ji = function (t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); let e = ""; for (let r = 0, n = t.length; r < n; r++)e += String.fromCharCode(t[r]); try { return decodeURIComponent(escape(e)) } catch (t) { return e } }, Qi = function (t) { const e = t.lastIndexOf("/"); return -1 === e ? "./" : t.substr(0, e + 1) }, $i = {}; function to(t) { Ei.call(this, t) } function eo(t, e) { It.call(this), this.type = "Light", this.color = new pt(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0 } function ro(t) { this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new m(512, 512), this.map = null, this.mapPass = null, this.matrix = new K, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Z, this._frameExtents = new m(1, 1), this._viewportCount = 1, this._viewports = [new it(0, 0, 1, 1)] } function no(t, e, r, n, i, o) { ur.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== r ? r : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix() } function io() { ro.call(this, new no(-5, 5, 5, -5, .5, 500)) } function oo(t, e) { eo.call(this, t, e), this.type = "DirectionalLight", this.position.copy(It.DefaultUp), this.updateMatrix(), this.target = new It, this.shadow = new io } function so() { ro.call(this, new lr(90, 1, .5, 500)), this._frameExtents = new m(4, 2), this._viewportCount = 6, this._viewports = [new it(2, 1, 1, 1), new it(0, 1, 1, 1), new it(3, 1, 1, 1), new it(1, 1, 1, 1), new it(3, 0, 1, 1), new it(1, 0, 1, 1)], this._cubeDirections = [new S(1, 0, 0), new S(-1, 0, 0), new S(0, 0, 1), new S(0, 0, -1), new S(0, 1, 0), new S(0, -1, 0)], this._cubeUps = [new S(0, 1, 0), new S(0, 1, 0), new S(0, 1, 0), new S(0, 1, 0), new S(0, 0, 1), new S(0, 0, -1)] } function ao(t, e, r, n) { eo.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", { get: function () { return 4 * this.intensity * Math.PI }, set: function (t) { this.intensity = t / (4 * Math.PI) } }), this.distance = void 0 !== r ? r : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new so } function co() { ro.call(this, new lr(50, 1, .5, 500)) } function uo(t, e, r, n, i, o) { eo.call(this, t, e), this.type = "SpotLight", this.position.copy(It.DefaultUp), this.updateMatrix(), this.target = new It, Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI }, set: function (t) { this.intensity = t / Math.PI } }), this.distance = void 0 !== r ? r : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new co } function lo(t) { ue.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new pt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new pt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new m(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t) } function ho(t) { lo.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new m(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t) } function fo(t, e, r, n) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(r), this.sampleValues = e, this.valueSize = r } function po(t) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Ei.call(this, t), this.options = { premultiplyAlpha: "none" } } function mo(t, e) { this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = p.generateUUID() } to.prototype = Object.assign(Object.create(Ei.prototype), { constructor: to, load: function (t, e, r, n) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const i = this, o = _i.get(t); if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function () { e && e(o), i.manager.itemEnd(t) }), 0), o; if (void 0 !== $i[t]) return void $i[t].push({ onLoad: e, onProgress: r, onError: n }); const s = t.match(/^data:(.*?)(;base64)?,(.*)$/); let a; if (s) { const r = s[1], o = !!s[2]; let a = s[3]; a = decodeURIComponent(a), o && (a = atob(a)); try { let n; const o = (this.responseType || "").toLowerCase(); switch (o) { case "arraybuffer": case "blob": const t = new Uint8Array(a.length); for (let e = 0; e < a.length; e++)t[e] = a.charCodeAt(e); n = "blob" === o ? new Blob([t.buffer], { type: r }) : t.buffer; break; case "document": const e = new DOMParser; n = e.parseFromString(a, r); break; case "json": n = JSON.parse(a); break; default: n = a }setTimeout((function () { e && e(n), i.manager.itemEnd(t) }), 0) } catch (e) { setTimeout((function () { n && n(e), i.manager.itemError(t), i.manager.itemEnd(t) }), 0) } } else { $i[t] = [], $i[t].push({ onLoad: e, onProgress: r, onError: n }), a = new XMLHttpRequest, a.open("GET", t, !0), a.addEventListener("load", (function (e) { const r = this.response, n = $i[t]; if (delete $i[t], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), _i.add(t, r); for (let t = 0, e = n.length; t < e; t++) { const e = n[t]; e.onLoad && e.onLoad(r) } i.manager.itemEnd(t) } else { for (let t = 0, r = n.length; t < r; t++) { const r = n[t]; r.onError && r.onError(e) } i.manager.itemError(t), i.manager.itemEnd(t) } }), !1), a.addEventListener("progress", (function (e) { const r = $i[t]; for (let t = 0, n = r.length; t < n; t++) { const n = r[t]; n.onProgress && n.onProgress(e) } }), !1), a.addEventListener("error", (function (e) { const r = $i[t]; delete $i[t]; for (let t = 0, n = r.length; t < n; t++) { const n = r[t]; n.onError && n.onError(e) } i.manager.itemError(t), i.manager.itemEnd(t) }), !1), a.addEventListener("abort", (function (e) { const r = $i[t]; delete $i[t]; for (let t = 0, n = r.length; t < n; t++) { const n = r[t]; n.onError && n.onError(e) } i.manager.itemError(t), i.manager.itemEnd(t) }), !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]); a.send(null) } return i.manager.itemStart(t), a }, setResponseType: function (t) { return this.responseType = t, this }, setWithCredentials: function (t) { return this.withCredentials = t, this }, setMimeType: function (t) { return this.mimeType = t, this } }), eo.prototype = Object.assign(Object.create(It.prototype), { constructor: eo, isLight: !0, copy: function (t) { return It.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this }, toJSON: function (t) { const e = It.prototype.toJSON.call(this, t); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e } }), Object.assign(ro.prototype, { _projScreenMatrix: new K, _lightPositionWorld: new S, _lookTarget: new S, getViewportCount: function () { return this._viewportCount }, getFrustum: function () { return this._frustum }, updateMatrices: function (t) { const e = this.camera, r = this.matrix, n = this._projScreenMatrix, i = this._lookTarget, o = this._lightPositionWorld; o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), i.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(i), e.updateMatrixWorld(), n.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(n), r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), r.multiply(e.projectionMatrix), r.multiply(e.matrixWorldInverse) }, getViewport: function (t) { return this._viewports[t] }, getFrameExtents: function () { return this._frameExtents }, copy: function (t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { const t = {}; return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t } }), no.prototype = Object.assign(Object.create(ur.prototype), { constructor: no, isOrthographicCamera: !0, copy: function (t, e) { return ur.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this }, setViewOffset: function (t, e, r, n, i, o) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = r, this.view.offsetY = n, this.view.width = i, this.view.height = o, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2; let i = r - t, o = r + t, s = n + e, a = n - e; if (null !== this.view && this.view.enabled) { const t = (this.right - this.left) / this.view.fullWidth / this.zoom, e = (this.top - this.bottom) / this.view.fullHeight / this.zoom; i += t * this.view.offsetX, o = i + t * this.view.width, s -= e * this.view.offsetY, a = s - e * this.view.height } this.projectionMatrix.makeOrthographic(i, o, s, a, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (t) { const e = It.prototype.toJSON.call(this, t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e } }), io.prototype = Object.assign(Object.create(ro.prototype), { constructor: io, isDirectionalLightShadow: !0, updateMatrices: function (t) { ro.prototype.updateMatrices.call(this, t) } }), oo.prototype = Object.assign(Object.create(eo.prototype), { constructor: oo, isDirectionalLight: !0, copy: function (t) { return eo.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), so.prototype = Object.assign(Object.create(ro.prototype), { constructor: so, isPointLightShadow: !0, updateMatrices: function (t, e) { void 0 === e && (e = 0); const r = this.camera, n = this.matrix, i = this._lightPositionWorld, o = this._lookTarget, s = this._projScreenMatrix; i.setFromMatrixPosition(t.matrixWorld), r.position.copy(i), o.copy(r.position), o.add(this._cubeDirections[e]), r.up.copy(this._cubeUps[e]), r.lookAt(o), r.updateMatrixWorld(), n.makeTranslation(-i.x, -i.y, -i.z), s.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(s) } }), ao.prototype = Object.assign(Object.create(eo.prototype), { constructor: ao, isPointLight: !0, copy: function (t) { return eo.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } }), co.prototype = Object.assign(Object.create(ro.prototype), { constructor: co, isSpotLightShadow: !0, updateMatrices: function (t) { const e = this.camera, r = 2 * p.RAD2DEG * t.angle, n = this.mapSize.width / this.mapSize.height, i = t.distance || e.far; r === e.fov && n === e.aspect && i === e.far || (e.fov = r, e.aspect = n, e.far = i, e.updateProjectionMatrix()), ro.prototype.updateMatrices.call(this, t) } }), uo.prototype = Object.assign(Object.create(eo.prototype), { constructor: uo, isSpotLight: !0, copy: function (t) { return eo.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), lo.prototype = Object.create(ue.prototype), lo.prototype.constructor = lo, lo.prototype.isMeshStandardMaterial = !0, lo.prototype.copy = function (t) { return ue.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this }, ho.prototype = Object.create(lo.prototype), ho.prototype.constructor = ho, ho.prototype.isMeshPhysicalMaterial = !0, ho.prototype.copy = function (t) { return lo.prototype.copy.call(this, t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new pt).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this }, Object.assign(fo.prototype, { evaluate: function (t) { const e = this.parameterPositions; let r = this._cachedIndex, n = e[r], i = e[r - 1]; t: { e: { let o; r: { n: if (!(t < n)) { for (let o = r + 2; ;) { if (void 0 === n) { if (t < i) break n; return r = e.length, this._cachedIndex = r, this.afterEnd_(r - 1, t, i) } if (r === o) break; if (i = n, n = e[++r], t < n) break e } o = e.length; break r } if (t >= i) break t; { const s = e[1]; t < s && (r = 2, i = s); for (let o = r - 2; ;) { if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, n); if (r === o) break; if (n = i, i = e[--r - 1], t >= i) break e } o = r, r = 0 } } for (; r < o;) { const n = r + o >>> 1; t < e[n] ? o = n : r = n + 1 } if (n = e[r], i = e[r - 1], void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, n); if (void 0 === n) return r = e.length, this._cachedIndex = r, this.afterEnd_(r - 1, i, t) } this._cachedIndex = r, this.intervalChanged_(r, i, n) } return this.interpolate_(r, i, t, n) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (t) { const e = this.resultBuffer, r = this.sampleValues, n = this.valueSize, i = t * n; for (let t = 0; t !== n; ++t)e[t] = r[i + t]; return e }, interpolate_: function () { throw new Error("call to abstract method") }, intervalChanged_: function () { } }), Object.assign(fo.prototype, { beforeStart_: fo.prototype.copySampleValue_, afterEnd_: fo.prototype.copySampleValue_ }), po.prototype = Object.assign(Object.create(Ei.prototype), { constructor: po, isImageBitmapLoader: !0, setOptions: function (t) { return this.options = t, this }, load: function (t, e, r, n) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const i = this, o = _i.get(t); if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function () { e && e(o), i.manager.itemEnd(t) }), 0), o; fetch(t).then((function (t) { return t.blob() })).then((function (t) { return createImageBitmap(t, i.options) })).then((function (r) { _i.add(t, r), e && e(r), i.manager.itemEnd(t) })).catch((function (e) { n && n(e), i.manager.itemError(t), i.manager.itemEnd(t) })), i.manager.itemStart(t) } }), Object.defineProperty(mo.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(mo.prototype, { isInterleavedBuffer: !0, onUploadCallback: function () { }, setUsage: function (t) { return this.usage = t, this }, copy: function (t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this }, copyAt: function (t, e, r) { t *= this.stride, r *= e.stride; for (let n = 0, i = this.stride; n < i; n++)this.array[t + n] = e.array[r + n]; return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, clone: function (t) { void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = p.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const e = new mo(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride); return e.setUsage(this.usage), e }, onUpload: function (t) { return this.onUploadCallback = t, this }, toJSON: function (t) { return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = p.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } }); const go = new S; function vo(t, e, r, n) { this.name = "", this.data = t, this.itemSize = e, this.offset = r, this.normalized = !0 === n } function yo(t, e, r, n, i, o, s, a, c) { b.call(this, t, e, r, n, i, o, s, a, c), this.needsUpdate = !0 } function xo(t) { ue.call(this), this.type = "PointsMaterial", this.color = new pt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t) } function bo(t) { ue.call(this), this.type = "LineBasicMaterial", this.color = new pt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t) } function wo(t, e) { t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Je.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new K, this.bindMatrixInverse = new K } Object.defineProperties(vo.prototype, { count: { get: function () { return this.data.count } }, array: { get: function () { return this.data.array } }, needsUpdate: { set: function (t) { this.data.needsUpdate = t } } }), Object.assign(vo.prototype, { isInterleavedBufferAttribute: !0, applyMatrix4: function (t) { for (let e = 0, r = this.data.count; e < r; e++)go.x = this.getX(e), go.y = this.getY(e), go.z = this.getZ(e), go.applyMatrix4(t), this.setXYZ(e, go.x, go.y, go.z); return this }, setX: function (t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this }, setY: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this }, setZ: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this }, setW: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this }, getX: function (t) { return this.data.array[t * this.data.stride + this.offset] }, getY: function (t) { return this.data.array[t * this.data.stride + this.offset + 1] }, getZ: function (t) { return this.data.array[t * this.data.stride + this.offset + 2] }, getW: function (t) { return this.data.array[t * this.data.stride + this.offset + 3] }, setXY: function (t, e, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = r, this }, setXYZ: function (t, e, r, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = r, this.data.array[t + 2] = n, this }, setXYZW: function (t, e, r, n, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = r, this.data.array[t + 2] = n, this.data.array[t + 3] = i, this }, clone: function (t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const r = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[r + e]) } return new Ft(new this.array.constructor(t), this.itemSize, this.normalized) } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new vo(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) }, toJSON: function (t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const r = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[r + e]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } }), yo.prototype = Object.create(b.prototype), yo.prototype.constructor = yo, yo.prototype.isCanvasTexture = !0, xo.prototype = Object.create(ue.prototype), xo.prototype.constructor = xo, xo.prototype.isPointsMaterial = !0, xo.prototype.copy = function (t) { return ue.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this }, bo.prototype = Object.create(ue.prototype), bo.prototype.constructor = bo, bo.prototype.isLineBasicMaterial = !0, bo.prototype.copy = function (t) { return ue.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this }, wo.prototype = Object.assign(Object.create(Je.prototype), { constructor: wo, isSkinnedMesh: !0, copy: function (t) { return Je.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this }, bind: function (t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e) }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { const t = new it, e = this.geometry.attributes.skinWeight; for (let r = 0, n = e.count; r < n; r++) { t.x = e.getX(r), t.y = e.getY(r), t.z = e.getZ(r), t.w = e.getW(r); const n = 1 / t.manhattanLength(); n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0), e.setXYZW(r, t.x, t.y, t.z, t.w) } }, updateMatrixWorld: function (t) { Je.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, boneTransform: function () { const t = new S, e = new it, r = new it, n = new S, i = new K; return function (o, s) { const a = this.skeleton, c = this.geometry; e.fromBufferAttribute(c.attributes.skinIndex, o), r.fromBufferAttribute(c.attributes.skinWeight, o), t.fromBufferAttribute(c.attributes.position, o).applyMatrix4(this.bindMatrix), s.set(0, 0, 0); for (let o = 0; o < 4; o++) { const c = r.getComponent(o); if (0 !== c) { const r = e.getComponent(o); i.multiplyMatrices(a.bones[r].matrixWorld, a.boneInverses[r]), s.addScaledVector(n.copy(t).applyMatrix4(i), c) } } return s.applyMatrix4(this.bindMatrixInverse) } }() }); const Mo = new S, So = new S, _o = new K, To = new we, Eo = new G; function Ao(t, e, r) { 1 === r && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), It.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new oe, this.material = void 0 !== e ? e : new bo, this.updateMorphTargets() } Ao.prototype = Object.assign(Object.create(It.prototype), { constructor: Ao, isLine: !0, copy: function (t) { return It.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this }, computeLineDistances: function () { const t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { const e = t.attributes.position, r = [0]; for (let t = 1, n = e.count; t < n; t++)Mo.fromBufferAttribute(e, t - 1), So.fromBufferAttribute(e, t), r[t] = r[t - 1], r[t] += Mo.distanceTo(So); t.setAttribute("lineDistance", new Yt(r, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) { const e = t.vertices, r = t.lineDistances; r[0] = 0; for (let t = 1, n = e.length; t < n; t++)r[t] = r[t - 1], r[t] += e[t - 1].distanceTo(e[t]) } return this }, raycast: function (t, e) { const r = this.geometry, n = this.matrixWorld, i = t.params.Line.threshold; if (null === r.boundingSphere && r.computeBoundingSphere(), Eo.copy(r.boundingSphere), Eo.applyMatrix4(n), Eo.radius += i, !1 === t.ray.intersectsSphere(Eo)) return; _o.getInverse(n), To.copy(t.ray).applyMatrix4(_o); const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o, a = new S, c = new S, u = new S, l = new S, h = this && this.isLineSegments ? 2 : 1; if (r.isBufferGeometry) { const n = r.index, i = r.attributes.position.array; if (null !== n) { const r = n.array; for (let n = 0, o = r.length - 1; n < o; n += h) { const o = r[n], h = r[n + 1]; a.fromArray(i, 3 * o), c.fromArray(i, 3 * h); if (To.distanceSqToSegment(a, c, l, u) > s) continue; l.applyMatrix4(this.matrixWorld); const f = t.ray.origin.distanceTo(l); f < t.near || f > t.far || e.push({ distance: f, point: u.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } else for (let r = 0, n = i.length / 3 - 1; r < n; r += h) { a.fromArray(i, 3 * r), c.fromArray(i, 3 * r + 3); if (To.distanceSqToSegment(a, c, l, u) > s) continue; l.applyMatrix4(this.matrixWorld); const n = t.ray.origin.distanceTo(l); n < t.near || n > t.far || e.push({ distance: n, point: u.clone().applyMatrix4(this.matrixWorld), index: r, face: null, faceIndex: null, object: this }) } } else if (r.isGeometry) { const n = r.vertices, i = n.length; for (let r = 0; r < i - 1; r += h) { if (To.distanceSqToSegment(n[r], n[r + 1], l, u) > s) continue; l.applyMatrix4(this.matrixWorld); const i = t.ray.origin.distanceTo(l); i < t.near || i > t.far || e.push({ distance: i, point: u.clone().applyMatrix4(this.matrixWorld), index: r, face: null, faceIndex: null, object: this }) } } }, updateMorphTargets: function () { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, r = Object.keys(e); if (r.length > 0) { const t = e[r[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, r = t.length; e < r; e++) { const r = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } }); const Ro = new S, Lo = new S; function Oo(t, e) { Ao.call(this, t, e), this.type = "LineSegments" } function Po(t, e) { Ao.call(this, t, e), this.type = "LineLoop" } Oo.prototype = Object.assign(Object.create(Ao.prototype), { constructor: Oo, isLineSegments: !0, computeLineDistances: function () { const t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { const e = t.attributes.position, r = []; for (let t = 0, n = e.count; t < n; t += 2)Ro.fromBufferAttribute(e, t), Lo.fromBufferAttribute(e, t + 1), r[t] = 0 === t ? 0 : r[t - 1], r[t + 1] = r[t] + Ro.distanceTo(Lo); t.setAttribute("lineDistance", new Yt(r, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) { const e = t.vertices, r = t.lineDistances; for (let t = 0, n = e.length; t < n; t += 2)Ro.copy(e[t]), Lo.copy(e[t + 1]), r[t] = 0 === t ? 0 : r[t - 1], r[t + 1] = r[t] + Ro.distanceTo(Lo) } return this } }), Po.prototype = Object.assign(Object.create(Ao.prototype), { constructor: Po, isLineLoop: !0 }); const Io = new K, Co = new we, ko = new G, No = new S; function zo(t, e) { It.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new oe, this.material = void 0 !== e ? e : new xo, this.updateMorphTargets() } function Uo(t, e, r, n, i, o, s) { const a = Co.distanceSqToPoint(t); if (a < r) { const r = new S; Co.closestPointToPoint(t, r), r.applyMatrix4(n); const c = i.ray.origin.distanceTo(r); if (c < i.near || c > i.far) return; o.push({ distance: c, distanceToRay: Math.sqrt(a), point: r, index: e, face: null, object: s }) } } function jo(t, e, r, n) { fo.call(this, t, e, r, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 } function Bo(t, e, r, n) { fo.call(this, t, e, r, n) } function Fo(t, e, r, n) { fo.call(this, t, e, r, n) } zo.prototype = Object.assign(Object.create(It.prototype), { constructor: zo, isPoints: !0, copy: function (t) { return It.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this }, raycast: function (t, e) { const r = this.geometry, n = this.matrixWorld, i = t.params.Points.threshold; if (null === r.boundingSphere && r.computeBoundingSphere(), ko.copy(r.boundingSphere), ko.applyMatrix4(n), ko.radius += i, !1 === t.ray.intersectsSphere(ko)) return; Io.getInverse(n), Co.copy(t.ray).applyMatrix4(Io); const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o; if (r.isBufferGeometry) { const i = r.index, o = r.attributes.position.array; if (null !== i) { const r = i.array; for (let i = 0, a = r.length; i < a; i++) { const a = r[i]; No.fromArray(o, 3 * a), Uo(No, a, s, n, t, e, this) } } else for (let r = 0, i = o.length / 3; r < i; r++)No.fromArray(o, 3 * r), Uo(No, r, s, n, t, e, this) } else { const i = r.vertices; for (let r = 0, o = i.length; r < o; r++)Uo(i[r], r, s, n, t, e, this) } }, updateMorphTargets: function () { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, r = Object.keys(e); if (r.length > 0) { const t = e[r[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, r = t.length; e < r; e++) { const r = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } }), jo.prototype = Object.assign(Object.create(fo.prototype), { constructor: jo, DefaultSettings_: { endingStart: 2400, endingEnd: 2400 }, intervalChanged_: function (t, e, r) { const n = this.parameterPositions; let i = t - 2, o = t + 1, s = n[i], a = n[o]; if (void 0 === s) switch (this.getSettings_().endingStart) { case 2401: i = t, s = 2 * e - r; break; case 2402: i = n.length - 2, s = e + n[i] - n[i + 1]; break; default: i = t, s = r }if (void 0 === a) switch (this.getSettings_().endingEnd) { case 2401: o = t, a = 2 * r - e; break; case 2402: o = 1, a = r + n[1] - n[0]; break; default: o = t - 1, a = e }const c = .5 * (r - e), u = this.valueSize; this._weightPrev = c / (e - s), this._weightNext = c / (a - r), this._offsetPrev = i * u, this._offsetNext = o * u }, interpolate_: function (t, e, r, n) { const i = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, c = a - s, u = this._offsetPrev, l = this._offsetNext, h = this._weightPrev, f = this._weightNext, p = (r - e) / (n - e), d = p * p, m = d * p, g = -h * m + 2 * h * d - h * p, v = (1 + h) * m + (-1.5 - 2 * h) * d + (-.5 + h) * p + 1, y = (-1 - f) * m + (1.5 + f) * d + .5 * p, x = f * m - f * d; for (let t = 0; t !== s; ++t)i[t] = g * o[u + t] + v * o[c + t] + y * o[a + t] + x * o[l + t]; return i } }), Bo.prototype = Object.assign(Object.create(fo.prototype), { constructor: Bo, interpolate_: function (t, e, r, n) { const i = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, c = a - s, u = (r - e) / (n - e), l = 1 - u; for (let t = 0; t !== s; ++t)i[t] = o[c + t] * l + o[a + t] * u; return i } }), Fo.prototype = Object.assign(Object.create(fo.prototype), { constructor: Fo, interpolate_: function (t) { return this.copySampleValue_(t - 1) } }); const Do = { arraySlice: function (t, e, r) { return Do.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== r ? r : t.length)) : t.slice(e, r) }, convertArray: function (t, e, r) { return !t || !r && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) }, isTypedArray: function (t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) }, getKeyframeOrder: function (t) { const e = t.length, r = new Array(e); for (let t = 0; t !== e; ++t)r[t] = t; return r.sort((function (e, r) { return t[e] - t[r] })), r }, sortedArray: function (t, e, r) { const n = t.length, i = new t.constructor(n); for (let o = 0, s = 0; s !== n; ++o) { const n = r[o] * e; for (let r = 0; r !== e; ++r)i[s++] = t[n + r] } return i }, flattenJSON: function (t, e, r, n) { let i = 1, o = t[0]; for (; void 0 !== o && void 0 === o[n];)o = t[i++]; if (void 0 === o) return; let s = o[n]; if (void 0 !== s) if (Array.isArray(s)) do { s = o[n], void 0 !== s && (e.push(o.time), r.push.apply(r, s)), o = t[i++] } while (void 0 !== o); else if (void 0 !== s.toArray) do { s = o[n], void 0 !== s && (e.push(o.time), s.toArray(r, r.length)), o = t[i++] } while (void 0 !== o); else do { s = o[n], void 0 !== s && (e.push(o.time), r.push(s)), o = t[i++] } while (void 0 !== o) }, subclip: function (t, e, r, n, i) { i = i || 30; const o = t.clone(); o.name = e; const s = []; for (let t = 0; t < o.tracks.length; ++t) { const e = o.tracks[t], a = e.getValueSize(), c = [], u = []; for (let t = 0; t < e.times.length; ++t) { const o = e.times[t] * i; if (!(o < r || o >= n)) { c.push(e.times[t]); for (let r = 0; r < a; ++r)u.push(e.values[t * a + r]) } } 0 !== c.length && (e.times = Do.convertArray(c, e.times.constructor), e.values = Do.convertArray(u, e.values.constructor), s.push(e)) } o.tracks = s; let a = 1 / 0; for (let t = 0; t < o.tracks.length; ++t)a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]); for (let t = 0; t < o.tracks.length; ++t)o.tracks[t].shift(-1 * a); return o.resetDuration(), o }, makeClipAdditive: function (t, e, r, n) { void 0 === e && (e = 0), void 0 === r && (r = t), (void 0 === n || n <= 0) && (n = 30); const i = t.tracks.length, o = e / n; for (let e = 0; e < i; ++e) { const n = r.tracks[e], i = n.ValueTypeName; if ("bool" === i || "string" === i) continue; const s = t.tracks.find((function (t) { return t.name === n.name && t.ValueTypeName === i })); if (void 0 === s) continue; let a = 0; const c = n.getValueSize(); n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = c / 3); let u = 0; const l = s.getValueSize(); s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = l / 3); const h = n.times.length - 1; let f; if (o <= n.times[0]) { const t = a, e = c - a; f = Do.arraySlice(n.values, t, e) } else if (o >= n.times[h]) { const t = h * c + a, e = t + c - a; f = Do.arraySlice(n.values, t, e) } else { const t = n.createInterpolant(), e = a, r = c - a; t.evaluate(o), f = Do.arraySlice(t.resultBuffer, e, r) } if ("quaternion" === i) { (new M).fromArray(f).normalize().conjugate().toArray(f) } const p = s.times.length; for (let t = 0; t < p; ++t) { const e = t * l + u; if ("quaternion" === i) M.multiplyQuaternionsFlat(s.values, e, f, 0, s.values, e); else { const t = l - 2 * u; for (let r = 0; r < t; ++r)s.values[e + r] -= f[r] } } } return t.blendMode = 2501, t } }; function Go(t, e, r, n) { if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t); this.name = t, this.times = Do.convertArray(e, this.TimeBufferType), this.values = Do.convertArray(r, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation) } function Vo(t, e, r, n) { Go.call(this, t, e, r, n) } function Ho(t, e, r, n) { fo.call(this, t, e, r, n) } function Wo(t, e, r, n) { Go.call(this, t, e, r, n) } function qo(t, e, r, n) { Go.call(this, t, e, r, n) } function Xo(t, e, r) { Go.call(this, t, e, r) } function Yo(t, e, r, n) { Go.call(this, t, e, r, n) } function Zo(t, e, r, n) { Go.call(this, t, e, r, n) } function Ko(t, e, r, n) { this.name = t, this.tracks = r, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== n ? n : 2500, this.uuid = p.generateUUID(), this.duration < 0 && this.resetDuration() } function Jo(t) { if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = function (t) { switch (t.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return Vo; case "vector": case "vector2": case "vector3": case "vector4": return qo; case "color": return Yo; case "quaternion": return Wo; case "bool": case "boolean": return Xo; case "string": return Zo }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t) }(t.type); if (void 0 === t.times) { const e = [], r = []; Do.flattenJSON(t.keys, e, r, "value"), t.times = e, t.values = r } return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation) } function Qo() { It.call(this), this.type = "Bone" } Object.assign(Go, { toJSON: function (t) { const e = t.constructor; let r; if (void 0 !== e.toJSON) r = e.toJSON(t); else { r = { name: t.name, times: Do.convertArray(t.times, Array), values: Do.convertArray(t.values, Array) }; const e = t.getInterpolation(); e !== t.DefaultInterpolation && (r.interpolation = e) } return r.type = t.ValueTypeName, r } }), Object.assign(Go.prototype, { constructor: Go, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function (t) { return new Fo(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodLinear: function (t) { return new Bo(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: function (t) { return new jo(this.times, this.values, this.getValueSize(), t) }, setInterpolation: function (t) { let e; switch (t) { case 2300: e = this.InterpolantFactoryMethodDiscrete; break; case 2301: e = this.InterpolantFactoryMethodLinear; break; case 2302: e = this.InterpolantFactoryMethodSmooth }if (void 0 === e) { const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (t === this.DefaultInterpolation) throw new Error(e); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", e), this } return this.createInterpolant = e, this }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return 2300; case this.InterpolantFactoryMethodLinear: return 2301; case this.InterpolantFactoryMethodSmooth: return 2302 } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (t) { if (0 !== t) { const e = this.times; for (let r = 0, n = e.length; r !== n; ++r)e[r] += t } return this }, scale: function (t) { if (1 !== t) { const e = this.times; for (let r = 0, n = e.length; r !== n; ++r)e[r] *= t } return this }, trim: function (t, e) { const r = this.times, n = r.length; let i = 0, o = n - 1; for (; i !== n && r[i] < t;)++i; for (; -1 !== o && r[o] > e;)--o; if (++o, 0 !== i || o !== n) { i >= o && (o = Math.max(o, 1), i = o - 1); const t = this.getValueSize(); this.times = Do.arraySlice(r, i, o), this.values = Do.arraySlice(this.values, i * t, o * t) } return this }, validate: function () { let t = !0; const e = this.getValueSize(); e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1); const r = this.times, n = this.values, i = r.length; 0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1); let o = null; for (let e = 0; e !== i; e++) { const n = r[e]; if ("number" == typeof n && isNaN(n)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, n), t = !1; break } if (null !== o && o > n) { console.error("THREE.KeyframeTrack: Out of order keys.", this, e, n, o), t = !1; break } o = n } if (void 0 !== n && Do.isTypedArray(n)) for (let e = 0, r = n.length; e !== r; ++e) { const r = n[e]; if (isNaN(r)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, r), t = !1; break } } return t }, optimize: function () { const t = Do.arraySlice(this.times), e = Do.arraySlice(this.values), r = this.getValueSize(), n = 2302 === this.getInterpolation(), i = t.length - 1; let o = 1; for (let s = 1; s < i; ++s) { let i = !1; const a = t[s]; if (a !== t[s + 1] && (1 !== s || a !== a[0])) if (n) i = !0; else { const t = s * r, n = t - r, o = t + r; for (let s = 0; s !== r; ++s) { const r = e[t + s]; if (r !== e[n + s] || r !== e[o + s]) { i = !0; break } } } if (i) { if (s !== o) { t[o] = t[s]; const n = s * r, i = o * r; for (let t = 0; t !== r; ++t)e[i + t] = e[n + t] } ++o } } if (i > 0) { t[o] = t[i]; for (let t = i * r, n = o * r, s = 0; s !== r; ++s)e[n + s] = e[t + s]; ++o } return o !== t.length ? (this.times = Do.arraySlice(t, 0, o), this.values = Do.arraySlice(e, 0, o * r)) : (this.times = t, this.values = e), this }, clone: function () { const t = Do.arraySlice(this.times, 0), e = Do.arraySlice(this.values, 0), r = new (0, this.constructor)(this.name, t, e); return r.createInterpolant = this.createInterpolant, r } }), Vo.prototype = Object.assign(Object.create(Go.prototype), { constructor: Vo, ValueTypeName: "number" }), Ho.prototype = Object.assign(Object.create(fo.prototype), { constructor: Ho, interpolate_: function (t, e, r, n) { const i = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = (r - e) / (n - e); let c = t * s; for (let t = c + s; c !== t; c += 4)M.slerpFlat(i, 0, o, c - s, o, c, a); return i } }), Wo.prototype = Object.assign(Object.create(Go.prototype), { constructor: Wo, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function (t) { return new Ho(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: void 0 }), qo.prototype = Object.assign(Object.create(Go.prototype), { constructor: qo, ValueTypeName: "vector" }), Xo.prototype = Object.assign(Object.create(Go.prototype), { constructor: Xo, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Yo.prototype = Object.assign(Object.create(Go.prototype), { constructor: Yo, ValueTypeName: "color" }), Zo.prototype = Object.assign(Object.create(Go.prototype), { constructor: Zo, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Object.assign(Ko, { parse: function (t) { const e = [], r = t.tracks, n = 1 / (t.fps || 1); for (let t = 0, i = r.length; t !== i; ++t)e.push(Jo(r[t]).scale(n)); return new Ko(t.name, t.duration, e, t.blendMode) }, toJSON: function (t) { const e = [], r = t.tracks, n = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode }; for (let t = 0, n = r.length; t !== n; ++t)e.push(Go.toJSON(r[t])); return n }, CreateFromMorphTargetSequence: function (t, e, r, n) { const i = e.length, o = []; for (let t = 0; t < i; t++) { let s = [], a = []; s.push((t + i - 1) % i, t, (t + 1) % i), a.push(0, 1, 0); const c = Do.getKeyframeOrder(s); s = Do.sortedArray(s, 1, c), a = Do.sortedArray(a, 1, c), n || 0 !== s[0] || (s.push(i), a.push(a[0])), o.push(new Vo(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(1 / r)) } return new Ko(t, -1, o) }, findByName: function (t, e) { let r = t; if (!Array.isArray(t)) { const e = t; r = e.geometry && e.geometry.animations || e.animations } for (let t = 0; t < r.length; t++)if (r[t].name === e) return r[t]; return null }, CreateClipsFromMorphTargetSequences: function (t, e, r) { const n = {}, i = /^([\w-]*?)([\d]+)$/; for (let e = 0, r = t.length; e < r; e++) { const r = t[e], o = r.name.match(i); if (o && o.length > 1) { const t = o[1]; let e = n[t]; e || (n[t] = e = []), e.push(r) } } const o = []; for (const t in n) o.push(Ko.CreateFromMorphTargetSequence(t, n[t], e, r)); return o }, parseAnimation: function (t, e) { if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const r = function (t, e, r, n, i) { if (0 !== r.length) { const o = [], s = []; Do.flattenJSON(r, o, s, n), 0 !== o.length && i.push(new t(e, o, s)) } }, n = [], i = t.name || "default", o = t.fps || 30, s = t.blendMode; let a = t.length || -1; const c = t.hierarchy || []; for (let t = 0; t < c.length; t++) { const i = c[t].keys; if (i && 0 !== i.length) if (i[0].morphTargets) { const t = {}; let e; for (e = 0; e < i.length; e++)if (i[e].morphTargets) for (let r = 0; r < i[e].morphTargets.length; r++)t[i[e].morphTargets[r]] = -1; for (const r in t) { const t = [], o = []; for (let n = 0; n !== i[e].morphTargets.length; ++n) { const n = i[e]; t.push(n.time), o.push(n.morphTarget === r ? 1 : 0) } n.push(new Vo(".morphTargetInfluence[" + r + "]", t, o)) } a = t.length * (o || 1) } else { const o = ".bones[" + e[t].name + "]"; r(qo, o + ".position", i, "pos", n), r(Wo, o + ".quaternion", i, "rot", n), r(qo, o + ".scale", i, "scl", n) } } if (0 === n.length) return null; return new Ko(i, a, n, s) } }), Object.assign(Ko.prototype, { resetDuration: function () { let t = 0; for (let e = 0, r = this.tracks.length; e !== r; ++e) { const r = this.tracks[e]; t = Math.max(t, r.times[r.times.length - 1]) } return this.duration = t, this }, trim: function () { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration); return this }, validate: function () { let t = !0; for (let e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate(); return t }, optimize: function () { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].optimize(); return this }, clone: function () { const t = []; for (let e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone()); return new Ko(this.name, this.duration, t, this.blendMode) } }), Qo.prototype = Object.assign(Object.create(It.prototype), { constructor: Qo, isBone: !0 }); const $o = new RegExp("[\\[\\]\\.:\\/]", "g"), ts = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", es = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), rs = /(WCOD+)?/.source.replace("WCOD", ts), ns = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), is = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), os = new RegExp("^" + es + rs + ns + is + "$"), ss = ["material", "materials", "bones"]; function as(t, e, r) { const n = r || cs.parseTrackName(e); this._targetGroup = t, this._bindings = t.subscribe_(e, n) } function cs(t, e, r) { this.path = e, this.parsedPath = r || cs.parseTrackName(e), this.node = cs.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t } Object.assign(as.prototype, { getValue: function (t, e) { this.bind(); const r = this._targetGroup.nCachedObjects_, n = this._bindings[r]; void 0 !== n && n.getValue(t, e) }, setValue: function (t, e) { const r = this._bindings; for (let n = this._targetGroup.nCachedObjects_, i = r.length; n !== i; ++n)r[n].setValue(t, e) }, bind: function () { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, r = t.length; e !== r; ++e)t[e].bind() }, unbind: function () { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, r = t.length; e !== r; ++e)t[e].unbind() } }), Object.assign(cs, { Composite: as, create: function (t, e, r) { return t && t.isAnimationObjectGroup ? new cs.Composite(t, e, r) : new cs(t, e, r) }, sanitizeNodeName: function (t) { return t.replace(/\s/g, "_").replace($o, "") }, parseTrackName: function (t) { const e = os.exec(t); if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t); const r = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, n = r.nodeName && r.nodeName.lastIndexOf("."); if (void 0 !== n && -1 !== n) { const t = r.nodeName.substring(n + 1); -1 !== ss.indexOf(t) && (r.nodeName = r.nodeName.substring(0, n), r.objectName = t) } if (null === r.propertyName || 0 === r.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t); return r }, findNode: function (t, e) { if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t; if (t.skeleton) { const r = t.skeleton.getBoneByName(e); if (void 0 !== r) return r } if (t.children) { const r = function (t) { for (let n = 0; n < t.length; n++) { const i = t[n]; if (i.name === e || i.uuid === e) return i; const o = r(i.children); if (o) return o } return null }, n = r(t.children); if (n) return n } return null } }), Object.assign(cs.prototype, { _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (t, e) { t[e] = this.node[this.propertyName] }, function (t, e) { const r = this.resolvedProperty; for (let n = 0, i = r.length; n !== i; ++n)t[e++] = r[n] }, function (t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }, function (t, e) { this.resolvedProperty.toArray(t, e) }], SetterByBindingTypeAndVersioning: [[function (t, e) { this.targetObject[this.propertyName] = t[e] }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { const r = this.resolvedProperty; for (let n = 0, i = r.length; n !== i; ++n)r[n] = t[e++] }, function (t, e) { const r = this.resolvedProperty; for (let n = 0, i = r.length; n !== i; ++n)r[n] = t[e++]; this.targetObject.needsUpdate = !0 }, function (t, e) { const r = this.resolvedProperty; for (let n = 0, i = r.length; n !== i; ++n)r[n] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty.fromArray(t, e) }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }]], getValue: function (t, e) { this.bind(), this.getValue(t, e) }, setValue: function (t, e) { this.bind(), this.setValue(t, e) }, bind: function () { let t = this.node; const e = this.parsedPath, r = e.objectName, n = e.propertyName; let i = e.propertyIndex; if (t || (t = cs.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); if (r) { let n = e.objectIndex; switch (r) { case "materials": if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); t = t.material.materials; break; case "bones": if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); t = t.skeleton.bones; for (let e = 0; e < t.length; e++)if (t[e].name === n) { n = e; break } break; default: if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); t = t[r] }if (void 0 !== n) { if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t); t = t[n] } } const o = t[n]; if (void 0 === o) { const r = e.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + r + "." + n + " but it wasn't found.", t) } let s = this.Versioning.None; this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate); let a = this.BindingType.Direct; if (void 0 !== i) { if ("morphTargetInfluences" === n) { if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== t.morphTargetDictionary[i] && (i = t.morphTargetDictionary[i]) } a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = i } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n; this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s] }, unbind: function () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }), Object.assign(cs.prototype, { _getValue_unbound: cs.prototype.getValue, _setValue_unbound: cs.prototype.setValue }); const us = new K, ls = new K; function hs(t, e) { if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses(); else if (this.bones.length === e.length) this.boneInverses = e.slice(0); else { console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = []; for (let t = 0, e = this.bones.length; t < e; t++)this.boneInverses.push(new K) } } Object.assign(hs.prototype, { calculateInverses: function () { this.boneInverses = []; for (let t = 0, e = this.bones.length; t < e; t++) { const e = new K; this.bones[t] && e.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(e) } }, pose: function () { for (let t = 0, e = this.bones.length; t < e; t++) { const e = this.bones[t]; e && e.matrixWorld.getInverse(this.boneInverses[t]) } for (let t = 0, e = this.bones.length; t < e; t++) { const e = this.bones[t]; e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale)) } }, update: function () { const t = this.bones, e = this.boneInverses, r = this.boneMatrices, n = this.boneTexture; for (let n = 0, i = t.length; n < i; n++) { const i = t[n] ? t[n].matrixWorld : ls; us.multiplyMatrices(i, e[n]), us.toArray(r, 16 * n) } void 0 !== n && (n.needsUpdate = !0) }, clone: function () { return new hs(this.bones, this.boneInverses) }, getBoneByName: function (t) { for (let e = 0, r = this.bones.length; e < r; e++) { const r = this.bones[e]; if (r.name === t) return r } }, dispose: function () { this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0) } }); var fs = function () { function t(t) { Ei.call(this, t), this.dracoLoader = null, this.ddsLoader = null, this.ktx2Loader = null, this.pluginCallbacks = [], this.register((function (t) { return new s(t) })), this.register((function (t) { return new c(t) })), this.register((function (t) { return new a(t) })) } function e() { var t = {}; return { get: function (e) { return t[e] }, add: function (e, r) { t[e] = r }, remove: function (e) { delete t[e] }, removeAll: function () { t = {} } } } t.prototype = Object.assign(Object.create(Ei.prototype), { constructor: t, load: function (t, e, r, n) { var i, o = this; i = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Qi(t), o.manager.itemStart(t); var s = function (e) { n ? n(e) : console.error(e), o.manager.itemError(t), o.manager.itemEnd(t) }, a = new to(o.manager); a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), "use-credentials" === o.crossOrigin && a.setWithCredentials(!0), a.load(t, (function (r) { try { o.parse(r, i, (function (r) { e(r), o.manager.itemEnd(t) }), s) } catch (t) { s(t) } }), r, s) }, setDRACOLoader: function (t) { return this.dracoLoader = t, this }, setDDSLoader: function (t) { return this.ddsLoader = t, this }, setKTX2Loader: function (t) { return this.ktx2Loader = t, this }, register: function (t) { return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this }, unregister: function (t) { return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this }, parse: function (t, e, s, a) { var c, l = {}, h = {}; if ("string" == typeof t) c = t; else if (Ji(new Uint8Array(t, 0, 4)) === u) { try { l[r.KHR_BINARY_GLTF] = new f(t) } catch (t) { return void (a && a(t)) } c = l[r.KHR_BINARY_GLTF].content } else c = Ji(new Uint8Array(t)); var p = JSON.parse(c); if (void 0 === p.asset || p.asset.version[0] < 2) a && a(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); else { var m = new q(p, { path: e || this.resourcePath || "", crossOrigin: this.crossOrigin, manager: this.manager, ktx2Loader: this.ktx2Loader }); m.fileLoader.setRequestHeader(this.requestHeader); for (var v = 0; v < this.pluginCallbacks.length; v++) { var b = this.pluginCallbacks[v](m); h[b.name] = b, l[b.name] = !0 } if (p.extensionsUsed) for (v = 0; v < p.extensionsUsed.length; ++v) { var w = p.extensionsUsed[v], M = p.extensionsRequired || []; switch (w) { case r.KHR_LIGHTS_PUNCTUAL: l[w] = new i(p); break; case r.KHR_MATERIALS_UNLIT: l[w] = new o; break; case r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: l[w] = new y; break; case r.KHR_DRACO_MESH_COMPRESSION: l[w] = new d(p, this.dracoLoader); break; case r.MSFT_TEXTURE_DDS: l[w] = new n(this.ddsLoader); break; case r.KHR_TEXTURE_TRANSFORM: l[w] = new g; break; case r.KHR_MESH_QUANTIZATION: l[w] = new x; break; default: M.indexOf(w) >= 0 && void 0 === h[w] && console.warn('THREE.GLTFLoader: Unknown extension "' + w + '".') } } m.setExtensions(l), m.setPlugins(h), m.parse(s, a) } } }); var r = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", MSFT_TEXTURE_DDS: "MSFT_texture_dds" }; function n(t) { if (!t) throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader"); this.name = r.MSFT_TEXTURE_DDS, this.ddsLoader = t } function i(t) { this.name = r.KHR_LIGHTS_PUNCTUAL; var e = t.extensions && t.extensions[r.KHR_LIGHTS_PUNCTUAL] || {}; this.lightDefs = e.lights || [] } function o() { this.name = r.KHR_MATERIALS_UNLIT } function s(t) { this.parser = t, this.name = r.KHR_MATERIALS_CLEARCOAT } function a(t) { this.parser = t, this.name = r.KHR_MATERIALS_TRANSMISSION } function c(t) { this.parser = t, this.name = r.KHR_TEXTURE_BASISU } i.prototype.loadLight = function (t) { var e, r = this.lightDefs[t], n = new pt(16777215); void 0 !== r.color && n.fromArray(r.color); var i = void 0 !== r.range ? r.range : 0; switch (r.type) { case "directional": (e = new oo(n)).target.position.set(0, 0, -1), e.add(e.target); break; case "point": (e = new ao(n)).distance = i; break; case "spot": (e = new uo(n)).distance = i, r.spot = r.spot || {}, r.spot.innerConeAngle = void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0, r.spot.outerConeAngle = void 0 !== r.spot.outerConeAngle ? r.spot.outerConeAngle : Math.PI / 4, e.angle = r.spot.outerConeAngle, e.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle, e.target.position.set(0, 0, -1), e.add(e.target); break; default: throw new Error('THREE.GLTFLoader: Unexpected light type, "' + r.type + '".') }return e.position.set(0, 0, 0), e.decay = 2, void 0 !== r.intensity && (e.intensity = r.intensity), e.name = r.name || "light_" + t, Promise.resolve(e) }, o.prototype.getMaterialType = function () { return Ce }, o.prototype.extendParams = function (t, e, r) { var n = []; t.color = new pt(1, 1, 1), t.opacity = 1; var i = e.pbrMetallicRoughness; if (i) { if (Array.isArray(i.baseColorFactor)) { var o = i.baseColorFactor; t.color.fromArray(o), t.opacity = o[3] } void 0 !== i.baseColorTexture && n.push(r.assignTexture(t, "map", i.baseColorTexture)) } return Promise.all(n) }, s.prototype.getMaterialType = function (t) { var e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? ho : null }, s.prototype.extendMaterialParams = function (t, e) { var r = this.parser, n = r.json.materials[t]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); var i = [], o = n.extensions[this.name]; if (void 0 !== o.clearcoatFactor && (e.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && i.push(r.assignTexture(e, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (e.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && i.push(r.assignTexture(e, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (i.push(r.assignTexture(e, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) { var s = o.clearcoatNormalTexture.scale; e.clearcoatNormalScale = new m(s, s) } return Promise.all(i) }, a.prototype.getMaterialType = function (t) { var e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? ho : null }, a.prototype.extendMaterialParams = function (t, e) { var r = this.parser, n = r.json.materials[t]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); var i = [], o = n.extensions[this.name]; return void 0 !== o.transmissionFactor && (e.transmission = o.transmissionFactor), void 0 !== o.transmissionTexture && i.push(r.assignTexture(e, "transmissionMap", o.transmissionTexture)), Promise.all(i) }, c.prototype.loadTexture = function (t) { var e = this.parser, r = e.json, n = r.textures[t]; if (!n.extensions || !n.extensions[this.name]) return null; var i = n.extensions[this.name], o = r.images[i.source], s = e.options.ktx2Loader; if (!s) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return e.loadTextureImage(t, o, s) }; var u = "glTF", l = 1313821514, h = 5130562; function f(t) { this.name = r.KHR_BINARY_GLTF, this.content = null, this.body = null; var e = new DataView(t, 0, 12); if (this.header = { magic: Ji(new Uint8Array(t.slice(0, 4))), version: e.getUint32(4, !0), length: e.getUint32(8, !0) }, this.header.magic !== u) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); for (var n = new DataView(t, 12), i = 0; i < n.byteLength;) { var o = n.getUint32(i, !0); i += 4; var s = n.getUint32(i, !0); if (i += 4, s === l) { var a = new Uint8Array(t, 12 + i, o); this.content = Ji(a) } else if (s === h) { var c = 12 + i; this.body = t.slice(c, c + o) } i += o } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } function d(t, e) { if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = r.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload() } function g() { this.name = r.KHR_TEXTURE_TRANSFORM } function v(t) { lo.call(this), this.isGLTFSpecularGlossinessMaterial = !0; var e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), r = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), n = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), i = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb;", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor.rgb;"].join("\n"), s = { specular: { value: (new pt).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = s, this.onBeforeCompile = function (t) { for (var a in s) t.uniforms[a] = s[a]; t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;"), t.fragmentShader = t.fragmentShader.replace("uniform float metalness;", "uniform float glossiness;"), t.fragmentShader = t.fragmentShader.replace("#include <roughnessmap_pars_fragment>", e), t.fragmentShader = t.fragmentShader.replace("#include <metalnessmap_pars_fragment>", r), t.fragmentShader = t.fragmentShader.replace("#include <roughnessmap_fragment>", n), t.fragmentShader = t.fragmentShader.replace("#include <metalnessmap_fragment>", i), t.fragmentShader = t.fragmentShader.replace("#include <lights_physical_fragment>", o) }, Object.defineProperties(this, { specular: { get: function () { return s.specular.value }, set: function (t) { s.specular.value = t } }, specularMap: { get: function () { return s.specularMap.value }, set: function (t) { s.specularMap.value = t } }, glossiness: { get: function () { return s.glossiness.value }, set: function (t) { s.glossiness.value = t } }, glossinessMap: { get: function () { return s.glossinessMap.value }, set: function (t) { s.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_ROUGHNESSMAP = "") : (delete this.defines.USE_ROUGHNESSMAP, delete this.defines.USE_GLOSSINESSMAP) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t) } function y() { return { name: r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"], getMaterialType: function () { return v }, extendParams: function (t, e, r) { var n = e.extensions[this.name]; t.color = new pt(1, 1, 1), t.opacity = 1; var i = []; if (Array.isArray(n.diffuseFactor)) { var o = n.diffuseFactor; t.color.fromArray(o), t.opacity = o[3] } if (void 0 !== n.diffuseTexture && i.push(r.assignTexture(t, "map", n.diffuseTexture)), t.emissive = new pt(0, 0, 0), t.glossiness = void 0 !== n.glossinessFactor ? n.glossinessFactor : 1, t.specular = new pt(1, 1, 1), Array.isArray(n.specularFactor) && t.specular.fromArray(n.specularFactor), void 0 !== n.specularGlossinessTexture) { var s = n.specularGlossinessTexture; i.push(r.assignTexture(t, "glossinessMap", s)), i.push(r.assignTexture(t, "specularMap", s)) } return Promise.all(i) }, createMaterial: function (t) { var e = new v(t); return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = 1, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = 0, t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e.refractionRatio = .98, e } } } function x() { this.name = r.KHR_MESH_QUANTIZATION } function b(t, e, r, n) { fo.call(this, t, e, r, n) } d.prototype.decodePrimitive = function (t, e) { var r = this.json, n = this.dracoLoader, i = t.extensions[this.name].bufferView, o = t.extensions[this.name].attributes, s = {}, a = {}, c = {}; for (var u in o) { var l = k[u] || u.toLowerCase(); s[l] = o[u] } for (u in t.attributes) { l = k[u] || u.toLowerCase(); if (void 0 !== o[u]) { var h = r.accessors[t.attributes[u]], f = O[h.componentType]; c[l] = f, a[l] = !0 === h.normalized } } return e.getDependency("bufferView", i).then((function (t) { return new Promise((function (e) { n.decodeDracoFile(t, (function (t) { for (var r in t.attributes) { var n = t.attributes[r], i = a[r]; void 0 !== i && (n.normalized = i) } e(t) }), s, c) })) })) }, g.prototype.extendTexture = function (t, e) { return t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.needsUpdate = !0, t }, v.prototype = Object.create(lo.prototype), v.prototype.constructor = v, v.prototype.copy = function (t) { return lo.prototype.copy.call(this, t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this }, b.prototype = Object.create(fo.prototype), b.prototype.constructor = b, b.prototype.copySampleValue_ = function (t) { for (var e = this.resultBuffer, r = this.sampleValues, n = this.valueSize, i = t * n * 3 + n, o = 0; o !== n; o++)e[o] = r[i + o]; return e }, b.prototype.beforeStart_ = b.prototype.copySampleValue_, b.prototype.afterEnd_ = b.prototype.copySampleValue_, b.prototype.interpolate_ = function (t, e, r, n) { for (var i = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = 2 * s, c = 3 * s, u = n - e, l = (r - e) / u, h = l * l, f = h * l, p = t * c, d = p - c, m = -2 * f + 3 * h, g = f - h, v = 1 - m, y = g - h + l, x = 0; x !== s; x++) { var b = o[d + x + s], w = o[d + x + a] * u, M = o[p + x + s], S = o[p + x] * u; i[x] = v * b + y * w + m * M + g * S } return i }; var w = 0, M = 1, _ = 2, T = 3, A = 4, R = 5, L = 6, O = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, P = { 9728: 1003, 9729: 1006, 9984: 1004, 9985: 1007, 9986: 1005, 9987: 1008 }, I = { 33071: 1001, 33648: 1002, 10497: 1e3 }, C = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, k = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, N = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, z = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 }, U = "OPAQUE", j = "MASK", B = "BLEND"; function F(t, e) { return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t) } function D(t, e, r) { for (var n in r.extensions) void 0 === t[n] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = r.extensions[n]) } function V(t, e) { void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) } function H(t, e) { if (t.updateMorphTargets(), void 0 !== e.weights) for (var r = 0, n = e.weights.length; r < n; r++)t.morphTargetInfluences[r] = e.weights[r]; if (e.extras && Array.isArray(e.extras.targetNames)) { var i = e.extras.targetNames; if (t.morphTargetInfluences.length === i.length) { t.morphTargetDictionary = {}; for (r = 0, n = i.length; r < n; r++)t.morphTargetDictionary[i[r]] = r } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function W(t) { for (var e = "", r = Object.keys(t).sort(), n = 0, i = r.length; n < i; n++)e += r[n] + ":" + t[r[n]] + ";"; return e } function q(t, r) { this.json = t || {}, this.extensions = {}, this.plugins = {}, this.options = r || {}, this.cache = new e, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new po(this.options.manager) : this.textureLoader = new Ri(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new to(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } function X(t, e, r) { var n = e.attributes, i = []; function o(e, n) { return r.getDependency("accessor", e).then((function (e) { t.setAttribute(n, e) })) } for (var s in n) { var a = k[s] || s.toLowerCase(); a in t.attributes || i.push(o(n[s], a)) } if (void 0 !== e.indices && !t.index) { var c = r.getDependency("accessor", e.indices).then((function (e) { t.setIndex(e) })); i.push(c) } return V(t, e), function (t, e, r) { var n = e.attributes, i = new E; if (void 0 !== n.POSITION) { var o = (p = r.json.accessors[n.POSITION]).min, s = p.max; if (void 0 !== o && void 0 !== s) { i.set(new S(o[0], o[1], o[2]), new S(s[0], s[1], s[2])); var a = e.targets; if (void 0 !== a) { for (var c = new S, u = new S, l = 0, h = a.length; l < h; l++) { var f = a[l]; if (void 0 !== f.POSITION) { var p; o = (p = r.json.accessors[f.POSITION]).min, s = p.max; void 0 !== o && void 0 !== s ? (u.setX(Math.max(Math.abs(o[0]), Math.abs(s[0]))), u.setY(Math.max(Math.abs(o[1]), Math.abs(s[1]))), u.setZ(Math.max(Math.abs(o[2]), Math.abs(s[2]))), c.max(u)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } i.expandByVector(c) } t.boundingBox = i; var d = new G; i.getCenter(d.center), d.radius = i.min.distanceTo(i.max) / 2, t.boundingSphere = d } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } }(t, e, r), Promise.all(i).then((function () { return void 0 !== e.targets ? function (t, e, r) { for (var n = !1, i = !1, o = 0, s = e.length; o < s; o++) { if (void 0 !== (u = e[o]).POSITION && (n = !0), void 0 !== u.NORMAL && (i = !0), n && i) break } if (!n && !i) return Promise.resolve(t); var a = [], c = []; for (o = 0, s = e.length; o < s; o++) { var u = e[o]; if (n) { var l = void 0 !== u.POSITION ? r.getDependency("accessor", u.POSITION) : t.attributes.position; a.push(l) } if (i) { l = void 0 !== u.NORMAL ? r.getDependency("accessor", u.NORMAL) : t.attributes.normal; c.push(l) } } return Promise.all([Promise.all(a), Promise.all(c)]).then((function (e) { var r = e[0], o = e[1]; return n && (t.morphAttributes.position = r), i && (t.morphAttributes.normal = o), t.morphTargetsRelative = !0, t })) }(t, e.targets, r) : t })) } function Y(t, e) { var r = t.getIndex(); if (null === r) { var n = [], i = t.getAttribute("position"); if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t; for (var o = 0; o < i.count; o++)n.push(o); t.setIndex(n), r = t.getIndex() } var s = r.count - 2, a = []; if (2 === e) for (o = 1; o <= s; o++)a.push(r.getX(0)), a.push(r.getX(o)), a.push(r.getX(o + 1)); else for (o = 0; o < s; o++)o % 2 == 0 ? (a.push(r.getX(o)), a.push(r.getX(o + 1)), a.push(r.getX(o + 2))) : (a.push(r.getX(o + 2)), a.push(r.getX(o + 1)), a.push(r.getX(o))); a.length / 3 !== s && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); var c = t.clone(); return c.setIndex(a), c } return q.prototype.setExtensions = function (t) { this.extensions = t }, q.prototype.setPlugins = function (t) { this.plugins = t }, q.prototype.parse = function (t, e) { var r = this, n = this.json, i = this.extensions; this.cache.removeAll(), this._markDefs(), Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then((function (e) { var o = { scene: e[0][n.scene || 0], scenes: e[0], animations: e[1], cameras: e[2], asset: n.asset, parser: r, userData: {} }; D(i, o, n), V(o, n), t(o) })).catch(e) }, q.prototype._markDefs = function () { for (var t = this.json.nodes || [], e = this.json.skins || [], n = this.json.meshes || [], i = 0, o = e.length; i < o; i++)for (var s = e[i].joints, a = 0, c = s.length; a < c; a++)t[s[a]].isBone = !0; for (var u = 0, l = t.length; u < l; u++) { var h = t[u]; void 0 !== h.mesh && (this._addNodeRef(this.meshCache, h.mesh), void 0 !== h.skin && (n[h.mesh].isSkinnedMesh = !0)), void 0 !== h.camera && this._addNodeRef(this.cameraCache, h.camera), h.extensions && h.extensions[r.KHR_LIGHTS_PUNCTUAL] && void 0 !== h.extensions[r.KHR_LIGHTS_PUNCTUAL].light && this._addNodeRef(this.lightCache, h.extensions[r.KHR_LIGHTS_PUNCTUAL].light) } }, q.prototype._addNodeRef = function (t, e) { void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++) }, q.prototype._getNodeRef = function (t, e, r) { if (t.refs[e] <= 1) return r; var n = r.clone(); return n.name += "_instance_" + t.uses[e]++, n }, q.prototype._invokeOne = function (t) { var e = Object.values(this.plugins); e.push(this); for (var r = 0; r < e.length; r++) { var n = t(e[r]); if (n) return n } }, q.prototype._invokeAll = function (t) { var e = Object.values(this.plugins); e.unshift(this); for (var r = [], n = 0; n < e.length; n++)r.push(t(e[n])); return Promise.all(r) }, q.prototype.getDependency = function (t, e) { var n = t + ":" + e, i = this.cache.get(n); if (!i) { switch (t) { case "scene": i = this.loadScene(e); break; case "node": i = this.loadNode(e); break; case "mesh": i = this._invokeOne((function (t) { return t.loadMesh && t.loadMesh(e) })); break; case "accessor": i = this.loadAccessor(e); break; case "bufferView": i = this._invokeOne((function (t) { return t.loadBufferView && t.loadBufferView(e) })); break; case "buffer": i = this.loadBuffer(e); break; case "material": i = this._invokeOne((function (t) { return t.loadMaterial && t.loadMaterial(e) })); break; case "texture": i = this._invokeOne((function (t) { return t.loadTexture && t.loadTexture(e) })); break; case "skin": i = this.loadSkin(e); break; case "animation": i = this.loadAnimation(e); break; case "camera": i = this.loadCamera(e); break; case "light": i = this.extensions[r.KHR_LIGHTS_PUNCTUAL].loadLight(e); break; default: throw new Error("Unknown type: " + t) }this.cache.add(n, i) } return i }, q.prototype.getDependencies = function (t) { var e = this.cache.get(t); if (!e) { var r = this, n = this.json[t + ("mesh" === t ? "es" : "s")] || []; e = Promise.all(n.map((function (e, n) { return r.getDependency(t, n) }))), this.cache.add(t, e) } return e }, q.prototype.loadBuffer = function (t) { var e = this.json.buffers[t], n = this.fileLoader; if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported."); if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[r.KHR_BINARY_GLTF].body); var i = this.options; return new Promise((function (t, r) { n.load(F(e.uri, i.path), t, void 0, (function () { r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".')) })) })) }, q.prototype.loadBufferView = function (t) { var e = this.json.bufferViews[t]; return this.getDependency("buffer", e.buffer).then((function (t) { var r = e.byteLength || 0, n = e.byteOffset || 0; return t.slice(n, n + r) })) }, q.prototype.loadAccessor = function (t) { var e = this, r = this.json, n = this.json.accessors[t]; if (void 0 === n.bufferView && void 0 === n.sparse) return Promise.resolve(null); var i = []; return void 0 !== n.bufferView ? i.push(this.getDependency("bufferView", n.bufferView)) : i.push(null), void 0 !== n.sparse && (i.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(i).then((function (t) { var i, o = t[0], s = C[n.type], a = O[n.componentType], c = a.BYTES_PER_ELEMENT, u = c * s, l = n.byteOffset || 0, h = void 0 !== n.bufferView ? r.bufferViews[n.bufferView].byteStride : void 0, f = !0 === n.normalized; if (h && h !== u) { var p = Math.floor(l / h), d = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + p + ":" + n.count, m = e.cache.get(d); m || (m = new mo(new a(o, p * h, n.count * h / c), h / c), e.cache.add(d, m)), i = new vo(m, s, l % h / c, f) } else i = new Ft(null === o ? new a(n.count * s) : new a(o, l, n.count * s), s, f); if (void 0 !== n.sparse) { var g = C.SCALAR, v = O[n.sparse.indices.componentType], y = n.sparse.indices.byteOffset || 0, x = n.sparse.values.byteOffset || 0, b = new v(t[1], y, n.sparse.count * g), w = new a(t[2], x, n.sparse.count * s); null !== o && (i = new Ft(i.array.slice(), i.itemSize, i.normalized)); for (var M = 0, S = b.length; M < S; M++) { var _ = b[M]; if (i.setX(_, w[M * s]), s >= 2 && i.setY(_, w[M * s + 1]), s >= 3 && i.setZ(_, w[M * s + 2]), s >= 4 && i.setW(_, w[M * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return i })) }, q.prototype.loadTexture = function (t) { var e, n, i = this.json, o = this.options, s = i.textures[t], a = s.extensions || {}; return (e = a[r.MSFT_TEXTURE_DDS] ? i.images[a[r.MSFT_TEXTURE_DDS].source] : i.images[s.source]).uri && (n = o.manager.getHandler(e.uri)), n || (n = a[r.MSFT_TEXTURE_DDS] ? this.extensions[r.MSFT_TEXTURE_DDS].ddsLoader : this.textureLoader), this.loadTextureImage(t, e, n) }, q.prototype.loadTextureImage = function (t, e, r) { var n = this, i = this.json, o = this.options, s = i.textures[t], a = self.URL || self.webkitURL, c = e.uri, u = !1, l = !0; return "image/jpeg" === e.mimeType && (l = !1), void 0 !== e.bufferView && (c = n.getDependency("bufferView", e.bufferView).then((function (t) { "image/png" === e.mimeType && (l = 6 === new DataView(t, 25, 1).getUint8(0, !1)), u = !0; var r = new Blob([t], { type: e.mimeType }); return c = a.createObjectURL(r) }))), Promise.resolve(c).then((function (t) { return new Promise((function (e, n) { var i = e; !0 === r.isImageBitmapLoader && (i = function (t) { e(new yo(t)) }), r.load(F(t, o.path), i, void 0, n) })) })).then((function (e) { !0 === u && a.revokeObjectURL(c), e.flipY = !1, s.name && (e.name = s.name), l || (e.format = 1022); var r = (i.samplers || {})[s.sampler] || {}; return e.magFilter = P[r.magFilter] || 1006, e.minFilter = P[r.minFilter] || 1008, e.wrapS = I[r.wrapS] || 1e3, e.wrapT = I[r.wrapT] || 1e3, n.associations.set(e, { type: "textures", index: t }), e })) }, q.prototype.assignTexture = function (t, e, n) { var i = this; return this.getDependency("texture", n.index).then((function (o) { if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."), i.extensions[r.KHR_TEXTURE_TRANSFORM]) { var s = void 0 !== n.extensions ? n.extensions[r.KHR_TEXTURE_TRANSFORM] : void 0; if (s) { var a = i.associations.get(o); o = i.extensions[r.KHR_TEXTURE_TRANSFORM].extendTexture(o, s), i.associations.set(o, a) } } t[e] = o })) }, q.prototype.assignFinalMaterial = function (t) { var e = t.geometry, r = t.material, n = void 0 !== e.attributes.tangent, i = void 0 !== e.attributes.color, o = void 0 === e.attributes.normal, s = !0 === t.isSkinnedMesh, a = Object.keys(e.morphAttributes).length > 0, c = a && void 0 !== e.morphAttributes.normal; if (t.isPoints) { var u = "PointsMaterial:" + r.uuid, l = this.cache.get(u); l || (l = new xo, ue.prototype.copy.call(l, r), l.color.copy(r.color), l.map = r.map, l.sizeAttenuation = !1, this.cache.add(u, l)), r = l } else if (t.isLine) { u = "LineBasicMaterial:" + r.uuid; var h = this.cache.get(u); h || (h = new bo, ue.prototype.copy.call(h, r), h.color.copy(r.color), this.cache.add(u, h)), r = h } if (n || i || o || s || a) { u = "ClonedMaterial:" + r.uuid + ":"; r.isGLTFSpecularGlossinessMaterial && (u += "specular-glossiness:"), s && (u += "skinning:"), n && (u += "vertex-tangents:"), i && (u += "vertex-colors:"), o && (u += "flat-shading:"), a && (u += "morph-targets:"), c && (u += "morph-normals:"); var f = this.cache.get(u); f || (f = r.clone(), s && (f.skinning = !0), n && (f.vertexTangents = !0), i && (f.vertexColors = !0), o && (f.flatShading = !0), a && (f.morphTargets = !0), c && (f.morphNormals = !0), this.cache.add(u, f), this.associations.set(f, this.associations.get(r))), r = f } r.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), r.normalScale && !n && (r.normalScale.y = -r.normalScale.y), r.clearcoatNormalScale && !n && (r.clearcoatNormalScale.y = -r.clearcoatNormalScale.y), t.material = r }, q.prototype.getMaterialType = function () { return lo }, q.prototype.loadMaterial = function (t) { var e, n = this, i = this.json, o = this.extensions, s = i.materials[t], a = {}, c = s.extensions || {}, u = []; if (c[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { var l = o[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; e = l.getMaterialType(), u.push(l.extendParams(a, s, n)) } else if (c[r.KHR_MATERIALS_UNLIT]) { var h = o[r.KHR_MATERIALS_UNLIT]; e = h.getMaterialType(), u.push(h.extendParams(a, s, n)) } else { var f = s.pbrMetallicRoughness || {}; if (a.color = new pt(1, 1, 1), a.opacity = 1, Array.isArray(f.baseColorFactor)) { var p = f.baseColorFactor; a.color.fromArray(p), a.opacity = p[3] } void 0 !== f.baseColorTexture && u.push(n.assignTexture(a, "map", f.baseColorTexture)), a.metalness = void 0 !== f.metallicFactor ? f.metallicFactor : 1, a.roughness = void 0 !== f.roughnessFactor ? f.roughnessFactor : 1, void 0 !== f.metallicRoughnessTexture && (u.push(n.assignTexture(a, "metalnessMap", f.metallicRoughnessTexture)), u.push(n.assignTexture(a, "roughnessMap", f.metallicRoughnessTexture))), e = this._invokeOne((function (e) { return e.getMaterialType && e.getMaterialType(t) })), u.push(this._invokeAll((function (e) { return e.extendMaterialParams && e.extendMaterialParams(t, a) }))) } !0 === s.doubleSided && (a.side = 2); var d = s.alphaMode || U; return d === B ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, d === j && (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && e !== Ce && (u.push(n.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new m(1, 1), void 0 !== s.normalTexture.scale && a.normalScale.set(s.normalTexture.scale, s.normalTexture.scale)), void 0 !== s.occlusionTexture && e !== Ce && (u.push(n.assignTexture(a, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (a.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && e !== Ce && (a.emissive = (new pt).fromArray(s.emissiveFactor)), void 0 !== s.emissiveTexture && e !== Ce && u.push(n.assignTexture(a, "emissiveMap", s.emissiveTexture)), Promise.all(u).then((function () { var i; return i = e === v ? o[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new e(a), s.name && (i.name = s.name), i.map && (i.map.encoding = 3001), i.emissiveMap && (i.emissiveMap.encoding = 3001), V(i, s), n.associations.set(i, { type: "materials", index: t }), s.extensions && D(o, i, s), i })) }, q.prototype.loadGeometries = function (t) { var e = this, n = this.extensions, i = this.primitiveCache; function o(t) { return n[r.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function (r) { return X(r, t, e) })) } for (var s, a, c = [], u = 0, l = t.length; u < l; u++) { var h, f = t[u], p = (a = void 0, (a = (s = f).extensions && s.extensions[r.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + a.bufferView + ":" + a.indices + ":" + W(a.attributes) : s.indices + ":" + W(s.attributes) + ":" + s.mode), d = i[p]; if (d) c.push(d.promise); else h = f.extensions && f.extensions[r.KHR_DRACO_MESH_COMPRESSION] ? o(f) : X(new oe, f, e), i[p] = { primitive: f, promise: h }, c.push(h) } return Promise.all(c) }, q.prototype.loadMesh = function (t) { for (var e, r = this, n = this.json.meshes[t], i = n.primitives, o = [], s = 0, a = i.length; s < a; s++) { var c = void 0 === i[s].material ? (void 0 === (e = this.cache).DefaultMaterial && (e.DefaultMaterial = new lo({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: 0 })), e.DefaultMaterial) : this.getDependency("material", i[s].material); o.push(c) } return o.push(r.loadGeometries(i)), Promise.all(o).then((function (e) { for (var o = e.slice(0, e.length - 1), s = e[e.length - 1], a = [], c = 0, u = s.length; c < u; c++) { var l, h = s[c], f = i[c], p = o[c]; if (f.mode === A || f.mode === R || f.mode === L || void 0 === f.mode) !0 !== (l = !0 === n.isSkinnedMesh ? new wo(h, p) : new Je(h, p)).isSkinnedMesh || l.geometry.attributes.skinWeight.normalized || l.normalizeSkinWeights(), f.mode === R ? l.geometry = Y(l.geometry, 1) : f.mode === L && (l.geometry = Y(l.geometry, 2)); else if (f.mode === M) l = new Oo(h, p); else if (f.mode === T) l = new Ao(h, p); else if (f.mode === _) l = new Po(h, p); else { if (f.mode !== w) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + f.mode); l = new zo(h, p) } Object.keys(l.geometry.morphAttributes).length > 0 && H(l, n), l.name = n.name || "mesh_" + t, s.length > 1 && (l.name += "_" + c), V(l, n), r.assignFinalMaterial(l), a.push(l) } if (1 === a.length) return a[0]; var d = new si; for (c = 0, u = a.length; c < u; c++)d.add(a[c]); return d })) }, q.prototype.loadCamera = function (t) { var e, r = this.json.cameras[t], n = r[r.type]; if (n) return "perspective" === r.type ? e = new lr(p.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : "orthographic" === r.type && (e = new no(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), r.name && (e.name = r.name), V(e, r), Promise.resolve(e); console.warn("THREE.GLTFLoader: Missing camera parameters.") }, q.prototype.loadSkin = function (t) { var e = this.json.skins[t], r = { joints: e.joints }; return void 0 === e.inverseBindMatrices ? Promise.resolve(r) : this.getDependency("accessor", e.inverseBindMatrices).then((function (t) { return r.inverseBindMatrices = t, r })) }, q.prototype.loadAnimation = function (t) { for (var e = this.json.animations[t], r = [], n = [], i = [], o = [], s = [], a = 0, c = e.channels.length; a < c; a++) { var u = e.channels[a], l = e.samplers[u.sampler], h = u.target, f = void 0 !== h.node ? h.node : h.id, p = void 0 !== e.parameters ? e.parameters[l.input] : l.input, d = void 0 !== e.parameters ? e.parameters[l.output] : l.output; r.push(this.getDependency("node", f)), n.push(this.getDependency("accessor", p)), i.push(this.getDependency("accessor", d)), o.push(l), s.push(h) } return Promise.all([Promise.all(r), Promise.all(n), Promise.all(i), Promise.all(o), Promise.all(s)]).then((function (r) { for (var n = r[0], i = r[1], o = r[2], s = r[3], a = r[4], c = [], u = 0, l = n.length; u < l; u++) { var h = n[u], f = i[u], p = o[u], d = s[u], m = a[u]; if (void 0 !== h) { var g; switch (h.updateMatrix(), h.matrixAutoUpdate = !0, N[m.path]) { case N.weights: g = Vo; break; case N.rotation: g = Wo; break; case N.position: case N.scale: default: g = qo }var v = h.name ? h.name : h.uuid, y = void 0 !== d.interpolation ? z[d.interpolation] : 2301, x = []; N[m.path] === N.weights ? h.traverse((function (t) { !0 === t.isMesh && t.morphTargetInfluences && x.push(t.name ? t.name : t.uuid) })) : x.push(v); var w = p.array; if (p.normalized) { var M; if (w.constructor === Int8Array) M = 1 / 127; else if (w.constructor === Uint8Array) M = 1 / 255; else if (w.constructor == Int16Array) M = 1 / 32767; else { if (w.constructor !== Uint16Array) throw new Error("THREE.GLTFLoader: Unsupported output accessor component type."); M = 1 / 65535 } for (var S = new Float32Array(w.length), _ = 0, T = w.length; _ < T; _++)S[_] = w[_] * M; w = S } for (_ = 0, T = x.length; _ < T; _++) { var E = new g(x[_] + "." + N[m.path], f.array, w, y); "CUBICSPLINE" === d.interpolation && (E.createInterpolant = function (t) { return new b(this.times, this.values, this.getValueSize() / 3, t) }, E.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), c.push(E) } } } return new Ko(e.name ? e.name : "animation_" + t, void 0, c) })) }, q.prototype.loadNode = function (t) { var e = this.json, n = this.extensions, i = this, o = e.nodes[t]; return function () { var t = []; if (void 0 !== o.mesh && t.push(i.getDependency("mesh", o.mesh).then((function (t) { var e = i._getNodeRef(i.meshCache, o.mesh, t); return void 0 !== o.weights && e.traverse((function (t) { if (t.isMesh) for (var e = 0, r = o.weights.length; e < r; e++)t.morphTargetInfluences[e] = o.weights[e] })), e }))), void 0 !== o.camera && t.push(i.getDependency("camera", o.camera).then((function (t) { return i._getNodeRef(i.cameraCache, o.camera, t) }))), o.extensions && o.extensions[r.KHR_LIGHTS_PUNCTUAL] && void 0 !== o.extensions[r.KHR_LIGHTS_PUNCTUAL].light) { var e = o.extensions[r.KHR_LIGHTS_PUNCTUAL].light; t.push(i.getDependency("light", e).then((function (t) { return i._getNodeRef(i.lightCache, e, t) }))) } return Promise.all(t) }().then((function (e) { var r; if ((r = !0 === o.isBone ? new Qo : e.length > 1 ? new si : 1 === e.length ? e[0] : new It) !== e[0]) for (var s = 0, a = e.length; s < a; s++)r.add(e[s]); if (o.name && (r.userData.name = o.name, r.name = cs.sanitizeNodeName(o.name)), V(r, o), o.extensions && D(n, r, o), void 0 !== o.matrix) { var c = new K; c.fromArray(o.matrix), r.applyMatrix4(c) } else void 0 !== o.translation && r.position.fromArray(o.translation), void 0 !== o.rotation && r.quaternion.fromArray(o.rotation), void 0 !== o.scale && r.scale.fromArray(o.scale); return i.associations.set(r, { type: "nodes", index: t }), r })) }, q.prototype.loadScene = function () { function t(e, r, n, i) { var o = n.nodes[e]; return i.getDependency("node", e).then((function (t) { return void 0 === o.skin ? t : i.getDependency("skin", o.skin).then((function (t) { for (var r = [], n = 0, o = (e = t).joints.length; n < o; n++)r.push(i.getDependency("node", e.joints[n])); return Promise.all(r) })).then((function (r) { return t.traverse((function (t) { if (t.isMesh) { for (var n = [], i = [], o = 0, s = r.length; o < s; o++) { var a = r[o]; if (a) { n.push(a); var c = new K; void 0 !== e.inverseBindMatrices && c.fromArray(e.inverseBindMatrices.array, 16 * o), i.push(c) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[o]) } t.bind(new hs(n, i), t.matrixWorld) } })), t })); var e })).then((function (e) { r.add(e); var s = []; if (o.children) for (var a = o.children, c = 0, u = a.length; c < u; c++) { var l = a[c]; s.push(t(l, e, n, i)) } return Promise.all(s) })) } return function (e) { var r = this.json, n = this.extensions, i = this.json.scenes[e], o = new si; i.name && (o.name = i.name), V(o, i), i.extensions && D(n, o, i); for (var s = i.nodes || [], a = [], c = 0, u = s.length; c < u; c++)a.push(t(s[c], o, r, this)); return Promise.all(a).then((function () { return o })) } }(), t }(); function ps(t) { return (ps = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function ds(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } function ms(t, e) { return (ms = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function gs(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var r, n = xs(t); if (e) { var i = xs(this).constructor; r = Reflect.construct(n, arguments, i) } else r = n.apply(this, arguments); return vs(this, r) } } function vs(t, e) { return !e || "object" !== ps(e) && "function" != typeof e ? ys(t) : e } function ys(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function xs(t) { return (xs = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var bs = ["side", "alphaTest", "transparent", "depthWrite", "shading", "wireframe"], ws = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && ms(t, e) }(o, t); var e, r, n, i = gs(o); function o(t) { var e; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, o), e = i.call(this, t), t = t || {}, bs.forEach((function (r) { var n = t[r]; void 0 !== n && (e[r] = n) }), ys(e)), e } return e = o, (r = [{ key: "onPropertyChange", value: function (t, e) { Object.defineProperty(this, t, { get: function () { return this["_" + t] }, set: function (r) { this["_" + t] = r, e.call(this, r) } }) } }, { key: "clone", value: function (t) { var e = t || new o; return ue.prototype.clone.call(this, e), e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.fog = this.fog, e.lights = this.lights, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e } }]) && ds(e.prototype, r), n && ds(e, n), o }(pe), Ms = r(153), Ss = r.n(Ms), _s = r(154), Ts = r.n(_s); function Es(t) { return (Es = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function As(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } function Rs(t, e) { return (Rs = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function Ls(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var r, n = Ps(t); if (e) { var i = Ps(this).constructor; r = Reflect.construct(n, arguments, i) } else r = n.apply(this, arguments); return Os(this, r) } } function Os(t, e) { return !e || "object" !== Es(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function Ps(t) { return (Ps = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Is = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Rs(t, e) }(o, t); var e, r, n, i = Ls(o); function o(t) { var e; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, o); var r = { vertexShader: Ss.a, fragmentShader: Ts.a, uniforms: { colorMin: { value: new pt(16711680) }, colorMax: { value: new pt(255) }, map: { value: null }, offsetRepeatMin: { value: new it(1, 0, 1, 1) }, offsetRepeatMax: { value: new it(1, 0, .15, 1) }, opacityRange: { value: new m(.5, 1) }, time: { value: 0 }, intensity: { value: 0 }, fallOffDistance: { value: -8 }, rotation: { value: new K }, globalOpacity: { value: 1 } } }; return e = i.call(this, r), t.colorMin && e.uniforms.colorMin.value.setHex(t.colorMin), t.colorMax && e.uniforms.colorMax.value.setHex(t.colorMax), t.map && (e.uniforms.map.value = t.map), t.offsetRepeatMin && e.uniforms.offsetRepeatMin.value.copy(t.offsetRepeatMin), t.offsetRepeatMax && e.uniforms.offsetRepeatMax.value.copy(t.offsetRepeatMax), t.opacityRange && e.uniforms.opacityRange.value.copy(t.opacityRange), void 0 !== t.fallOffDistance && (e.uniforms.fallOffDistance.value = t.fallOffDistance), e.minSpeed = void 0 !== t.minSpeed ? t.minSpeed : .1, e.maxSpeed = void 0 !== t.maxSpeed ? t.maxSpeed : .5, e.transparent = !0, e.depthWrite = !1, e } return e = o, (r = [{ key: "update", value: function (t, e, r) { this.uniforms.intensity.value = t, this.uniforms.rotation.value.copy(e), this.uniforms.globalOpacity.value = r; var n = p.mapLinear(t, 0, 1, this.minSpeed, this.maxSpeed); this.uniforms.time.value += Time.delta * n } }]) && As(e.prototype, r), n && As(e, n), o }(ws); function Cs(t) { return (Cs = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function ks(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } function Ns(t, e) { return (Ns = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function zs(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var r, n = js(t); if (e) { var i = js(this).constructor; r = Reflect.construct(n, arguments, i) } else r = n.apply(this, arguments); return Us(this, r) } } function Us(t, e) { return !e || "object" !== Cs(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function js(t) { return (js = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Bs = new Ri, Fs = [{ map: "/assets/textures/clouds1.jpg", colorRange: [9437429, 9437429], opacityRange: [.025, .4], speedRange: [.01, .5], repeatMin: [1, 1], repeatMax: [.5, 1], fallOffDistance: -8, rotationSpeedRange: [5, 30] }, { map: "/assets/textures/clouds1.jpg", colorRange: [16711746, 16711746], opacityRange: [.1, .36], speedRange: [.0125, .35], repeatMin: [1, 1], repeatMax: [.33, 1], fallOffDistance: -8, rotationSpeedRange: [5, 30] }, { map: "/assets/textures/noise3.jpg", colorRange: [2513405, 2513405], opacityRange: [.1, .4], speedRange: [.0125, .15], repeatMin: [.5, 1], repeatMax: [.25, 1], fallOffDistance: -6, rotationSpeedRange: [2.5, 25] }, { map: "/assets/textures/noise3.jpg", colorRange: [8716527, 8716527], opacityRange: [.075, .4], speedRange: [.015, .225], repeatMin: [.75, 1], repeatMax: [.35, 1], fallOffDistance: -6, rotationSpeedRange: [5, 30] }], Ds = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Ns(t, e) }(o, t); var e, r, n, i = zs(o); function o() { var t, e; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, o), (t = i.call(this)).maps = {}, t.loadMaps(), (new fs).load("/assets/models/cone.glb", (function (r) { (e = r.scene.children[0]).scale.set(2, 1, 2), e.position.z -= 5, e.rotation.z = -Math.PI, t.createLayers(e) })), t } return e = o, (r = [{ key: "loadMaps", value: function () { var t = this;["/assets/textures/clouds1.jpg", "/assets/textures/noise3.jpg"].forEach((function (e) { var r = Bs.load(e); r.wrapS = r.wrapT = 1e3, t.maps[e] = r })) } }, { key: "createLayers", value: function (t) { this.addLayer("clouds2", t.clone(), Fs[1]), this.addLayer("voronoi1", t.clone(), Fs[2]), this.addLayer("voronoi2", t.clone(), Fs[3]) } }, { key: "addLayer", value: function (t, e, r) { var n = e; e.material = new Is({ map: this.maps[r.map], colorMin: r.colorRange[0], colorMax: r.colorRange[1], offsetRepeatMin: new it(1, 0, r.repeatMin[0], r.repeatMin[1]), offsetRepeatMax: new it(1, 0, r.repeatMax[0], r.repeatMax[1]), minSpeed: r.speedRange[0], maxSpeed: r.speedRange[1], opacityRange: new m(r.opacityRange[0], r.opacityRange[1]), fallOffDistance: r.fallOffDistance }), e.name = t, e.rotationSpeedRange = r.rotationSpeedRange, this.add(n) } }, { key: "setRenderOrder", value: function (t) { this.traverse((function (e) { e.renderOrder = t })) } }, { key: "update", value: function (t, e, r) { this.children.forEach((function (n) { if (n.material && n.material.update && n.material.update(t, e, r), n.rotationSpeedRange) { var i = p.mapLinear(t, 0, 1, n.rotationSpeedRange[0], n.rotationSpeedRange[1]); n.rotation.y += p.degToRad(Time.delta * i) } })) } }]) && ks(e.prototype, r), n && ks(e, n), o }(It); function Gs(t) { return (Gs = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function Vs(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } function Hs(t, e) { return (Hs = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function Ws(t) { var e = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (t) { return !1 } }(); return function () { var r, n = Xs(t); if (e) { var i = Xs(this).constructor; r = Reflect.construct(n, arguments, i) } else r = n.apply(this, arguments); return qs(this, r) } } function qs(t, e) { return !e || "object" !== Gs(e) && "function" != typeof e ? function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) : e } function Xs(t) { return (Xs = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } var Ys = new S, Zs = new S, Ks = new S(0, 0, 1), Js = new S, Qs = (new S, new M), $s = new K, ta = new m, ea = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Hs(t, e) }(o, t); var e, r, n, i = Ws(o); function o(t, e, r, n, s) { var a; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, o), (a = i.call(this)).direction = new S(0, 0, 1), a.intensity = 0, a.intensityLerpFactor = .035, a.globalOpacity = 0, a.camera = t, a.add(a.camera), a.starsScrollRange = r, a.cloudsScrollRange = n, a.starfield = new Ki(e), a.camera.add(a.starfield), a.warpTunnel = new Ds, a.camera.add(a.warpTunnel), a.warpTunnel.setRenderOrder(0), a.starfield.setRenderOrder(1), a.background = new pt(s), a.starfield.update(a.intensity, a.camera.position, a.direction, $s), a } return e = o, (r = [{ key: "fadeIn", value: function () { Si.tweenPropertyAsPromise(this, "globalOpacity", 1, 1e3) } }, { key: "update", value: function (t, e, r, n) { this.intensity = p.lerp(this.intensity, t, this.intensityLerpFactor); var i = Si.remapAndClamp(this.intensity, 0, 1, -.03, 0); i = Si.remapAndClamp(n, 0, window.innerHeight, i, 0); var o = Ys.set(0, 0, 1).normalize(), s = Js.set(r.x, .5 * r.y, 1).normalize(); Zs.set(-e.x * i, -e.y * i, 1).normalize(), Ks.lerp(Zs, .05), Qs.setFromUnitVectors(s, Ks), $s.makeRotationFromQuaternion(Qs); var a = Si.remapAndClamp(n, this.cloudsScrollRange[0], this.cloudsScrollRange[1], 1, 0), c = Si.remapAndClamp(n, this.starsScrollRange[0], this.starsScrollRange[1], 1, 0); this.warpTunnel && this.warpTunnel.update(this.intensity, $s, a * this.globalOpacity), this.starfield && this.starfield.update(this.intensity, this.camera.position, o, $s, c * this.globalOpacity), ta.lerp(e, Si.remapAndClamp(n, 0, window.innerHeight, .01, 0)), this.camera.position.y = -n / 700 + ta.y, this.camera.position.x = -ta.x } }]) && Vs(e.prototype, r), n && Vs(e, n), o }(xi); function ra(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } var na = function () { function t(e) { var r = this; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.renderLoop = new pi({ canvas: e.canvas, autoClear: !1, clearColor: 16777215, width: window.innerWidth, height: window.innerHeight, onUpdate: this.onUpdate.bind(this), onRender: this.onRender.bind(this), onResize: function (t, e) { }, maxPixelRatio: 1.5 }), this.needsRender = !0, this.followButton = e.followButton, this.buttonElement = e.button, this.idleIntensity = e.idleIntensity, this.clickIntensity = e.clickIntensity, this.buttonIntensity = e.buttonIntensity, this.fpsCounter = new mi({ enabled: !1 }), this.camera = new lr(60, window.innerWidth / window.innerHeight, .01, 500), this.renderLoop.cameras.push(this.camera), this.camera.position.set(0, 0, -4), this.camera.lookAt(new S(0, 0, 0)), this.scene = new ea(this.camera, e.starCount, e.starsScrollRange, e.cloudsScrollRange, e.backgroundColor), this.intensity = this.idleIntensity, this.buttonCenter = new m, this.buttonRect = this.buttonElement.getBoundingClientRect(), this.mousePos = new m, this.normalizedMousePos = new m, setTimeout((function () { r.updateButtonCenter() }), 1), window.addEventListener("mousemove", (function (t) { r.mousePos.set(t.pageX, t.pageY - (window.pageYOffset || window.scrollY)), r.normalizedMousePos.set(p.mapLinear(r.mousePos.x, 0, window.innerWidth, -1, 1), p.mapLinear(r.mousePos.y, 0, window.innerHeight, 1, -1)) })), document.body.addEventListener("mousedown", (function (t) { r.isPressingDown = !0 })), document.body.addEventListener("mouseup", (function (t) { r.isPressingDown = !1 })), window.addEventListener("resize", (function () { r.updateButtonCenter() })), Object.defineProperty(this, "starsScrollRange", { get: function () { return r.scene.starsScrollRange }, set: function (t) { r.scene.starsScrollRange = t } }), Object.defineProperty(this, "cloudsScrollRange", { get: function () { return r.scene.cloudsScrollRange }, set: function (t) { r.scene.cloudsScrollRange = t } }) } var e, r, n; return e = t, (r = [{ key: "start", value: function () { this.renderLoop.start(), this.scene.fadeIn() } }, { key: "updateButtonCenter", value: function () { var t = this.buttonElement.getBoundingClientRect(); this.buttonRect = { top: t.top, left: t.left, height: t.height, width: t.width }, this.buttonRect.top += window.pageYOffset; var e = this.buttonRect.left + this.buttonRect.width / 2, r = this.buttonRect.top + this.buttonRect.height / 2, n = p.mapLinear(e, 0, window.innerWidth, -1, 1), i = p.mapLinear(r, 0, window.innerHeight, 1, -1); this.buttonCenter.set(n, i) } }, { key: "isHoveringDownloadButton", value: function (t) { return this.mousePos.x >= this.buttonRect.left && this.mousePos.x <= this.buttonRect.left + this.buttonRect.width && this.mousePos.y >= this.buttonRect.top - t && this.mousePos.y <= this.buttonRect.top - t + this.buttonRect.height } }, { key: "onUpdate", value: function () { var t = this, e = window.pageYOffset || window.scrollY; e <= Math.max(this.starsScrollRange[1], this.cloudsScrollRange[1]) ? this.needsRender = !0 : setTimeout((function () { t.needsRender = !1 }), 1), this.isPressingDown ? (this.intensity += .1, this.intensity = Math.min(this.intensity, this.clickIntensity), this.isHoveringDownloadButton(e) && (this.intensity = this.buttonIntensity)) : this.isHoveringDownloadButton(e) ? this.intensity = this.buttonIntensity : this.intensity = this.idleIntensity, this.scene.update(this.intensity, this.normalizedMousePos, this.buttonCenter, e), this.fpsCounter.update(), this.followButton && this.camera.setViewOffset(window.innerWidth, window.innerHeight, 0, e, window.innerWidth, window.innerHeight) } }, { key: "onRender", value: function () { this.needsRender && this.renderLoop.renderScene(this.scene, this.camera) } }]) && ra(e.prototype, r), n && ra(e, n), t }(), ia = function (t) { var e = this; this.app = new na({ canvas: t.canvas, button: t.button, followButton: void 0 === t.followButton || t.followButton, starCount: void 0 !== t.starCount ? t.starCount : 1500, starsScrollRange: void 0 !== t.starsScrollRange ? t.starsScrollRange : [window.innerHeight, 2 * window.innerHeight], cloudsScrollRange: void 0 !== t.cloudsScrollRange ? t.cloudsScrollRange : [window.innerHeight, 2 * window.innerHeight], idleIntensity: void 0 !== t.idleIntensity ? t.idleIntensity : 0, clickIntensity: void 0 !== t.clickIntensity ? t.clickIntensity : 0, buttonIntensity: void 0 !== t.buttonIntensity ? t.buttonIntensity : 1.5, backgroundColor: void 0 !== t.backgroundColor ? t.backgroundColor : "#070E28" }), void 0 === t.canvas && console.error("WebGLBackground: canvas element is missing."), void 0 === t.button && console.error("WebGLBackground: button element is missing."), Object.defineProperty(this, "starsScrollRange", { set: function (t) { e.app.starsScrollRange = t } }), Object.defineProperty(this, "cloudsScrollRange", { set: function (t) { e.app.cloudsScrollRange = t } }), this.app.start() }; ia.prototype = { start: function () { this.app.start() } }, window.WebGLBackground = ia }]);